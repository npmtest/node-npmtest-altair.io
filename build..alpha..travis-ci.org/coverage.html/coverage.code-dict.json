{"/home/travis/build/npmtest/node-npmtest-altair.io/test.js":"/* istanbul instrument in package npmtest_altair_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-altair.io/lib.npmtest_altair.io.js":"/* istanbul instrument in package npmtest_altair_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_altair_io = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_altair_io = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-altair.io/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-altair.io && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_altair_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_altair_io\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_altair_io.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_altair_io.rollup.js'] =\n            local.assetsDict['/assets.npmtest_altair_io.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_altair_io.__dirname + '/lib.npmtest_altair_io.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/altair.js":"#!/usr/bin/env node\n\n/**\n * This file exists to bootstrap the dojo environment, which in turn bootstraps altair. Because you can pass any bootstrap\n * file you want with --bootstrap\n *\n * @type {exports}\n */\n\nvar path = require('path'),\n    argv = require('yargs').usage('Altair - Experiences of Everything\\n Usage: $0').options('env', {\n        'default': 'dev',\n        describe:  'specify the environment you want to run'\n    }).options('bootstrap', {\n        'default': 'core/bootstrap',\n        describe:  'change the bootstrap file used by Altair'\n    }).options('safe', {\n        'default': false,\n        describe:  'Boot in safe mode (only core modules, etc.)'\n    }).boolean('help')\n        .alias('help', 'h')\n        .describe('help', 'display help')\n        .boolean('test')\n        .describe('test', 'run our unit tests').argv;\n\nif (argv.help) {\n    require('yargs').showHelp();\n    return;\n}\n\nvar base = ''; //in case we want to install everything somewhere outside of the altair.io dir\n\n// Configuration Object for Dojo Loader:\ndojoConfig = {\n    baseUrl: path.resolve(__dirname), // Where we will put our packages\n    async:   1, // We want to make sure we are using the \"modern\" loader\n    has:     {\n        'config-tlmSiblingOfDojo': 0, //for relative path resolution from require() - setting to true breaks it, dojo.js 944\n        'dojo-publish-privates': 1 // for haaalp!\n    },\n    packages: [\n        {\n            name:     'lodash',\n            location: path.join(base, \"core/lib/lodash\"),\n            main:     'lodash'\n        },\n        {\n            name:     \"dojo\",\n            location: path.join(base, \"core/lib/dojo\")\n        },\n        {\n            name:     \"altair\",\n            location: path.join(base, \"core/lib/altair\")\n        },\n        {\n            name:     \"core\",\n            location: path.join(base, \"core\")\n        },\n        {\n            name:     \"doh\",\n            location: path.join(base, \"core/lib/doh\")\n        },\n        {\n            name:     \"apollo\",\n            location: path.join(base, \"core/lib/apollo\")\n        }\n    ],\n    map:      {\n        \"*\": {\n            'dojo/_base/declare': 'altair/facades/declare',\n            'dojo/Deferred':      'altair/Deferred',\n            'doh/runner':         'altair/test'\n        }\n\n    },\n    deps:     [\n        argv.bootstrap\n    ]\n};\n\nif (argv.t || argv.test) {\n    dojoConfig.deps = ['core/bootstrap-test'];\n}\n\n// Only exists to pass env to the bootstrap script (altair does not access any GLOBALS)\nglobal.env = argv.env;\nglobal.safe = argv.safe;\nglobal.cwd = argv.cwd || process.cwd();\n\n// Now load the Dojo loader\nrequire(\"./core/lib/dojo/dojo.js\");\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/bin/altair.js":"#!/usr/bin/env node\nrequire('../altair.js');","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/bootstrap.js":"/**\n * Bootstrap Altair instances based on a config\n */\nrequire(['altair/Altair',\n    'require',\n    'altair/cartridges/Foundry',\n    'altair/facades/mixin',\n    'altair/facades/home',\n    'altair/plugins/node!debug',\n    'altair/plugins/node!path',\n    'altair/plugins/node!fs',\n    'altair/plugins/node!module',\n    'altair/plugins/node!config-extend',\n    'lodash',\n    'altair/plugins/config!core/config/altair.json?env=' + global.env],\n\n    function (Altair, require, Foundry, mixin, home, debugUtil, path, fs, Module, extend, _, config) {\n\n        /**\n         * Simple debug logging\n         */\n        debugUtil.enable(config.debug);\n        debug       = debugUtil('altair:Altair');\n        require.log = debug; //overrides the require.log used by dojo to provide much better high level reporting\n\n        /**\n         * Make sure our CWD is set\n         */\n        if(global.cwd !== process.cwd()) {\n            process.chdir(global.cwd);\n        }\n\n        /**\n         * NPM has zero dependency injection so it's easier to create a central place for altair to manage\n         * all node dependencies than it is to configure npm (at all). This is where all the dependencies\n         * for altair modules/themes/widgets/sites will be installed.\n         */\n        var homePath        = path.join(home(), '.altair'),\n            homeConfigPath  = path.join(homePath, 'altair.json'),\n            homePackagePath = path.join(homePath, 'package.json'),\n            appConfigPath   = path.join(process.cwd(), 'altair.json');\n\n        //does our run dir exist? move this to better installer\n        try {\n\n            fs.statSync(homePath);\n\n        } catch (e) {\n\n            debug('altair first run, creating ' + homePath);\n\n            //create home\n            fs.mkdirSync(homePath);\n            fs.writeFileSync(homeConfigPath, JSON.stringify({\n                description: 'See https://github.com/liquidg3/altair/blob/master/docs/config.md for help on configuring altair.',\n                'default': {\n                    paths:       {\n                        core: 'core'\n                    }\n                }\n            }, null, 4));\n\n            fs.writeFileSync(homePackagePath, JSON.stringify({\n                name:        'altair-global',\n                description: 'Placeholder altair config to hold dependencies of all installed modules.'\n            }, null, 4));\n\n\n        }\n\n        /**\n         * Mixin config from app/config/altair.json if there is one\n         */\n        require([\n            'altair/plugins/config!' + appConfigPath + '?env=' + global.env,\n            'altair/plugins/config!' + homeConfigPath + '?env=' + global.env\n        ], function (appConfig, homeConfig) {\n\n            var paths = [],\n                altair,\n                app,\n                foundry;\n\n            config.paths.home = homePath; //always have a home path\n\n            //inform us about our environment\n            debug('current environment is \"' + global.env + '\".');\n\n            //mixin configs, cwd config wins!\n            if(appConfig) {\n\n                //if the cwdConfig exists, it is our new \"home\" folder and everything will run/install from there\n                debug('app detected - loading config @ ' + appConfigPath);\n\n                extend(config, appConfig);\n\n                //our new home (also make sure it's in the paths)\n                app = process.cwd();\n                config.paths.app = app;\n\n            } else {\n\n                debug('loading config @ ' + homeConfigPath);\n                config = mixin(config, homeConfig);\n\n            }\n\n            /**\n             * Lets you configure how much error reporting to do.\n             *\n             * @type {number}\n             */\n            Error.stackTraceLimit = config.stackTraceLimit || Infinity;\n\n\n            //set debug config again\n            debugUtil.names = [];\n            debugUtil.skips = [];\n            debugUtil.enable(config.debug);\n\n            /**\n             * Make sure npm can look at our current app directory, fallback to home. But NEVER both.\n             *\n             * @type {string}\n             */\n            process.env['NODE_PATH'] += \":\" + path.join(homePath, 'node_modules');\n            if(app) { //app (which is cwd if altair.json exists) is a valid lookup spot\n                process.env['NODE_PATH'] += \":\" + path.join(app, 'node_modules');\n            }\n            Module._initPaths(); // terrible\n\n            /**\n             * Bring in the packages from the config, this should point to at least app and core. Even though core is not\n             * needed, this array is also used to build our lookup paths in altair. Altair only needs their names since\n             * dojo's define() and require() can map it to their paths.\n             */\n            require({\n                paths: config.paths\n            });\n\n            //cartridges are given a key in the config so they can be overridden easier.\n            config.cartridges = _.toArray(config.cartridges);\n\n            //paths by name for altair\n            Object.keys(config.paths).forEach(function (name) {\n                paths.push(name);\n            });\n\n            /**\n             * Startup the cartridge factory and create the cartridges, then add\n             * them to altair.\n             */\n            altair  = new Altair({ paths: paths, safeMode: global.safe, home: homePath });\n            foundry = new Foundry(altair);\n\n            if (altair.safeMode) {\n                debug('-- starting altair in safe mode --');\n            }\n\n            debug('creating cartridge foundry. adding ' +  config.cartridges.length + ' cartridges.');\n\n            foundry.build(config.cartridges).then(function (cartridges) {\n\n                debug('cartridges created. adding to altair for startup.');\n\n                /**\n                 * Add cartridges\n                 */\n                return altair.addCartridges(cartridges).then(function () {\n\n                    debug('cartridges started.');\n\n                });\n\n            }).otherwise(debug);\n\n        });\n\n\n    });","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/locales/en.js":"{}","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/altair/Altair.js":"/**\n * Well, this is it... Altair in its entirety. The whole platform is simply a cartridge loader. These cartridges are\n * responsible for enhancing the environment in various ways. It should be really easy to augment the platform at a very\n * low level this way. Chances are that if you need to add new functionality into the platform you should be doing it\n * as a module. The only things that should be cartridges are components that need to exist before the module system\n * is ready. Currently, this is things like Nexus (Dependency Injection), Apollo (ORM), Cache, Database, and a few others.\n * See core/config/altair.json to see the current config.\n */\ndefine(['altair/facades/declare',\n    'altair/Deferred',\n    'lodash',\n    'altair/facades/hitch',\n    'altair/facades/home',\n    'altair/facades/all',\n    'altair/facades/when',\n    'altair/plugins/node!path',\n    'altair/events/Emitter'\n],\n    function (declare, Deferred, _, hitch, home, all, when, path, Emitter) {\n\n        //helper for us elsewhere *find better place*\n        _.isObjectLiteral = function (_obj) {\n            var _test  = _obj;\n            return (  typeof _obj !== 'object' || _obj === null ?\n                false :\n                (\n                    (function () {\n                        while (!false) {\n                            if (  Object.getPrototypeOf( _test = Object.getPrototypeOf(_test)  ) === null) {\n                                break;\n                            }\n                        }\n                        return Object.getPrototypeOf(_obj) === _test;\n                    })()\n                    )\n                );\n        };\n\n        \"use strict\";\n\n        return declare([Emitter], {\n\n            _cartridges: null,\n            env:         'dev',\n            paths:       null,\n            safeMode:    false,\n            home:       '',\n\n            constructor: function (options) {\n\n                var _options = options || {};\n\n                this.paths = _options.paths || [];\n                this.env = _options.env || 'dev';\n                this.safeMode = _.has(_options, 'safeMode') ? _options.safeMode : false;\n                this.home = _.has(_options, 'home') ? _options.home : path.join(home(), '.altair');\n\n                this._cartridges = {};\n            },\n\n            /**\n             * Resolve a path against  the last path in my paths. home by default\n             *\n             * @param p String\n             * @returns {String}\n             */\n            resolvePath: function (p) {\n\n                var resolved = p;\n\n                //if it starts with ./, then assume it's from the current working directory\n                if (p[0] === '.') {\n                    resolved = path.join(process.cwd(), p);\n                }\n                //relative paths (no /) all look from app or home\n                else if(p[0] != path.sep) {\n                    resolved = path.join(require.toUrl(this.paths[this.paths.length - 1]), p);\n                }\n\n                return resolved;\n\n            },\n\n            /**\n             * Add an un-started cartridge and I'll add it to the system and start it up. optionally i will execute it.\n             *\n             * @param cartridge\n             * @param execute should I execute the cartridge after startup??\n             * @returns {altair.Promise}\n             */\n            addCartridge: function (cartidge, execute) {\n\n                this._cartridges[cartidge.name] = cartidge;\n\n                return cartidge.startup().then(function (cartridge) {\n                    if (execute !== false) {\n                        return cartridge.execute();\n                    } else {\n                        return cartridge;\n                    }\n                });\n\n\n            },\n\n            /**\n             * Removes a cartridge, but tears it down first.\n             *\n             * @param key\n             * @returns {altair.Promise}\n             */\n            removeCartridge: function (name) {\n\n                var def = this.cartridge(name).teardown();\n\n                delete this._cartridges[name];\n\n                return def;\n\n            },\n\n            /**\n             * All the cartridges by name.\n             *\n             * @returns {object}\n             */\n            cartridges: function () {\n                return this._cartridges;\n            },\n\n            /**\n             * Get a cartridge by it's key\n             *\n             * @param key\n             * @returns {*|null}\n             */\n            cartridge: function (name) {\n                return this._cartridges[name] || null;\n            },\n\n            /**\n             * Is this cartridge loaded?\n             *\n             * @param name\n             * @returns {boolean}\n             */\n            hasCartridge: function (name) {\n                return !!this._cartridges[name];\n            },\n\n            /**\n             * Quick check if all the cartridges are loaded. If any single one is missing,\n             * it returns false.\n             *\n             * @param namees\n             * @returns {boolean}\n             */\n            hasCartridges: function (namees) {\n\n                var i;\n\n                for (i = 0; i < namees.length; i++) {\n                    if (!this.hasCartridge(namees[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            /**\n             * Add a collection of cartridges. Each cartridge will be started up AFTER the one before it. This is to ensure\n             * dependencies are in place before dependants are loaded.\n             *\n             * @param cartridges\n             * @returns {altair.Promise}\n             */\n            addCartridges: function (cartridges) {\n\n                var deferred = new Deferred(),\n                    deferred2 = new Deferred(),\n                    started = [],\n                    add = hitch(this, function () {\n\n                        var cartridge = cartridges.shift();\n\n                        if (cartridge) {\n                            started.push(cartridge);\n                            this.addCartridge(cartridge, false).then(add).otherwise(hitch(deferred, 'reject'));\n                        } else {\n                            deferred.resolve(this);\n                        }\n                    });\n\n                add();\n\n                //execute module\n                var execute = hitch(this, function () {\n\n                    var cartridge = started.shift();\n\n                    if (cartridge) {\n                        when(cartridge.execute()).then(execute).otherwise(function (err) {\n                            deferred2.reject(err);\n                        });\n                    } else {\n                        deferred2.resolve(this);\n                    }\n                });\n\n                return deferred.then(hitch(this, function () {\n\n                    execute();\n                    return deferred2;\n\n                }));\n\n            },\n\n            /**\n             * Teardown every cartridge.\n             *\n             * @returns {*}\n             */\n            teardown: function () {\n\n                var l = _.map(this._cartridges, function (c) {\n                    return c.teardown();\n                });\n\n                return all(l);\n\n            },\n\n            toString: function () {\n                return '[object Altair]';\n            }\n\n        });\n    });\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/altair/Deferred.js":"/**\n * What this class does differently than dojo/Deferred:\n *   * supports optional error logging suppression is reject()\n *   * step() alias to make for pretty codez\n *   * hasWaiting()\n */\ndefine([\n    \"dojo/has\",\n    \"dojo/_base/lang\",\n    \"dojo/errors/CancelError\",\n    \"dojo/promise/Promise\",\n    'altair/plugins/node!debug',\n    \"dojo/has!config-deferredInstrumentation?dojo/promise/instrumentation\"\n], function(has, lang, CancelError, Promise, debug, instrumentation){\n\n    debug.enable('altair:Deferred');\n    debug = debug('altair:Deferred');\n\n    // module:\n    //\t\tdojo/Deferred\n\n    var PROGRESS = 0,\n        RESOLVED = 1,\n        REJECTED = 2;\n    var FULFILLED_ERROR_MESSAGE = \"This deferred has already been fulfilled.\";\n\n    var freezeObject = Object.freeze || function(){};\n\n    var signalWaiting = function(waiting, type, result, rejection, deferred, ignoreErrors){\n        if(has(\"config-deferredInstrumentation\")){\n            if(!ignoreErrors && type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){\n                Deferred.instrumentRejected(result, false, rejection, deferred);\n            }\n        }\n\n        for(var i = 0; i < waiting.length; i++){\n            signalListener(waiting[i], type, result, rejection, ignoreErrors);\n        }\n    };\n\n    var signalListener = function(listener, type, result, rejection, ignoreErrors){\n        var func = listener[type];\n        var deferred = listener.deferred;\n        ignoreErrors = ignoreErrors || deferred.ignoreErrors;\n        if(func){\n            try{\n\n                //if this is a deferredsignaler, pass through error status\n                if(func.hasOwnProperty('__ignoreErrors')) {\n                    func.__ignoreErrors = ignoreErrors;\n                }\n                var newResult = func(result);\n                if(type === PROGRESS){\n                    if(typeof newResult !== \"undefined\"){\n                        signalDeferred(deferred, type, newResult);\n                    }\n                }else{\n                    if(newResult && typeof newResult.then === \"function\"){\n                        listener.cancel = newResult.cancel;\n                        newResult.then(\n                            // Only make resolvers if they're actually going to be used\n                            makeDeferredSignaler(deferred, RESOLVED,ignoreErrors),\n                            makeDeferredSignaler(deferred, REJECTED,ignoreErrors),\n                            makeDeferredSignaler(deferred, PROGRESS,ignoreErrors));\n                        return;\n                    }\n                    signalDeferred(deferred, RESOLVED, newResult, ignoreErrors);\n                }\n            }catch(error){\n                debug(error);\n                signalDeferred(deferred, REJECTED, error, ignoreErrors);\n            }\n        }else{\n            signalDeferred(deferred, type, result, ignoreErrors);\n        }\n\n        if(has(\"config-deferredInstrumentation\")){\n            if(!ignoreErrors && type === REJECTED && Deferred.instrumentRejected){\n                Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);\n            }\n        }\n    };\n\n    var makeDeferredSignaler = function(deferred, type, ignoreErrors){\n\n        var signaler = function(value){\n            signalDeferred(deferred, type, value, signaler.__ignoreErrors);\n        };\n\n        signaler.__ignoreErrors = ignoreErrors;\n\n        return signaler;\n    };\n\n    var signalDeferred = function(deferred, type, result, ignoreErrors){\n        ignoreErrors = ignoreErrors || deferred.ignoreErrors;\n        if(!deferred.isCanceled()){\n            switch(type){\n                case PROGRESS:\n                    deferred.progress(result);\n                    break;\n                case RESOLVED:\n                    deferred.resolve(result);\n                    break;\n                case REJECTED:\n                    if(ignoreErrors) {\n                        deferred.reject(result, false);\n                    } else {\n                        deferred.reject(result);\n\n                    }\n                    break;\n            }\n        }\n    };\n\n    var Deferred = function(canceler){\n        // summary:\n        //\t\tCreates a new deferred. This API is preferred over\n        //\t\t`dojo/_base/Deferred`.\n        // description:\n        //\t\tCreates a new deferred, as an abstraction over (primarily)\n        //\t\tasynchronous operations. The deferred is the private interface\n        //\t\tthat should not be returned to calling code. That's what the\n        //\t\t`promise` is for. See `dojo/promise/Promise`.\n        // canceler: Function?\n        //\t\tWill be invoked if the deferred is canceled. The canceler\n        //\t\treceives the reason the deferred was canceled as its argument.\n        //\t\tThe deferred is rejected with its return value, or a new\n        //\t\t`dojo/errors/CancelError` instance.\n\n        // promise: dojo/promise/Promise\n        //\t\tThe public promise object that clients can add callbacks to.\n        var promise = this.promise = new Promise();\n\n        var deferred = this;\n        var fulfilled, result, rejection;\n        var canceled = false;\n        var waiting = [];\n\n        this.ignoreErrors = false;\n\n        if(!this.ignoreErrors && !has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n            Error.captureStackTrace(deferred, Deferred);\n            Error.captureStackTrace(promise, Deferred);\n        }\n\n        this.isResolved = promise.isResolved = function(){\n            // summary:\n            //\t\tChecks whether the deferred has been resolved.\n            // returns: Boolean\n\n            return fulfilled === RESOLVED;\n        };\n\n        this.isRejected = promise.isRejected = function(){\n            // summary:\n            //\t\tChecks whether the deferred has been rejected.\n            // returns: Boolean\n\n            return fulfilled === REJECTED;\n        };\n\n        this.isFulfilled = promise.isFulfilled = function(){\n            // summary:\n            //\t\tChecks whether the deferred has been resolved or rejected.\n            // returns: Boolean\n\n            return !!fulfilled;\n        };\n\n        this.isCanceled = promise.isCanceled = function(){\n            // summary:\n            //\t\tChecks whether the deferred has been canceled.\n            // returns: Boolean\n\n            return canceled;\n        };\n\n        this.progress = function(update, strict){\n            // summary:\n            //\t\tEmit a progress update on the deferred.\n            // description:\n            //\t\tEmit a progress update on the deferred. Progress updates\n            //\t\tcan be used to communicate updates about the asynchronous\n            //\t\toperation before it has finished.\n            // update: any\n            //\t\tThe progress update. Passed to progbacks.\n            // strict: Boolean?\n            //\t\tIf strict, will throw an error if the deferred has already\n            //\t\tbeen fulfilled and consequently no progress can be emitted.\n            // returns: dojo/promise/Promise\n            //\t\tReturns the original promise for the deferred.\n\n            if(!fulfilled){\n                signalWaiting(waiting, PROGRESS, update, null, deferred);\n                return promise;\n            }else if(strict === true){\n                throw new Error(FULFILLED_ERROR_MESSAGE);\n            }else{\n                return promise;\n            }\n        };\n\n        this.resolve = function(value, strict){\n            // summary:\n            //\t\tResolve the deferred.\n            // description:\n            //\t\tResolve the deferred, putting it in a success state.\n            // value: any\n            //\t\tThe result of the deferred. Passed to callbacks.\n            // strict: Boolean?\n            //\t\tIf strict, will throw an error if the deferred has already\n            //\t\tbeen fulfilled and consequently cannot be resolved.\n            // returns: dojo/promise/Promise\n            //\t\tReturns the original promise for the deferred.\n\n            if(!fulfilled){\n                // Set fulfilled, store value. After signaling waiting listeners unset\n                // waiting.\n                signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);\n                waiting = null;\n                return promise;\n            }else if(strict === true){\n                throw new Error(FULFILLED_ERROR_MESSAGE);\n            }else{\n                return promise;\n            }\n        };\n\n        /**\n         * Now passing strict as false with disable error reporting\n         * @type {reject}\n         */\n        var reject = this.reject = function(error, strict){\n            // summary:\n            //\t\tReject the deferred.\n            // description:\n            //\t\tReject the deferred, putting it in an error state.\n            // error: any\n            //\t\tThe error result of the deferred. Passed to errbacks.\n            // strict: Boolean?\n            //\t\tIf strict, will throw an error if the deferred has already\n            //\t\tbeen fulfilled and consequently cannot be rejected.\n            // returns: dojo/promise/Promise\n            //\t\tReturns the original promise for the deferred.\n\n\n            if(!fulfilled){\n                if(strict === false) {\n                    this.ignoreErrors = true;\n                    promise.ignoreErrors = true;\n                }\n                if(!this.ignoreErrors && has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n//                    error.__hasBeenLogged = true;\n//                    console.error(error.stack || error);\n                    Error.captureStackTrace(rejection = {}, reject);\n                }\n                signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred, this.ignoreErrors);\n                waiting = null;\n                return promise;\n            }else if(strict === true){\n                throw new Error(FULFILLED_ERROR_MESSAGE);\n            }else{\n                return promise;\n            }\n        };\n\n        this.hasWaiting = function () {\n            return waiting.length > 0;\n        };\n\n        this.then = promise.then = function(callback, errback, progback){\n            // summary:\n            //\t\tAdd new callbacks to the deferred.\n            // description:\n            //\t\tAdd new callbacks to the deferred. Callbacks can be added\n            //\t\tbefore or after the deferred is fulfilled.\n            // callback: Function?\n            //\t\tCallback to be invoked when the promise is resolved.\n            //\t\tReceives the resolution value.\n            // errback: Function?\n            //\t\tCallback to be invoked when the promise is rejected.\n            //\t\tReceives the rejection error.\n            // progback: Function?\n            //\t\tCallback to be invoked when the promise emits a progress\n            //\t\tupdate. Receives the progress update.\n            // returns: dojo/promise/Promise\n            //\t\tReturns a new promise for the result of the callback(s).\n            //\t\tThis can be used for chaining many asynchronous operations.\n\n            var listener = [progback, callback, errback];\n            // Ensure we cancel the promise we're waiting for, or if callback/errback\n            // have returned a promise, cancel that one.\n            listener.cancel = promise.cancel;\n            listener.deferred = new Deferred(function(reason){\n                // Check whether cancel is really available, returned promises are not\n                // required to expose `cancel`\n                return listener.cancel && listener.cancel(reason);\n            });\n\n\n            listener.deferred.ignoreErrors = this.ignoreErrors;\n\n            if(fulfilled && !waiting){\n                signalListener(listener, fulfilled, result, rejection);\n            }else{\n                waiting.push(listener);\n            }\n            return listener.deferred.promise;\n        };\n\n        this.otherwise = promise.step = function (errback, callback, progback) {\n            return this.then(callback, errback, progback);\n        };\n\n        this.step = promise.step = function (progback, callback ,errback) {\n            return this.then(callback, errback, progback);\n        };\n\n        this.always = function(callbackOrErrback){\n            // summary:\n            //\t\tAdd a callback to be invoked when the promise is resolved\n            //\t\tor rejected.\n            // callbackOrErrback: Function?\n            //\t\tA function that is used both as a callback and errback.\n            // returns: dojo/promise/Promise\n            //\t\tReturns a new promise for the result of the callback/errback.\n\n            return this.then(callbackOrErrback, callbackOrErrback);\n        };\n\n\n        this.cancel = promise.cancel = function(reason, strict){\n            // summary:\n            //\t\tInform the deferred it may cancel its asynchronous operation.\n            // description:\n            //\t\tInform the deferred it may cancel its asynchronous operation.\n            //\t\tThe deferred's (optional) canceler is invoked and the\n            //\t\tdeferred will be left in a rejected state. Can affect other\n            //\t\tpromises that originate with the same deferred.\n            // reason: any\n            //\t\tA message that may be sent to the deferred's canceler,\n            //\t\texplaining why it's being canceled.\n            // strict: Boolean?\n            //\t\tIf strict, will throw an error if the deferred has already\n            //\t\tbeen fulfilled and consequently cannot be canceled.\n            // returns: any\n            //\t\tReturns the rejection reason if the deferred was canceled\n            //\t\tnormally.\n\n            if(!fulfilled){\n                // Cancel can be called even after the deferred is fulfilled\n                if(canceler){\n                    var returnedReason = canceler(reason);\n                    reason = typeof returnedReason === \"undefined\" ? reason : returnedReason;\n                }\n                canceled = true;\n                if(!fulfilled){\n                    // Allow canceler to provide its own reason, but fall back to a CancelError\n                    if(typeof reason === \"undefined\"){\n                        reason = new CancelError();\n                    }\n                    reject(reason);\n                    return reason;\n                }else if(fulfilled === REJECTED && result === reason){\n                    return reason;\n                }\n            }else if(strict === true){\n                throw new Error(FULFILLED_ERROR_MESSAGE);\n            }\n        };\n\n        freezeObject(promise);\n    };\n\n    Deferred.prototype.toString = function(){\n        // returns: String\n        //\t\tReturns `[object Deferred]`.\n\n        return \"[object Deferred]\";\n    };\n\n    if(instrumentation){\n        instrumentation(Deferred);\n    }\n\n    return Deferred;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/altair/Lifecycle.js":"/**\n * Altair's base LifeCycle mixin. Anytime your object has a 3 part lifecycle (setup, execute, teardown)\n * you should mixin this class. It returns dojo/Deferred's for each method for you, but chances are\n * you'll need to override one of these methods. Each one, by default, will return an auto-resolved\n * instance of a dojo/Deferred. That way usage is consistent, whether you override the method or not.\n *\n * Here is how I would implement my overridden startup()\n *\n * ...\n *\n * startup: function (options) {\n *\n *      //options are optional, fallback to the ones already set\n *      options = options || this.options;\n *\n *      //creating your own deferred will stop the auto-resolve behavior\n *      this.deferred = new Deferred();\n *\n *      //run your complicated, time consuming setup\n *      fs.someLongComplicatedAsyncProcess(this.hitch(function (results) {\n *\n *          //do something with your results\n *          this.results = results;\n *\n *          //always resolve and pass yourself.\n *          this.deferred.resolve(this);\n *\n *      }));\n *\n *      return this.inherited(arguments);\n *\n * }\n *\n * ...\n *\n * REMEMBER: the purpose of startup() is to to ensure execute() has everything it needs to do its job. Don't abuse startup().\n *\n */\ndefine(['altair/facades/declare',\n        './mixins/_DeferredMixin',\n        'lodash'],\n            function (declare,\n                      _DeferredMixin) {\n\n    \"use strict\";\n\n\n    return declare([_DeferredMixin], {\n\n        deferred:       null,\n        options:        null,\n\n        //deferred tracking\n        _startupDeferred: null,\n\n        constructor: function (options) {\n            this.options = options;\n        },\n\n        /**\n         * Put anything that needs to be done (configuring, setup, etc.) before your lifecycle is executed.\n         *\n         * Startup always returns an altair/Deferred. If one does not exist (meaning you did not set this.deferred = new Deferred\n         * in your child class) then I will make one and resolve it immediately. This makes the operation synchronise,\n         * but will allow us to always use the startup().then(... syntax.\n         *\n         * @param options simply copied to local this.options\n         * @return {altair.Promise}\n         */\n        startup: function (options) {\n\n            if(options) {\n                this.options = _.clone(options);\n            }\n\n            if(!this.deferred) {\n                this.deferred = new this.Deferred();\n                this.deferred.resolve(this);\n            }\n\n            //remove the deferred after it's been resolved\n            if(!this.deferred.always) {\n\n                this.deferred.reject(new Error('Invalid deferred type, use altair/Deferred.'));\n\n            } else {\n\n                this.deferred.always(this._deferredAutoRemover(this.deferred));\n            }\n\n            //tracking\n            this._startupDeferred = this.deferred;\n\n            return this.deferred.promise || this.deferred;\n\n        },\n\n        /**\n         * Mixin your async dependencies, for use during sartingy\n         *\n         * @param dependencies\n         * @returns {*}\n         */\n        mixinDependencies: function (dependencies) {\n\n            this.deferred = this.all(dependencies).then(function (deps) {\n\n                declare.safeMixin(this, deps);\n\n                return this;\n\n            }.bind(this));\n\n            return this.deferred;\n\n        },\n\n        /**\n         * Do your work in here.\n         *\n         * @returns {altair.Promise}\n         */\n        execute: function () {\n\n            //make sure startup deferred is still not active (can happen when someone goes life.startup().then(life.execute())\n            //and deferreds are auto-resolved (which makes the whole process sync)\n            if(this.deferred && this.deferred === this._startupDeferred) {\n                this.deferred = null;\n            }\n\n            if(!this.deferred) {\n                this.deferred = new this.Deferred();\n                this.deferred.resolve(this);\n            }\n\n            //do not need the startup deferred again\n            this._startupDeferred = null;\n\n            //remove the deferred after it's been resolved\n            this.deferred.always(this._deferredAutoRemover(this.deferred));\n\n            return this.deferred.promise || this.deferred;\n\n        },\n\n        /**\n         * Clean up so it's like you never existed.\n         *\n         * @returns {altair.Promise}\n         */\n        teardown: function () {\n\n            if(!this.deferred) {\n                this.deferred = new this.Deferred();\n                this.deferred.resolve(this);\n            }\n\n            //remove the deferred after it's been resolved\n            this.deferred.always(this._deferredAutoRemover(this.deferred));\n\n            return this.deferred.promise || this.deferred;\n\n        },\n\n        _deferredAutoRemover: function(def) {\n\n            var scope = this;\n            return function () {\n\n                setTimeout(function () {\n\n                    if(scope.deferred === def && scope.deferred.isResolved()) {\n                        scope.deferred = null;\n                    }\n\n                }, 0);\n            };\n        }\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/altair/StateMachine.js":"/**\n * Simple State Machine.\n */\ndefine(['altair/facades/declare',\n        'altair/facades/hitch',\n        'altair/events/Emitter',\n        'altair/events/Event',\n        'altair/Deferred',\n        'altair/facades/__',\n        'altair/facades/sprintf',\n        'lodash',\n        'altair/plugins/node!debug'\n        ],\n    function (declare,\n              hitch,\n              Emitter,\n              Event,\n              Deferred,\n              __,\n              sprintf,\n              _,\n              debug) {\n\n    debug = debug('altair/StateMachine');\n\n\n    \"use strict\";\n\n    return declare([Emitter], {\n\n        state:  null, //the my current state\n        states: null, //all our possible states\n        repeat: false, //run forever?\n\n        //statics\n        _listenerMap: {\n            'will-enter-state': 'onStateMachineWillEnter%s',\n            'did-enter-state':  'onStateMachineDidEnter%s',\n            'did-exit-state':   'onStateMachineDidExit%s'\n        },\n\n        constructor: function (options) {\n\n            this.state  = options && _.has(options, 'state') ? options.state : this.state; //starting state is optional\n            this.states = options.states;\n\n            if(options && _.has(options, 'delegate')) {\n                this.attachListeners(options.delegate);\n            }\n\n        },\n\n        /**\n         * Attach all our possible listeners to delegate depending on whether or not they exist\n         *\n         * @param delegate\n         */\n        attachListeners: function (delegate) {\n\n            var listeners = [];\n\n            //loop through each possible state\n            this.states.forEach(hitch(this, function (state) {\n\n                //then our listener map\n                Object.keys(this._listenerMap).forEach(hitch(this, function (eventName) {\n\n                    //construct the callbacks name\n                    var methodName = this._stateAndEventNameToCallbackName(state, eventName);\n\n                    //does the delegate have the name? if so, lets add a listener for it\n                    if(delegate[methodName] !== undefined) {\n                        listeners.push(this.on(eventName, hitch(delegate, methodName), { state: state }));\n                    }\n\n                }));\n\n            }));\n\n            return listeners;\n        },\n\n        /**\n         * Start me over!\n         *\n         * @returns {altair.events.Emitter}\n         */\n        reset: function () {\n            this.state = this.states[0];\n            return this;\n        },\n\n        /**\n         * Utility to make it a tad easier to set listeners\n         *\n         * @param state\n         * @param eventName\n         * @returns {*}\n         * @private\n         */\n        _stateAndEventNameToCallbackName: function (state, eventName) {\n            return sprintf(this._listenerMap[eventName], _.capitalize(state.replace(/-([a-z])/g, function (m, w) {\n                return w.toUpperCase();\n            })));\n        },\n\n        /**\n         * Loops through every state, emitting all events along the way. If an event listener returns a deferred, we\n         * wait until it is resolved before continuing. When we resolve our deferred, we will pass the return value\n         * of the last state we transitionedTo\n         *\n         * @param options  - repeat: loop back on itself?\n         * @returns {altair.Deferred}\n         */\n        execute: function (options) {\n\n            //lastResponse is is in form [state, data]... if no state, we're done\n            var d               = new Deferred(),\n                state           = options && _.has(options, 'state') ? options.state : this.states[0], //optionally override starting state\n                lastResponse    = [state, {}],\n                fire            = hitch(this, function () {\n\n                    if(!lastResponse[0]) {\n                        d.resolve(lastResponse[1]);\n                        return;\n                    }\n\n                    this.transitionTo(lastResponse[0], lastResponse[1], options).then(function (response) {\n                        lastResponse = response;\n                        fire();\n                    }).otherwise(hitch(this, function (err) {\n\n                        debug('state machine error in state: ' + state);\n                        debug(err);\n\n                        d.reject({\n                            error: err,\n                            state: state\n                        });\n                    }));\n\n                });\n\n            //repeat option passthrough\n            if(_.has(options,'repeat')) {\n                this.repeat = options.repeat;\n            }\n\n            fire();\n\n            return d;\n        },\n\n        /**\n         * Pass me a state and I'll let you know which state is next... if you on the last state, i'll pass back the first\n         *\n         * @param state\n         * @param backToFirst\n         *\n         * @returns {*}\n         */\n        nextState: function (state, backToFirst) {\n\n            var i = _.indexOf(this.states, state) + 1,\n                next = '';\n\n            if(i < this.states.length) {\n                next = this.states[i];\n            } else if(backToFirst === true){\n                next = this.states[0];\n            }\n\n            return next;\n        },\n\n        /**\n         * Same as above, but opposite order\n         *\n         * @param state\n         * @param backToLast\n         * @returns {string}\n         */\n        previousState: function (state, backToLast) {\n\n            var i = _.indexOf(this.states, state) - 1,\n                next = '';\n\n            if(i >= 0) {\n                next = this.states[i];\n            } else if(backToLast === true){\n                next = this.states[this.states.length-1];\n            }\n\n            return next;\n        },\n\n\n        /**\n         * Transition to a particular state (which involves emitting all events that are the lifecycle of the state.\n         *\n         * @param state the state (must match something in this.states)\n         * @param data object passed through to event (usually whatever was returned from previous state)\n         */\n        transitionTo: function (state, data, options) {\n\n            this.state = state;//probably should wait until didEnterState before setting this, yeah?\n\n            var dfd         = new Deferred(),\n                eventData   = data,\n                events      = Object.keys(this._listenerMap),\n                lastResponse,\n                nextState   = this.nextState(state, (options && _.has(options, 'repeat')) ? options.repeat : this.repeat),\n                fire        = hitch(this, function (i) {\n\n                    //are we on the last event?\n                    if(i === events.length) {\n                        dfd.resolve([nextState, lastResponse]);\n                        return;\n                    }\n\n                    //make sure our event data is an object\n                    if(!_.isObject(eventData)) {\n                        eventData = {};\n                    }\n\n                    //make sure we at least have the state\n                    eventData.state = state;\n\n                    //emit this event\n                    this.emit(events[i], eventData).then(hitch(this, function (e) {\n\n                        //someone stopped the state machine\n                        if(!e.active) {\n                            this.repeat = false;\n                            dfd.resolve([false, 'SIGABRT']);\n                            return false;\n                        }\n\n                        var results = e.resultsRaw();\n\n                        //get the results from the last event listener if any listeners are set\n                        if(results.length > 0) {\n\n                            lastResponse = results.pop();\n\n                            //if lastResponse is in the form of [ nextState, { event: data } ]\n                            //if so, halt the state machine and jump to that step immediately\n                            if(_.isArray(lastResponse)) {\n\n                                var _state = lastResponse[0];\n\n                                if(_.indexOf(this.states, _state) === -1) {\n                                    dfd.reject(new Error(__('State \"%s\" does not exist on this state machine.', _state)));\n                                }\n\n                                nextState       = _state;\n                                eventData       = lastResponse[1];\n                                lastResponse    = lastResponse[1];\n\n                                dfd.resolve([nextState, lastResponse]);\n                                return;\n\n                            } else if(_.isObject(lastResponse)) {\n                                eventData = lastResponse;\n                            }\n\n                        }\n\n                        fire(++i);\n\n                    })).otherwise(function (err) {\n                        dfd.reject(err);\n                    });\n\n                });\n\n            fire(0);\n\n            return dfd;\n\n        }\n\n\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/altair/TestRunner.js":"/**\n * Our simple test running. Works with doh/runner.\n */\ndefine(['altair/facades/declare',\n        'altair/Lifecycle',\n        'altair/facades/hitch',\n        'altair/facades/all',\n        'altair/plugins/node!fs',\n        'altair/plugins/node!debug',\n        'altair/plugins/node!path',\n        'doh/runner',\n        'altair/facades/glob',\n        'require'],\n    function (declare,\n              Lifecycle,\n              hitch,\n              all,\n              fs,\n              debug,\n              path,\n              doh,\n              glob,\n              require) {\n\n\n        return declare('altair/TestRunner', [Lifecycle], {\n\n            /**\n             * @param options\n             * options.paths - an array of paths whose contents are assumed to be tests\n             *\n             * @returns {*}\n             */\n            startup: function (options) {\n\n                var list         = [],\n                    _options = this.options || options;\n\n                // No tests to run throw error\n                if(!_options || !_options.glob) {\n                    this.deferred.reject(\"You must pass glob option test runner to parse to look for tests.\");\n                    return;\n                }\n\n                doh.debug = console.log;\n                doh.error = function (err) {\n                    if(err.stack) {\n                        console.error(err.stack || err);\n                    } else {\n                        console.log(err);\n                    }\n                };\n\n\n                doh._handleFailure = function (groupName, fixture, e) {\n\n                    // this.debug(\"FAILED test:\", fixture.name);\n                    // mostly borrowed from JUM\n                    this._groups[groupName].failures++;\n                    if(e instanceof this._AssertFailure){\n                        this._failureCount++;\n                        this.error(e.toString());\n                    }else{\n                        this._errorCount++;\n                        this.error(e); // printing Error on IE9 (and other browsers?) yields \"[Object Error]\"\n                    }\n                    if(fixture.runTest[\"toSource\"]){\n                        var ss = fixture.runTest.toSource();\n                        this.debug(\"\\tERROR IN:\\n\\t\\t\", ss);\n                    }else{\n                        this.debug(\"\\tERROR IN:\\n\\t\\t\", fixture.runTest);\n                    }\n                    if(e.rhinoException){\n                        e.rhinoException.printStackTrace();\n                    }else if(e.javaException){\n                        e.javaException.printStackTrace();\n                    }\n                };\n\n                this.deferred = glob(_options.glob.map(function (p) {\n                    if (p[0] === '.') {\n                        return path.join(process.cwd(), p);\n                    } else {\n                        return require.toUrl(p);\n                    }\n                }), _options.globOptions).then(hitch(this, function (files) {\n\n                    list.concat(files.map(hitch(this, 'includeTest')));\n                    return all(list);\n\n                })).then(hitch(this, function () {\n                    return this;\n                }));\n\n\n                return this.inherited(arguments);\n            },\n\n            execute: function () {\n                this.deferred = new this.Deferred();\n\n                doh._onEnd = hitch(this, function () {\n                    if(doh._errorCount > 0) {\n                        this.deferred.reject(doh._errorCount + ' tests failed.');\n\n                    } else {\n                        this.deferred.resolve();\n\n                    }\n\n                });\n\n                doh.run();\n\n                return this.inherited(arguments);\n            },\n\n\n            includeTest: function (path) {\n                var deferred = new this.Deferred();\n\n                require([path], function (t) {\n                    if(!t) {\n                        deferred.reject('including ' + path + ' failed');\n\n                    } else {\n                        deferred.resolve(t);\n\n                    }\n                });\n\n                return deferred;\n            }\n\n        });\n\n    });\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/apollo/Apollo.js":"/**\n * Apollo is a unique ORM. It does not couple itself to any particular type of class, such as a data model or an entity.\n * Schemas in Apollo are strict... very strict. This is to ensure that any schema has everything it needs to be rendered\n * via a UI. Field options like \"label\" come in handy, even via cli and the \"description\"\n * attribute is a great place for user friendly documentation (that engineers will appreciate too).\n */\ndefine(['dojo/_base/declare',\n        'dojo/Deferred',\n        'dojo/_base/lang',\n        './Schema'\n], function (declare,\n             Deferred,\n             lang,\n             Schema) {\n\n\n    return declare('apollo/Apollo', null, {\n\n        propertyTypes: null,\n\n        constructor: function (propertyTypes) {\n            this.propertyTypes = {};\n\n            if(propertyTypes) {\n                this.addTypes(propertyTypes);\n            }\n\n        },\n\n        /**\n         * Add a new type of property\n         * @param fieldType {apollo.propertyTypes._Base}\n         * @returns {apollo.Apollo}\n         */\n        addType: function (propertyType) {\n            this.propertyTypes[propertyType.key] = propertyType;\n            return this;\n        },\n\n        /**\n         * Add many property types at once.\n         *\n         * @param types\n         */\n        addTypes: function (types) {\n            types.forEach(lang.hitch(this, function (type) {\n                this.addType(type);\n            }));\n        },\n\n        /**\n         * Get you a property type by key\n         *\n         * @param type\n         * @returns {*}\n         */\n        type: function (key) {\n            return this.propertyTypes[key];\n        },\n\n        /**\n         * Creates a schema based on the data you provide, but uses the field types that have been added to Apollo\n         *\n         * @param data\n         * @returns {altair.io.core.lib.apollo.Schema}\n         */\n        createSchema: function (data) {\n\n            var s = new Schema(data, this.propertyTypes);\n\n            return s;\n\n        }\n\n\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/apollo/Collection.js":"/**\n * A collection is a wrapper for an array of _HasSchemaMixin objects to allow for chaining calls.\n *\n *\n *\n */\ndefine(['dojo/_base/declare',\n        'dojo/Deferred',\n        'dojo/_base/lang'\n], function (declare, Deferred, lang) {\n\n    return declare(null, {\n\n\n\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/apollo/_HasSchemaMixin.js":"/**\n * Apollo _HasSchemaMixin -> give any object you want a schema, it's powerful and stuff =)\n */\ndefine(['dojo/_base/declare',\n    'lodash',\n    'dojo/Deferred',\n    'dojo/promise/all',\n    './Schema'\n], function (declare,\n             _,\n             Deferred,\n             all,\n             Schema) {\n\n    function capitalise(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n\n\n    var _HasSchemaMixin = declare(null, {\n\n        _schema: null,\n        values: null,\n\n        /**\n         * Pass a schema if ya'nt\n         *\n         * @param schema\n         */\n        constructor: function (schema) {\n\n            if (schema && schema.isInstanceOf && schema.isInstanceOf(Schema)) {\n                this.setSchema(schema);\n            }\n\n        },\n\n\n        toGetter: function(named) {\n            return 'get' + capitalise(named);\n        },\n\n        toSetter: function(named) {\n            return 'set' + capitalise(named);\n        },\n\n        /**\n         * Will try and call an method to override this getter (getFieldName).\n         *\n         * @param name\n         * @param defaultValue\n         * @param options\n         * @param config\n         * @returns {*}\n         */\n        get: function (name, defaultValue, options, config) {\n\n            var methodName = this.toGetter(name);\n\n            if (typeof this[methodName] === 'function') {\n                return this[methodName](defaultValue, options, config);\n            }\n\n            return this._get(name, defaultValue, options, config);\n\n        },\n\n        /**\n         * Will try and call an overridden setter first, then\n         *\n         * @param name\n         * @param value\n         * @returns {apollo|_HasSchemaMixin}\n         */\n        set: function (name, value) {\n\n            var methodName = this.toSetter(name),\n                results;\n\n            if (typeof this[methodName] === 'function') {\n\n                results = this[methodName](value);\n\n            } else {\n\n                results = this._set(name, value);\n            }\n\n            return results;\n        },\n\n        /**\n         * Mixes in only matching values, leaving the rest\n         *\n         * @param values\n         * @returns {_HasSchemaMixin}\n         */\n        mixin: function (values, optionsByField, config) {\n\n            var cleaned = {};\n\n            _.each(values, function (value, name) {\n                if (this.has(name)) {\n\n                    if (config && config.methods) {\n\n                        var options = optionsByField && optionsByField[name] || {};\n\n                        //pass through old value\n                        config.old = this.values[name];\n\n                        //apply methods on value\n                        cleaned[name] = this.schema().applyOnProperty(config.methods, name, value, options, config);\n\n                    } else {\n                        cleaned[name] = value;\n                    }\n                }\n            }, this);\n\n            if (config && config.methods) {\n\n                return all(cleaned).then(function (values) {\n\n                    _.each(values, function (value, name) {\n                        this.set(name, value);\n                    }, this);\n\n                    return this;\n\n                }.bind(this));\n\n            } else {\n\n                _.each(cleaned, function (value, name) {\n                    this.set(name, value);\n                }, this);\n\n                return this;\n\n            }\n\n        },\n\n        has: function (name) {\n            return this.schema().has(name);\n        },\n\n        /**\n         * Default setter, just sets values array\n         *\n         * @param name\n         * @param value\n         * @returns {apollo|_HasSchemaMixin}\n         * @private\n         */\n        _set: function (name, value) {\n\n            if (this.schema().has(name)) {\n                this.values[name] = value;\n\n            } else {\n                throw new Error(\"No property called '\" + name + \"' exists on this \" + this);\n\n            }\n\n            return this;\n        },\n\n        /**\n         * Last resort getter. If you override a getter and still want access to the original value in the schema\n         *\n         * @param name\n         * @param defaultValue\n         * @param options\n         * @param config\n         * @returns {*}\n         * @private\n         */\n        _get: function (name, defaultValue, options, config) {\n\n            if (!_.has(this.values, name)) {\n                throw new Error('No property ' + name + ' found on ' + this);\n            }\n\n            var value = this.schema().applyOnProperty((config && config.methods) ? config.methods : ['toJsValue'], name, this.values[name], options, config);\n\n            if (value === null || value === undefined && !_.isUndefined(defaultValue)) {\n                value = defaultValue;\n\n            }\n\n            return value;\n        },\n\n        /**\n         * Set the schema to this object, then set default values to ourselves.\n         *\n         * @param schema\n         * @returns {apollo|_HasSchemaMixin}\n         */\n        setSchema: function (schema) {\n\n            this._schema = schema;\n\n            if (!this.values) {\n                this.values = {};\n            }\n\n            var properties = schema.properties();\n\n            _.each(properties, function (value, name) {\n\n                //only set values on ourselves that do not already exist\n                //this is to ensure that values has a key for every property in the schema\n                if (!( this.values.hasOwnProperty(name) )) {\n                    var defaultValue = schema.optionsFor(name, false).default;\n                    this.set(name, defaultValue);\n                }\n\n            }, this);\n\n            return this;\n\n        },\n\n        /**\n         * Returns you the schema attached to this object\n         *\n         * @returns {apollo.Schema}\n         */\n        schema: function () {\n            return this._schema;\n        },\n\n        /**\n         *\n         * @returns {*}\n         */\n        getValues: function (optionsByProperty, config) {\n\n            var values = {},\n                _obp = optionsByProperty || {},\n                _all = _obp['*'] || {},\n                _config = config || {};\n\n            _.each(this.schema().properties(), function (propConfig, name) {\n\n                if (_obp) {\n                    _obp[name] = _.defaults(_obp[name] || {}, _all);\n                }\n\n                var options = _.defaults(_obp[name] || {}, propConfig.options);\n\n                values[name] = this.get(name, null, options, _config);\n\n\n            }, this);\n\n\n            return values;\n\n        },\n\n        primaryProperty: function () {\n            return this.schema().primaryProperty();\n        },\n\n        primaryValue: function () {\n            var prop = this.primaryProperty();\n            return prop ? this.get(prop.name) : undefined;\n        },\n\n        /**\n         * @TODO finish\n         *\n         * @returns {dojo.Deferred}\n         */\n        validate: function (options) {\n\n            var schema = this.schema();\n\n            if (!schema) {\n                throw new Error('You can only validate objects that have a schema.');\n            }\n\n            return schema.validate(this.values, options).then(function () {\n                return this;\n            }.bind(this));\n\n        }\n\n    });\n\n    return _HasSchemaMixin;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/apollo/Schema.js":"/**\n * Apollo schemas are meant to be VERY lightweight.\n *\n * In altair\n *\n * var schema = this.nexus('cartridges/Apollo').createSchema({\n *  'properties' => {\n *      'fieldName' => {\n *          'type' => 'string',\n *          'options' => [\n *              'label'         => 'My cool field',\n *              'description'   => 'What the eff dude?',\n *              'required'      => true\n *          ]\n *      }\n * });\n *\n */\ndefine(['dojo/_base/declare',\n        'dojo/_base/lang',\n        'dojo/Deferred',\n        'dojo/promise/all',\n        'lodash'\n\n], function (declare, lang, Deferred, all, _) {\n\n    \"use strict\";\n\n    return declare(null, {\n\n        _data:           null,\n        _propertyTypes:   null,\n        _optionsByField: null,\n        _typeCache:      null,\n\n        /**\n         * Pass through straight config... assume its setup how we like it.\n         *\n         * @param schema\n         */\n        constructor: function (schema, propertyTypes) {\n\n            if (!schema || !propertyTypes) {\n                throw \"You must pass a schema literal and an array of apollo/fieldtypes/_Base instances\";\n            }\n\n            this._propertyTypes      = {};\n            this._data              = schema;\n            this._optionsByField    = {};\n            this._typeCache         = {};\n\n            if(!this._data.properties) {\n                this._data.properties = {};\n            }\n\n            //make sure each property has a name in it as well\n            _.each(this._data.properties, function (prop, name) {\n                prop.name = name;\n            });\n\n            if (propertyTypes instanceof Array) {\n\n                propertyTypes.forEach(lang.hitch(this, function (type) {\n                    this._propertyTypes[type.key] = type;\n                }));\n\n            } else {\n                this._propertyTypes = propertyTypes;\n            }\n\n\n        },\n\n        /**\n         * Does a schema have a field by this name?\n         *\n         * @param propertyName\n         * @returns {boolean}\n         */\n        has: function (propertyName) {\n            return (this._data.properties.hasOwnProperty(propertyName));\n        },\n\n        /**\n         * Tells you the type of a particular property (firstName would return string)\n         *\n         * @param propertyName\n         * @returns {string}\n         */\n        typeFor: function (propertyName) {\n            return this._data.properties[propertyName].type;\n        },\n\n        /**\n         * Set a single option for a property\n         *\n         * @param propertyName\n         * @param optionName\n         * @param optionValue\n         * @returns {this}\n         */\n        setOptionFor: function (propertyName, optionName, optionValue) {\n            if(!this.has(propertyName)) {\n                throw new Error('No property named ' + propertyName + ' exists on schema ');\n            }\n            this._data.properties[propertyName].options[optionName] = optionValue;\n            return this;\n        },\n\n        /**\n         * A property by a particular name\n         *\n         * @param named\n         * @returns {{}}\n         */\n        property: function (named) {\n            return this._data.properties[named];\n        },\n\n        /**\n         * I single option for a property\n         *\n         * @param propertyName\n         * @param optionName\n         * @returns {*}\n         */\n        optionFor: function (propertyName, optionName) {\n\n            if(!_.has(this._data.properties, propertyName)) {\n                throw new Error('no property called ' + propertyName + ' found on schema.');\n            }\n\n            return this._data.properties[propertyName].options[optionName];\n        },\n        /**\n         * Get you all the options for this field mixed in with all options for the field type.\n         *\n         * @param propertyName\n         * @param mixinAll optional\n         * @returns {string} all options for that field type\n         */\n        optionsFor: function (propertyName, mixinAll) {\n\n            if (propertyName in this._data.properties) {\n\n                var property = this._data.properties[propertyName],\n                    options = property.options;\n\n                if (!options) {\n                    throw new Error(propertyName + \" has no options. add it to your schema\");\n                }\n\n                //if we are doing a simple (lightweight) get of options\n                if (mixinAll === false) {\n                    return options;\n                }\n\n                if (!this._optionsByField[propertyName]) {\n\n                    var type = this.propertyType(property.type);\n                    this._optionsByField[propertyName] = type.normalizeOptions(options);\n\n                }\n\n\n            } else {\n\n                throw new Error(propertyName + ' does not exist on ' + this.declaredClass);\n            }\n\n            return this._optionsByField[propertyName];\n\n        },\n\n        option: function (named) {\n            return this._data[named];\n        },\n\n        get: function (named) {\n            return this._data[named];\n        },\n\n        data: function () {\n            return this._data;\n        },\n\n        primaryProperty: function () {\n            return _.where(this._data.properties, { type: 'primary' }).pop();\n        },\n\n        /**\n         * All the properties on this schema\n         *\n         * @returns {};\n         */\n        properties: function () {\n            return this.option('properties');\n        },\n\n        /**\n         * Gets all properties in this schema, but returns an array\n         *\n         * @returns {Array}\n         */\n        propertiesAsArray: function () {\n\n            var properties = [];\n\n            Object.keys(this._data.properties).forEach(lang.hitch(this, function (name) {\n\n                var property = lang.mixin({}, this._data.properties[name], {\n                    name: name\n                });\n\n                properties.push(property);\n\n            }));\n\n            return properties;\n\n        },\n\n        /**\n         * Returns you a propertytype by a particular key, e.g. string, email, bool\n         *\n         * @param key\n         * @returns {*}\n         */\n        propertyType: function (key) {\n\n            if (!(key in this._propertyTypes)) {\n                throw new Error('No property type of ' + key + ' found in schema.');\n            }\n\n            return this._propertyTypes[key];\n\n        },\n\n        /**\n         * All property types\n         *\n         * @returns {*}\n         */\n        propertyTypes: function () {\n            return this._propertyTypes;\n        },\n\n        /**\n         * Apply a transformation strategy on many values at once (the keys of values must match a property in the schema)\n         *\n         * @param values\n         * @param optionsByProperty\n         * @param config\n         * @returns {*}\n         */\n        applyOnValues: function (values, optionsByProperty, config) {\n\n            var _obp     = optionsByProperty || {},\n                _config  = config || {};\n\n            _.each(values, function (value, name) {\n                values[name] = this.applyOnProperty(_config.methods || ['toJsValue'], name, value, _obp[name], _config);\n            }, this);\n\n\n            return values;\n\n        },\n\n        /**\n         * Tries all the methods passed on the property propertyType, first one wins.\n         *\n         * Example:\n         *\n         *  schema.applyOnProperty(['toSolrValue', 'toStringValue'], 'firstName', 'Taylo®™', { maxLength: 35 });\n         *\n         * @param named\n         * @returns {*}\n         */\n        applyOnProperty: function (methodNames, propertyName, value, options, config) {\n\n            if (!this._data.properties[propertyName]) {\n                throw new Error('Property \"' + propertyName + '\" not found on ' + this + '.');\n            }\n\n            var property = this._data.properties[propertyName],\n                type = property.type,\n                _config = config || {},\n                propertyType = this.propertyType(type),\n                c,\n                methodName;\n\n            //by convention, these are null and will not be transformed\n            if ((value === null || value === undefined) && _config.ignoreNull !== false) {\n                return null;\n            }\n\n            //normalize options\n            options = lang.mixin({}, this.optionsFor(propertyName), options || {});\n\n            //normalize for many\n            value = propertyType.normalizeMany(value, options, config);\n\n            //invoke first method we find\n            for (c = 0; c < methodNames.length; c++) {\n\n                methodName = methodNames[c];\n\n                if (_.isFunction(propertyType[methodName])) {\n\n                    //make sure it's not an array when {{methodName}} is called\n                    if (propertyType.makeValuesSingular) {\n\n                        var wasArray = false;\n\n                        if (value instanceof Array) {\n\n                            wasArray = true;\n\n                        } else {\n\n                            value = [value];\n\n                        }\n\n                        var finalValue = [];\n\n                        value.forEach(function (_value) {\n                            if ((_value === null || _value === undefined) && _config.ignoreNull !== false) {\n                                //skip because null\n                            } else {\n                                finalValue.push(propertyType[methodName](_value, options, config));\n                            }\n                        });\n\n                        return wasArray && finalValue.length > 0 ? finalValue : finalValue.length > 0 ? finalValue[0] : null;\n\n                    }\n                    //we want the raw value passed to method name\n                    else {\n\n                        return propertyType[methodName](value, options, config);\n\n                    }\n                }\n            }\n\n            throw 'Could not find methods (' + methodNames.join(', ') + ') for property named \"' + propertyName + '\" of type \"' + type + '\".';\n\n        },\n\n        /**\n         * Add a new property to this schema.\n         *\n         * @param name\n         * @param type\n         * @param options\n         */\n        append: function (name, type, options) {\n            \n            this._data.properties[name] = {\n                type:       type,\n                name:       name,\n                options:    options\n            };\n\n            return this;\n        },\n\n        /**\n         * Helpful printing\n         * @returns {string}\n         */\n        toString: function () {\n            return '[object Schema]';\n        },\n\n        /**\n         * Validates all the values passed against our properties. Missing fields are also validaded with a value of null.\n         *\n         * schema().validate().then(... passs ...).otherwise(function (errs) {\n         *      console.log('you have', errs.length, 'errors'); //outputs 'you have 6 errors'\n         *      console.log('more details', errs.byProperty); //outputs `{ firstName: [...all errors...], email: [...all errors...] }\n         * });\n         *\n         * If no error occured, it will not be include in errs.byProperty.\n         *\n         * @param values the keys should match properties on this schema\n         * @param options { throwOnFirst: false, skipMissing: false } //should i return all errors, or just throw a new Error on first? - should i skip fields you did not pass?\n         * @returns {*|Promise}\n         */\n        validate: function (values, options) {\n\n            var everything  = {},\n                errors      = [],\n                errorsByProp = {},\n                _options    = options || {},\n                dfd         = new Deferred(),\n                skipMissing  = _.has(_options, 'skipMissing') ? _options.skipMissing : false,\n                _values     = values || {};\n\n            //call validate on all properties\n            _.each(this.properties(), function (prop, key) {\n\n                //mantain keys for all validate() calls\n                if(!skipMissing || _.has(values, key)) {\n                    everything[key] = this.applyOnProperty(['validate'], key, _values[key] || null, {}, { ignoreNull: false });\n                }\n\n            }, this);\n\n\n            //when all are done validating, check results for arrays (a result of true is pass, an array is fail)\n            all(everything).then(function (results) {\n\n                _.each(results, function (result, key) {\n\n                    //anything with many: true will be\n                    var many = this.optionFor(key, 'many'),\n                        manyResults = many ? result : [result];\n\n\n                    _.each(manyResults, function (result) {\n\n                        //if the result of validate() is not true, it's an array of errors\n                        if(result !== true) {\n\n                            if(!_.isArray(result)) {\n                                throw new Error('validate() for property type ' +  this.typeFor(key) + ' must return `true` or an array.');\n                            }\n\n                            if(_options.throwOnFirst) {\n                                throw new Error(result[0]);\n                            }\n\n                            errors = errors.concat(result);\n                            if (!errorsByProp[key]) {\n                                errorsByProp[key] = [];\n                            }\n                            errorsByProp[key] = errorsByProp[key].concat(result);\n                        }\n\n                    });\n\n                }, this);\n\n                if( errors.length > 0 ) {\n                    errors.byProperty = errorsByProp;\n                    dfd.reject(errors);\n                    return;\n                }\n\n                dfd.resolve(true);\n\n\n            }.bind(this)).otherwise(function (err) {\n                dfd.reject(err);\n            });\n\n            return dfd;\n\n        }\n\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/_browserRunner.js":"define([\n\t\"dojo/dom\", \"dojo/dom-geometry\", \"dojo/dom-style\",\n\t\"dojo/_base/fx\", \"dojo/_base/lang\", \"dojo/query\", \"dojo/domReady\", \"dojo/sniff\", \"dojo/window\",\n\t\"doh/runner\"\n], function(dom, domGeom, domStyle, baseFx, lang, query, domReady, has, win, doh){\n\tdoh.isBrowser= true;\n\tvar topdog;\n\ttry{\n\t\ttopdog = (window.parent == window) || !Boolean(window.parent.doh);\n\t}catch(e){\n\t\t//can't access window.parent.doh, then consider ourselves as topdog\n\t\ttopdog=true;\n\t}\n\tif(topdog){\n\t\t// we're the top-dog window.\n\n\t\t// borrowed from Dojo, etc.\n\t\tvar byId = function(id){\n\t\t\treturn document.getElementById(id);\n\t\t};\n\n\t\tvar _addOnEvt = function( type,\t\t// string\n\t\t\t\t\t\t\t\t\trefOrName,\t// function or string\n\t\t\t\t\t\t\t\t\tscope){\t\t// object, defaults is window\n\n\t\t\tif(!scope){ scope = window; }\n\n\t\t\tvar funcRef = refOrName;\n\t\t\tif(typeof refOrName == \"string\"){\n\t\t\t\tfuncRef = scope[refOrName];\n\t\t\t}\n\t\t\tvar enclosedFunc = function(){ return funcRef.apply(scope, arguments); };\n\n\t\t\tif(domReady && type == \"load\"){\n\t\t\t\tdomReady(enclosedFunc);\n\t\t\t}else{\n\t\t\t\tif(window[\"attachEvent\"]){\n\t\t\t\t\twindow.attachEvent(\"on\"+type, enclosedFunc);\n\t\t\t\t}else if(window[\"addEventListener\"]){\n\t\t\t\t\twindow.addEventListener(type, enclosedFunc, false);\n\t\t\t\t}else if(document[\"addEventListener\"]){\n\t\t\t\t\tdocument.addEventListener(type, enclosedFunc, false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t//\n\t\t// Over-ride or implement base runner.js-provided methods\n\t\t//\n\t\tvar escapeXml = function(str){\n\t\t\t// summary:\n\t\t\t//\t\tAdds escape sequences for special characters in XML: &<>\"'\n\t\t\t//\t\tOptionally skips escapes for single quotes\n\t\t\treturn str.replace(/&/gm, \"&amp;\").replace(/</gm, \"&lt;\").replace(/>/gm, \"&gt;\").replace(/\"/gm, \"&quot;\"); // string\n\t\t};\n\n\t\tvar formatTime = function(n){\n\t\t\tswitch(true){\n\t\t\t\tcase n<1000: //<1s\n\t\t\t\t\treturn n+\"ms\";\n\t\t\t\tcase n<60000: //<1m\n\t\t\t\t\treturn Math.round(n/100)/10+\"s\";\n\t\t\t\tcase n<3600000: //<1h\n\t\t\t\t\treturn Math.round(n/6000)/10+\"m\";\n\t\t\t\tdefault: //>1h\n\t\t\t\t\treturn Math.round(n/360000)/10+\"h\";\n\t\t\t}\n\t\t};\n\n\t\tvar _logBacklog = [], _loggedMsgLen = 0;\n\t\tvar sendToLogPane = function(args, skip){\n\t\t\tvar msg = \"\";\n\t\t\tfor(var x = 0; x < args.length; x++){\n\t\t\t\tmsg += \" \" + args[x];\n\t\t\t}\n\n\t\t\tmsg = escapeXml(msg);\n\n\t\t\t// workarounds for IE. Wheeee!!!\n\t\t\tmsg = msg.replace(\"\\t\", \"&nbsp;&nbsp;&nbsp;&nbsp;\")\n\t\t\t\t.replace(\" \", \"&nbsp;\")\n\t\t\t\t.replace(\"\\n\", \"<br>&nbsp;\");\n\t\t\tif(!byId(\"logBody\")){\n\t\t\t\t_logBacklog.push(msg);\n\t\t\t\treturn;\n\t\t\t}else if(_logBacklog.length && !skip){\n\t\t\t\tvar tm;\n\t\t\t\twhile((tm = _logBacklog.shift())){\n\t\t\t\t\tsendToLogPane(tm, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar logBody = byId(\"logBody\");\n\t\t\tvar tn = document.createElement(\"div\");\n\t\t\ttn.innerHTML = msg;\n\t\t\t//tn.id=\"logmsg_\"+logBody.childNodes.length;\n\t\t\tlogBody.appendChild(tn);\n\t\t\t_loggedMsgLen++;\n\t\t};\n\n\t\tvar findTarget = function(n){\n\t\t\twhile(n && !n.getAttribute('_target')){\n\t\t\t\tn = n.parentNode;\n\t\t\t\tif(!n.getAttribute){\n\t\t\t\t\tn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n;\n\t\t};\n\n\t\tdoh._jumpToLog = function(e){\n\t\t\t//console.log(e);\n\n\t\t\tvar node = findTarget(e?e.target:window.event.srcElement);\n\t\t\tif(!node){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar _t = Number(node.getAttribute('_target'));\n\t\t\tvar lb = byId(\"logBody\");\n\t\t\tif(_t>=lb.childNodes.length){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t = lb.childNodes[_t];\n\t\t\tt.scrollIntoView();\n\t\t\tif(domStyle && baseFx){\n\t\t\t\t//t.parentNode.parentNode is <div class=\"tabBody\">, only it has a explicitly set background-color,\n\t\t\t\t//all children of it are transparent\n\t\t\t\tvar bgColor = domStyle.get(t.parentNode.parentNode,'backgroundColor');\n\t\t\t\t//node.parentNode is the tr which has background-color set explicitly\n\t\t\t\tvar hicolor = domStyle.get(node.parentNode,'backgroundColor');\n\t\t\t\tvar unhilight = baseFx.animateProperty({\n\t\t\t\t\tnode: t,\n\t\t\t\t\tduration: 500,\n\t\t\t\t\tproperties:\n\t\t\t\t\t{\n\t\t\t\t\t\tbackgroundColor: { start: hicolor, end: bgColor }\n\t\t\t\t\t},\n\t\t\t\t\tonEnd: function(){\n\t\t\t\t\t\tt.style.backgroundColor=\"\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tvar hilight = baseFx.animateProperty({\n\t\t\t\t\tnode: t,\n\t\t\t\t\tduration: 500,\n\t\t\t\t\tproperties:\n\t\t\t\t\t{\n\t\t\t\t\t\tbackgroundColor: { start: bgColor, end: hicolor }\n\t\t\t\t\t},\n\t\t\t\t\tonEnd: function(){\n\t\t\t\t\t\tunhilight.play();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\thilight.play();\n\t\t\t}\n\t\t};\n\n\t\tdoh._jumpToSuite = function(e){\n\t\t\tvar node = findTarget(e ? e.target : window.event.srcElement);\n\t\t\tif(!node){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar _g = node.getAttribute('_target');\n\t\t\tvar gn = getGroupNode(_g);\n\t\t\tif(!gn){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgn.scrollIntoView();\n\t\t};\n\n\t\tdoh._init = (function(oi){\n\t\t\treturn function(){\n\t\t\t\tvar lb = byId(\"logBody\");\n\t\t\t\tif(lb){\n\t\t\t\t\t// clear the console before each run\n\t\t\t\t\twhile(lb.firstChild){\n\t\t\t\t\t\tlb.removeChild(lb.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\t_loggedMsgLen = 0;\n\t\t\t\t}\n\t\t\t\tthis._totalTime = 0;\n\t\t\t\tthis._suiteCount = 0;\n\t\t\t\toi.apply(doh, arguments);\n\t\t\t}\n\t\t})(doh._init);\n\n\t\tdoh._setupGroupForRun = (function(os){\n\t\t\t//overload _setupGroupForRun to record which log line to jump to when a suite is clicked\n\t\t\treturn function(groupName){\n\t\t\t\tvar tg = doh._groups[groupName];\n\t\t\t\tdoh._curTestCount = tg.length;\n\t\t\t\tdoh._curGroupCount = 1;\n\t\t\t\tvar gn = getGroupNode(groupName);\n\t\t\t\tif(gn){\n\t\t\t\t\t//two lines will be added, scroll the second line into view\n\t\t\t\t\tgn.getElementsByTagName(\"td\")[2].setAttribute('_target',_loggedMsgLen+1);\n\t\t\t\t}\n\t\t\t\tos.apply(doh,arguments);\n\t\t\t}\n\t\t})(doh._setupGroupForRun);\n\n\t\tvar originalDohReport= doh._report;\n\t\tdoh._report = function(){\n\t\t\tvar tb = byId(\"testList\");\n\t\t\tif(tb){\n\t\t\t\tvar tfoots=tb.getElementsByTagName('tfoot');\n\t\t\t\tif(tfoots.length){\n\t\t\t\t\ttb.removeChild(tfoots[0]);\n\t\t\t\t}\n\t\t\t\tvar foot = tb.createTFoot();\n\t\t\t\tvar row = foot.insertRow(-1);\n\t\t\t\trow.className = 'inProgress';\n\t\t\t\tvar cell=row.insertCell(-1);\n\t\t\t\tcell.colSpan=2;\n\t\t\t\tcell.innerHTML=\"Result\";\n\t\t\t\tcell = row.insertCell(-1);\n\t\t\t\tcell.innerHTML=this._testCount+\" tests in \"+this._groupCount+\" groups /<span class='failure'>\"+this._errorCount+\"</span> errors, <span class='failure'>\"+this._failureCount+\"</span> failures\";\n\t\t\t\tcell.setAttribute('_target',_loggedMsgLen+1);\n\t\t\t\trow.insertCell(-1).innerHTML=formatTime(doh._totalTime);\n\t\t\t}\n\n\t\t\t//This location can do the final performance rendering for the results\n\t\t\t//of any performance tests.\n\n\t\t\tif(doh.perfTestResults){\n\t\t\t\trequire([\"dojox/math/stats\", \"dojox/charting/DataChart\", \"dojox/charting/plot2d/Scatter\", \"dojox/charting/plot2d/Lines\", \"dojo/data/ItemFileReadStore\"],\n\t\t\t\t\t\tfunction(stats, DataChart, Scatter, Lines, ItemFileReadStore){\n\t\t\t\t\tlang.mixin(doh, stats);\n\n\t\t\t\t\tvar plotResults = function(div, name, dataArray) {\n\t\t\t\t\t\t// Performance report generating functions!\n\t\t\t\t\t\tvar median = doh.median(dataArray);\n\t\t\t\t\t\tvar medarray = [];\n\n\t\t\t\t\t\tvar i;\n\t\t\t\t\t\tfor(i = 0; i < dataArray.length; i++){\n\t\t\t\t\t\t\tmedarray.push(median);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tlabel: \"name\",\n\t\t\t\t\t\t\titems: [\n\t\t\t\t\t\t\t\t{name: name, trials: dataArray},\n\t\t\t\t\t\t\t\t{name: \"Median\", trials: medarray}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar ifs = new ItemFileReadStore({data: data});\n\n\t\t\t\t\t\tvar min = Math.floor(doh.min(dataArray));\n\t\t\t\t\t\tvar max = Math.ceil(doh.max(dataArray));\n\t\t\t\t\t\tvar step = (max - min)/10;\n\n\t\t\t\t\t\t//Lets try to pad out the bottom and top a bit\n\t\t\t\t\t\t//Then recalc the step.\n\t\t\t\t\t\tif(min > 0){\n\t\t\t\t\t\t\tmin = min - step;\n\t\t\t\t\t\t\tif(min < 0){\n\t\t\t\t\t\t\t\tmin = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmin = Math.floor(min);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(max > 0){\n\t\t\t\t\t\t\tmax = max + step;\n\t\t\t\t\t\t\tmax = Math.ceil(max);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstep = (max - min)/10;\n\n\t\t\t\t\t\tvar chart = new DataChart(div, {\n\t\t\t\t\t\t\ttype: Lines,\n\t\t\t\t\t\t\tdisplayRange: dataArray.length,\n\t\t\t\t\t\t\txaxis: {min: 1, max: dataArray.length, majorTickStep: Math.ceil((dataArray.length - 1)/10), htmlLabels: false},\n\t\t\t\t\t\t\tyaxis: {min: min, max: max, majorTickStep: step, vertical: true, htmlLabels: false}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tchart.setStore(ifs, {name:\"*\"}, \"trials\");\n\t\t\t\t\t};\n\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar g;\n\t\t\t\t\t\tvar pBody = byId(\"perfTestsBody\");\n\t\t\t\t\t\tvar chartsToRender = [];\n\t\t\t\t\t\t// store analytics for reading later\n\t\t\t\t\t\t// keyed on test group name, each value is in turn an object keyed on test name\n\t\t\t\t\t\tdoh.perfTestAnalytics={};\n\t\t\t\t\t\tdoh.showPerfTestsPage();\n\t\t\t\t\t\tfor(g in doh.perfTestResults){\n\t\t\t\t\t\t\tdoh.perfTestAnalytics[g] = {};\n\t\t\t\t\t\t\tvar grp = doh.perfTestResults[g];\n\t\t\t\t\t\t\tvar hdr = document.createElement(\"h1\");\n\t\t\t\t\t\t\thdr.appendChild(document.createTextNode(\"Group: \" + g));\n\t\t\t\t\t\t\tpBody.appendChild(hdr);\n\t\t\t\t\t\t\tvar ind = document.createElement(\"blockquote\");\n\t\t\t\t\t\t\tpBody.appendChild(ind);\n\t\t\t\t\t\t\tvar f;\n\t\t\t\t\t\t\tfor(f in grp){\n\t\t\t\t\t\t\t\tvar fResults = grp[f];\n\t\t\t\t\t\t\t\tif(!fResults){ continue; }\n\t\t\t\t\t\t\t\tvar fhdr = document.createElement(\"h3\");\n\t\t\t\t\t\t\t\tfhdr.appendChild(document.createTextNode(\"TEST: \" + f));\n\t\t\t\t\t\t\t\tfhdr.style.textDecoration = \"underline\";\n\t\t\t\t\t\t\t\tind.appendChild(fhdr);\n\t\t\t\t\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tind.appendChild(div);\n\n\t\t\t\t\t\t\t\t//Figure out the basic info\n\t\t\t\t\t\t\t\tvar results = \"<b>TRIAL SIZE: </b>\"\t + fResults.trials[0].testIterations + \" iterations<br>\" +\n\t\t\t\t\t\t\t\t\t\"<b>NUMBER OF TRIALS: </b>\" + fResults.trials.length + \"<br>\";\n\n\t\t\t\t\t\t\t\t//Figure out the average test pass cost.\n\t\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\t\tvar iAvgArray = [];\n\t\t\t\t\t\t\t\tvar tAvgArray = [];\n\t\t\t\t\t\t\t\tfor(i = 0; i < fResults.trials.length; i++){\n\t\t\t\t\t\t\t\t\tiAvgArray.push(fResults.trials[i].average);\n\t\t\t\t\t\t\t\t\ttAvgArray.push(fResults.trials[i].executionTime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar analytics = doh.perfTestAnalytics[g][f] = {\n\t\t\t\t\t\t\t\t\taverageTrialExecutionTime: doh.mean(tAvgArray),\n\t\t\t\t\t\t\t\t\tmaxTestIterationTime: doh.max(iAvgArray),\n\t\t\t\t\t\t\t\t\tminTestIterationTime: doh.min(iAvgArray),\n\t\t\t\t\t\t\t\t\taverageTestIterationTime: doh.mean(iAvgArray),\n\t\t\t\t\t\t\t\t\tmedianTestIterationTime: doh.median(iAvgArray),\n\t\t\t\t\t\t\t\t\tvarianceTestIterationTime: doh.variance(iAvgArray),\n\t\t\t\t\t\t\t\t\tstandardDeviationTestIterationTime: doh.sd(iAvgArray)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tresults += \"<b>AVERAGE TRIAL EXECUTION TIME: </b>\" + analytics.averageTrialExecutionTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>MAXIMUM TEST ITERATION TIME: </b>\" + analytics.maxTestIterationTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>MINIMUM TEST ITERATION TIME: </b>\" + analytics.minTestIterationTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>AVERAGE TEST ITERATION TIME: </b>\" + analytics.averageTestIterationTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>MEDIAN TEST ITERATION TIME: </b>\" + analytics.medianTestIterationTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>VARIANCE TEST ITERATION TIME: </b>\" + analytics.varianceTestIterationTime.toFixed(10) + \"ms.<br>\";\n\t\t\t\t\t\t\t\tresults += \"<b>STANDARD DEVIATION ON TEST ITERATION TIME: </b>\" +analytics.standardDeviationTestIterationTime.toFixed(10) + \"ms.<br>\";\n\n\t\t\t\t\t\t\t\t//Okay, attach it all in.\n\t\t\t\t\t\t\t\tdiv.innerHTML = results;\n\n\t\t\t\t\t\t\t\tdiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tdiv.innerHTML = \"<h3>Average Test Execution Time (in milliseconds, with median line)</h3>\";\n\t\t\t\t\t\t\t\tind.appendChild(div);\n\t\t\t\t\t\t\t\tdiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tdomStyle.set(div, \"width\", \"600px\");\n\t\t\t\t\t\t\t\tdomStyle.set(div, \"height\", \"250px\");\n\t\t\t\t\t\t\t\tind.appendChild(div);\n\t\t\t\t\t\t\t\tchartsToRender.push({\n\t\t\t\t\t\t\t\t\tdiv: div,\n\t\t\t\t\t\t\t\t\ttitle: \"Average Test Execution Time\",\n\t\t\t\t\t\t\t\t\tdata: iAvgArray\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tdiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tdiv.innerHTML = \"<h3>Average Trial Execution Time (in milliseconds, with median line)</h3>\";\n\t\t\t\t\t\t\t\tind.appendChild(div);\n\t\t\t\t\t\t\t\tdiv = document.createElement(\"div\");\n\t\t\t\t\t\t\t\tdomStyle.set(div, \"width\", \"600px\");\n\t\t\t\t\t\t\t\tdomStyle.set(div, \"height\", \"250px\");\n\t\t\t\t\t\t\t\tind.appendChild(div);\n\t\t\t\t\t\t\t\tchartsToRender.push({\n\t\t\t\t\t\t\t\t\tdiv: div,\n\t\t\t\t\t\t\t\t\ttitle: \"Average Trial Execution Time\",\n\t\t\t\t\t\t\t\t\tdata: tAvgArray\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Lazy-render these to give the browser time and not appear locked.\n\t\t\t\t\t\tvar delayedRenders = function() {\n\t\t\t\t\t\t\tif(chartsToRender.length){\n\t\t\t\t\t\t\t\tvar chartData = chartsToRender.shift();\n\t\t\t\t\t\t\t\tplotResults(chartData.div, chartData.title, chartData.data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetTimeout(delayedRenders, 50);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsetTimeout(delayedRenders, 150);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tdoh.debug(e);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\toriginalDohReport.apply(doh,arguments);\n\t\t};\n\n\n\t\tdoh.error = undefined;\n\t\tif(this[\"opera\"] && opera.postError){\n\t\t\tdoh.debug = function(){\n\t\t\t\tvar msg = \"\";\n\t\t\t\tfor(var x=0; x<arguments.length; x++){\n\t\t\t\t\tmsg += \" \"+arguments[x];\n\t\t\t\t}\n\t\t\t\tsendToLogPane([msg]);\n\t\t\t\topera.postError(\"DEBUG:\"+msg);\n\t\t\t}\n\t\t}else if(window[\"console\"]){\n\t\t\tif(console.error){\n\t\t\t\tdoh.error = function(){\n\t\t\t\t\tsendToLogPane.call(window, arguments);\n\t\t\t\t\tconsole.error(Array.prototype.join.call(arguments, \" \"))\n\t\t\t\t};\n\t\t\t}\n\t\t\tif(console.debug){\n\t\t\t\tdoh.debug = function(){\n\t\t\t\t\tsendToLogPane.call(window, arguments);\n\t\t\t\t\tconsole.debug(Array.prototype.join.call(arguments, \" \"))\n\t\t\t\t};\n\t\t\t}else if(console.info){\n\t\t\t\tdoh.debug = function(){\n\t\t\t\t\tsendToLogPane.call(window, arguments);\n\t\t\t\t\tconsole.info(Array.prototype.join.call(arguments, \" \"))\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\tdoh.debug = function(){\n\t\t\t\t\tsendToLogPane.call(window, arguments);\n\t\t\t\t\tconsole.log(\"DEBUG:\"+ Array.prototype.join.call(arguments, \" \"));\n\t\t\t\t};\n\t\t\t}\n\t\t}else{\n\t\t\tdoh.debug = function(){\n\t\t\t\tsendToLogPane.call(window, arguments);\n\t\t\t}\n\t\t}\n\t\tdoh.error = doh.error || doh.debug;\n\t\tvar loaded = false;\n\t\tvar groupTemplate = null;\n\t\tvar testTemplate = null;\n\n\t\tvar groupNodes = {};\n\n\t\tvar _groupTogglers = {};\n\n\t\tvar _getGroupToggler = function(group, toggle){\n\t\t\tif(_groupTogglers[group]){ return _groupTogglers[group]; }\n\t\t\tvar rolledUp = true;\n\t\t\treturn (_groupTogglers[group] = function(evt, forceOpen){\n\t\t\t\tvar nodes = groupNodes[group].__items;\n\t\t\t\tvar x;\n\t\t\t\tif(rolledUp||forceOpen){\n\t\t\t\t\trolledUp = false;\n\t\t\t\t\tfor(x=0; x<nodes.length; x++){\n\t\t\t\t\t\tnodes[x].style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t\ttoggle.innerHTML = \"&#9660;\";\n\t\t\t\t}else{\n\t\t\t\t\trolledUp = true;\n\t\t\t\t\tfor(x=0; x<nodes.length; x++){\n\t\t\t\t\t\tnodes[x].style.display = \"none\";\n\t\t\t\t\t}\n\t\t\t\t\ttoggle.innerHTML = \"&#9658;\";\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tvar addGroupToList = function(group){\n\t\t\tif(!byId(\"testList\")){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar tb = byId(\"testList\").tBodies[0];\n\t\t\tvar tg = groupTemplate.cloneNode(true);\n\t\t\tvar tds = tg.getElementsByTagName(\"td\");\n\t\t\tvar toggle = tds[0];\n\t\t\ttoggle.onclick = _getGroupToggler(group, toggle);\n\t\t\tvar cb = tds[1].getElementsByTagName(\"input\")[0];\n\t\t\tcb.group = group;\n\t\t\tcb.onclick = function(){\n\t\t\t\tdoh._groups[group].skip = (!this.checked);\n\t\t\t};\n\t\t\ttds[2].innerHTML = \"<div class='testGroupName'>\" + group + \"</div><div style='width:0;'>&nbsp;</div>\";\n\t\t\ttds[3].innerHTML = \"\";\n\n\t\t\ttb.appendChild(tg);\n\t\t\treturn tg;\n\t\t};\n\n\t\tvar addFixtureToList = function(group, fixture){\n\t\t\tif(!testTemplate){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar cgn = groupNodes[group];\n\t\t\tif(!cgn[\"__items\"]){\n\t\t\t\tcgn.__items = [];\n\t\t\t}\n\t\t\tvar tn = testTemplate.cloneNode(true);\n\t\t\tvar tds = tn.getElementsByTagName(\"td\");\n\n\t\t\ttds[2].innerHTML = fixture.name;\n\t\t\ttds[3].innerHTML = \"\";\n\n\t\t\tvar nn = (cgn.__lastFixture || cgn.__groupNode).nextSibling;\n\t\t\tif(nn){\n\t\t\t\tnn.parentNode.insertBefore(tn, nn);\n\t\t\t}else{\n\t\t\t\tcgn.__groupNode.parentNode.appendChild(tn);\n\t\t\t}\n\t\t\t// FIXME: need to make group display toggleable!!\n\t\t\ttn.style.display = \"none\";\n\t\t\tcgn.__items.push(tn);\n\t\t\treturn (cgn.__lastFixture = tn);\n\t\t};\n\n\t\tvar getFixtureNode = function(group, fixture){\n\t\t\tif(groupNodes[group]){\n\t\t\t\treturn groupNodes[group][fixture.name];\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tvar getGroupNode = function(group){\n\t\t\tif(groupNodes[group]){\n\t\t\t\treturn groupNodes[group].__groupNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tvar updateBacklog = [];\n\t\tdoh._updateTestList = function(group, fixture, unwindingBacklog){\n\t\t\tif(!loaded){\n\t\t\t\tif(group && fixture){\n\t\t\t\t\tupdateBacklog.push([group, fixture]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}else if(updateBacklog.length && !unwindingBacklog){\n\t\t\t\tvar tr;\n\t\t\t\twhile((tr = updateBacklog.shift())){\n\t\t\t\t\tdoh._updateTestList(tr[0], tr[1], true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(group && fixture){\n\t\t\t\tif(!groupNodes[group]){\n\t\t\t\t\tgroupNodes[group] = {\n\t\t\t\t\t\t\"__groupNode\": addGroupToList(group)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(!groupNodes[group][fixture.name]){\n\t\t\t\t\tgroupNodes[group][fixture.name] = addFixtureToList(group, fixture)\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tdoh._testRegistered = doh._updateTestList;\n\n\t\tdoh._groupStarted = function(group){\n\t\t\tif(this._suiteCount == 0){\n\t\t\t\tthis._runedSuite = 0;\n\t\t\t\tthis._currentGlobalProgressBarWidth = 0;\n\t\t\t\tthis._suiteCount = this._testCount;\n\t\t\t}\n\t\t\t// console.debug(\"_groupStarted\", group);\n\t\t\tif(doh._inGroup != group){\n\t\t\t\tdoh._groupTotalTime = 0;\n\t\t\t\tdoh._runed = 0;\n\t\t\t\tdoh._inGroup = group;\n\t\t\t\tthis._runedSuite++;\n\t\t\t}\n\t\t\tvar gn = getGroupNode(group);\n\t\t\tif(gn){\n\t\t\t\tgn.className = \"inProgress\";\n\t\t\t}\n\t\t};\n\n\t\tdoh._groupFinished = function(group, success){\n\t\t\t// console.debug(\"_groupFinished\", group);\n\t\t\tvar gn = getGroupNode(group);\n\t\t\tif(gn && doh._inGroup == group){\n\t\t\t\tdoh._totalTime += doh._groupTotalTime;\n\t\t\t\tgn.getElementsByTagName(\"td\")[3].innerHTML = formatTime(doh._groupTotalTime);\n\t\t\t\tgn.getElementsByTagName(\"td\")[2].lastChild.className = \"\";\n\t\t\t\tdoh._inGroup = null;\n\t\t\t\t//doh._runedSuite++;\n\t\t\t\tvar failure = doh._updateGlobalProgressBar(this._runedSuite / this._groupCount, success, group);\n\t\t\t\tgn.className = failure ? \"failure\" : \"success\";\n\t\t\t\t//doh._runedSuite--;\n\t\t\t\tdoh._currentGlobalProgressBarWidth = parseInt(this._runedSuite / this._groupCount * 10000) / 100;\n\t\t\t\t//byId(\"progressOuter\").style.width = parseInt(this._runedSuite/this._suiteCount*100)+\"%\";\n\t\t\t}\n\t\t\tif(doh._inGroup == group){\n\t\t\t\tthis.debug(\"Total time for GROUP \\\"\", group, \"\\\" is \", formatTime(doh._groupTotalTime));\n\t\t\t}\n\t\t};\n\n\t\tdoh._testStarted = function(group, fixture){\n\t\t\t// console.debug(\"_testStarted\", group, fixture.name);\n\t\t\tvar fn = getFixtureNode(group, fixture);\n\t\t\tif(fn){\n\t\t\t\tfn.className = \"inProgress\";\n\t\t\t}\n\t\t};\n\n\t\tvar _nameTimes = {};\n\t\tvar _playSound = function(name){\n\t\t\tif(byId(\"hiddenAudio\") && byId(\"audio\") && byId(\"audio\").checked){\n\t\t\t\t// console.debug(\"playing:\", name);\n\t\t\t\tvar nt = _nameTimes[name];\n\t\t\t\t// only play sounds once every second or so\n\t\t\t\tif((!nt) || (((new Date) - nt) > 700)){\n\t\t\t\t\t_nameTimes[name] = new Date();\n\t\t\t\t\tvar tc = document.createElement(\"span\");\n\t\t\t\t\tbyId(\"hiddenAudio\").appendChild(tc);\n\t\t\t\t\ttc.innerHTML = '<embed src=\"_sounds/' + name + '.wav\" autostart=\"true\" loop=\"false\" hidden=\"true\" width=\"1\" height=\"1\"></embed>';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tdoh._updateGlobalProgressBar = function(p, success, group){\n\t\t\tvar outerContainer = byId(\"progressOuter\");\n\n\t\t\tvar gdiv = outerContainer.childNodes[doh._runedSuite - 1];\n\t\t\tif(!gdiv){\n\t\t\t\tgdiv = document.createElement('div');\n\t\t\t\touterContainer.appendChild(gdiv);\n\t\t\t\tgdiv.className = 'success';\n\t\t\t\tgdiv.setAttribute('_target', group);\n\t\t\t}\n\t\t\tif(!success && !gdiv._failure){\n\t\t\t\tgdiv._failure = true;\n\t\t\t\tgdiv.className = 'failure';\n\t\t\t\tif(group){\n\t\t\t\t\tgdiv.setAttribute('title', 'failed group ' + group);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar tp = parseInt(p * 10000) / 100;\n\t\t\tgdiv.style.width = (tp - doh._currentGlobalProgressBarWidth) + \"%\";\n\t\t\treturn gdiv._failure;\n\t\t};\n\t\tdoh._testFinished = function(group, fixture, success){\n\t\t\tvar fn = getFixtureNode(group, fixture);\n\t\t\tvar elapsed = fixture.endTime-fixture.startTime;\n\t\t\tvar gn;\n\t\t\tif(fn){\n\t\t\t\tfn.getElementsByTagName(\"td\")[3].innerHTML = formatTime(elapsed);\n\t\t\t\tfn.className = (success) ? \"success\" : \"failure\";\n\t\t\t\tfn.getElementsByTagName(\"td\")[2].setAttribute('_target', _loggedMsgLen);\n\t\t\t\tif(!success){\n\t\t\t\t\t_playSound(\"doh\");\n\t\t\t\t\tgn = getGroupNode(group);\n\t\t\t\t\tif(gn){\n\t\t\t\t\t\tgn.className = \"failure\";\n\t\t\t\t\t\t_getGroupToggler(group)(null, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(doh._inGroup == group){\n\t\t\t\tgn = getGroupNode(group);\n\t\t\t\tdoh._runed++;\n\t\t\t\tif(gn && doh._curTestCount){\n\t\t\t\t\tvar p = doh._runed/doh._curTestCount;\n\t\t\t\t\tvar groupfail = this._updateGlobalProgressBar((doh._runedSuite+p-1)/doh._groupCount,success,group);\n\n\t\t\t\t\tvar pbar = gn.getElementsByTagName(\"td\")[2].lastChild;\n\t\t\t\t\tpbar.className = groupfail?\"failure\":\"success\";\n\t\t\t\t\tpbar.style.width = parseInt(p*100)+\"%\";\n\t\t\t\t\tgn.getElementsByTagName(\"td\")[3].innerHTML = parseInt(p*10000)/100+\"%\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._groupTotalTime += elapsed;\n\t\t\tthis.debug((success ? \"PASSED\" : \"FAILED\"), \"test:\", fixture.name, elapsed, 'ms');\n\t\t};\n\n\t\tdoh._registerUrl = function(group, url, timeout, type, dohArgs){\n\t\t\tgroup= group || url;\n\t\t\tthis._registerTest(group, {\n\t\t\t\tname: url,\n\t\t\t\tsetUp: function(){\n\t\t\t\t\tdoh.currentGroupName = group;\n\t\t\t\t\tdoh.currentGroup = this;\n\t\t\t\t\tdoh.currentUrl = url;\n\t\t\t\t\tdoh.dohArgs = dohArgs;\n\t\t\t\t\tthis.d = new doh.Deferred();\n\t\t\t\t\tdoh.currentTestDeferred = this.d;\n\t\t\t\t\tdoh.showTestPage();\n\t\t\t\t\tbyId(\"testBody\").src = url;\n\t\t\t\t},\n\t\t\t\ttimeout: timeout||10000, // 10s\n\t\t\t\t// timeout: timeout||1000, // 10s\n\t\t\t\trunTest: function(){\n\t\t\t\t\t// FIXME: implement calling into the url's groups here!!\n\t\t\t\t\treturn this.d;\n\t\t\t\t},\n\t\t\t\ttearDown: function(){\n\t\t\t\t\tdoh.currentGroupName = null;\n\t\t\t\t\tdoh.currentGroup = null;\n\t\t\t\t\tdoh.currentTestDeferred = null;\n\t\t\t\t\tdoh.currentUrl = null;\n\t\t\t\t\t// this.d.errback(false);\n\t\t\t\t\t// byId(\"testBody\").src = \"about:blank\";\n\t\t\t\t\tdoh.showLogPage();\n\t\t\t\t}\n\t\t\t}, type);\n\t\t};\n\n\t\t//\n\t\t// Utility code for runner.html\n\t\t//\n\t\t// var isSafari = navigator.appVersion.indexOf(\"Safari\") >= 0;\n\t\tvar tabzidx = 1;\n\t\tvar _showTab = function(toShow, toHide){\n\t\t\t// FIXME: I don't like hiding things this way.\n\t\t\tvar i;\n\t\t\tfor(i = 0; i < toHide.length; i++){\n\t\t\t\tvar node = byId(toHide[i]);\n\t\t\t\tif(node){\n\t\t\t\t\tnode.style.display = \"none\";\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoShow = byId(toShow);\n\t\t\tif(toShow){\n\t\t\t\ttoShow.style.display = \"\";\n\t\t\t\ttoShow.style.zIndex = ++tabzidx;\n\t\t\t}\n\t\t};\n\n\t\tdoh.showTestPage = function(){\n\t\t\t_showTab(\"testBody\", [\"logBody\", \"perfTestsBody\"]);\n\t\t};\n\n\t\tdoh.showLogPage = function(){\n\t\t\t_showTab(\"logBody\", [\"testBody\", \"perfTestsBody\"]);\n\t\t};\n\n\t\tdoh.showPerfTestsPage = function(){\n\t\t\t_showTab(\"perfTestsBody\", [\"testBody\", \"logBody\"]);\n\t\t};\n\n\t\tvar runAll = true;\n\t\tdoh.toggleRunAll = function(){\n\t\t\t// would be easier w/ query...sigh\n\t\t\trunAll = !runAll;\n\t\t\tif(!byId(\"testList\")){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar tb = byId(\"testList\").tBodies[0];\n\t\t\tvar inputs = tb.getElementsByTagName(\"input\");\n\t\t\tvar x = 0;\n\t\t\tvar tn;\n\t\t\twhile((tn = inputs[x++])){\n\t\t\t\ttn.checked = runAll;\n\t\t\t\tdoh._groups[tn.group].skip = (!runAll);\n\t\t\t}\n\t\t};\n\n\t\tvar listHeightTimer = null;\n\t\tvar setListHeight = function(){\n\t\t\tif(listHeightTimer){\n\t\t\t\tclearTimeout(listHeightTimer);\n\t\t\t}\n\t\t\tvar tl = byId(\"testList\");\n\t\t\tif(!tl){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistHeightTimer = setTimeout(function(){\n\t\t\t\ttl.style.display = \"none\";\n\t\t\t\ttl.style.display = \"\";\n\n\t\t\t}, 10);\n\t\t};\n\n\t\t_addOnEvt(\"resize\", setListHeight);\n\t\t_addOnEvt(\"load\", setListHeight);\n\t\t_addOnEvt(\"load\", function(){\n\t\t\tif(loaded){ return; }\n\t\t\tloaded = true;\n\t\t\tgroupTemplate = byId(\"groupTemplate\");\n\t\t\tif(!groupTemplate){\n\t\t\t\t// make sure we've got an amenable DOM structure\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgroupTemplate.parentNode.removeChild(groupTemplate);\n\t\t\tgroupTemplate.style.display = \"\";\n\t\t\ttestTemplate = byId(\"testTemplate\");\n\t\t\ttestTemplate.parentNode.removeChild(testTemplate);\n\t\t\ttestTemplate.style.display = \"\";\n\t\t\tdoh._updateTestList();\n\t\t});\n\n\t\t_addOnEvt(\"load\",\n\t\t\tfunction(){\n\t\t\t\t// let robot code run if it gets to this first\n\t\t\t\tvar __onEnd = doh._onEnd;\n\t\t\t\tdoh._onEnd = function(){\n\t\t\t\t\t__onEnd.apply(doh, arguments);\n\t\t\t\t\tif(doh._failureCount == 0){\n\t\t\t\t\t\tdoh.debug(\"WOOHOO!!\");\n\t\t\t\t\t\t_playSound(\"woohoo\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tconsole.debug(\"doh._failureCount:\", doh._failureCount);\n\t\t\t\t\t}\n\t\t\t\t\tif(byId(\"play\")){\n\t\t\t\t\t\ttoggleRunning();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif(!byId(\"play\")){\n\t\t\t\t\t// make sure we've got an amenable DOM structure\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar isRunning = false;\n\t\t\t\tvar toggleRunning = function(){\n\t\t\t\t\t// ugg, this would be so much better w/ dojo.query()\n\t\t\t\t\tif(isRunning){\n\t\t\t\t\t\tbyId(\"play\").style.display = byId(\"pausedMsg\").style.display = \"\";\n\t\t\t\t\t\tbyId(\"playingMsg\").style.display = byId(\"pause\").style.display = \"none\";\n\t\t\t\t\t\tisRunning = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbyId(\"play\").style.display = byId(\"pausedMsg\").style.display = \"none\";\n\t\t\t\t\t\tbyId(\"playingMsg\").style.display = byId(\"pause\").style.display = \"\";\n\t\t\t\t\t\tisRunning = true;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoh.run = (function(oldRun){\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tif(!doh._currentGroup){\n\t\t\t\t\t\t\ttoggleRunning();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn oldRun.apply(doh, arguments);\n\t\t\t\t\t}\n\t\t\t\t})(doh.run);\n\t\t\t\tvar btns = byId(\"toggleButtons\").getElementsByTagName(\"span\");\n\t\t\t\tvar node; var idx=0;\n\t\t\t\twhile((node=btns[idx++])){\n\t\t\t\t\tnode.onclick = toggleRunning;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}else{\n\t\t// we're in an iframe environment. Time to mix it up a bit.\n\n\t\tvar _doh = window.parent.doh;\n\t\tvar _thisGroup = _doh.currentGroupName;\n\t\tvar _thisUrl = _doh.currentUrl;\n\t\tif(_thisGroup){\n\t\t\tdoh._onEnd = function(){\n\t\t\t\t_doh._errorCount += doh._errorCount;\n\t\t\t\t_doh._failureCount += doh._failureCount;\n\t\t\t\t_doh._testCount += doh._testCount;\n\t\t\t\t// should we be really adding raw group counts?\n\t\t\t\t//_doh._groupCount += doh._groupCount;\n\t\t\t\t_doh.currentTestDeferred.callback(true);\n\t\t\t};\n\t\t\tdoh._testRegistered = function(group, fixture){\n\t\t\t\tfixture.name = _thisUrl+\"::\"+arguments[0]+\"::\"+fixture.name;\n\t\t\t\t_doh._updateTestList(_thisGroup, fixture);\n\t\t\t};\n\t\t\tdoh.debug = lang.hitch(_doh, \"debug\");\n\t\t\tdoh.error = lang.hitch(_doh, \"error\");\n\t\t\tdoh.registerUrl = lang.hitch(_doh, \"registerUrl\");\n\t\t\tdoh._testStarted = function(group, fixture){\n\t\t\t\t_doh._testStarted(_thisGroup, fixture);\n\t\t\t};\n\t\t\tdoh._testFinished = function(g, f, s){\n\t\t\t\t_doh._testFinished(_thisGroup, f, s);\n\n\t\t\t\t//Okay, there may be performance info we need to filter back\n\t\t\t\t//to the parent, so do that here.\n\t\t\t\tif(doh.perfTestResults){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar gName = g.toString();\n\t\t\t\t\t\tvar localFName = f.name;\n\t\t\t\t\t\twhile(localFName.indexOf(\"::\") >= 0){\n\t\t\t\t\t\t\tlocalFName = localFName.substring(localFName.indexOf(\"::\") + 2, localFName.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!_doh.perfTestResults){\n\t\t\t\t\t\t\t_doh.perfTestResults = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!_doh.perfTestResults[gName]){\n\t\t\t\t\t\t\t_doh.perfTestResults[gName] = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_doh.perfTestResults[gName][f.name] = doh.perfTestResults[gName][localFName];\n\t\t\t\t\t}catch (e){\n\t\t\t\t\t\tdoh.debug(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoh._groupStarted = function(){\n\t\t\t\tif(!this._setParent){\n\t\t\t\t\t_doh._curTestCount = this._testCount;\n\t\t\t\t\t_doh._curGroupCount = this._groupCount;\n\t\t\t\t\tthis._setParent = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoh._report = function(){\n\t\t\t};\n\t\t}\n\t}\n\n\tvar fixHeight = doh._fixHeight = function(){\n\t\t// IE9 doesn't give test iframe height because no nodes have an explicit pixel height!\n\t\t// Give outer table a pixel height.\n\t\tif(has(\"ie\")){\n\t\t\tvar headerHeight = 0;\n\t\t\tvar rows = query('#testLayout > tbody > tr');\n\t\t\tfor(var i = 0; i < rows.length-1; i++){\n\t\t\t\theaderHeight += domGeom.position(rows[i]).h;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\t// we subtract the headerHeight from the window height because the table row containing the tests is height:100% so they will stretch the table to the intended height.\n\t\t\t\tdom.byId('testLayout').style.height = (win.getBox().h - headerHeight)+\"px\";\n\t\t\t}catch(e){\n\t\t\t\t// An obscure race condition when you load the runner in IE from the command line causes the window reported height to be 0.\n\t\t\t\t// Try to recover after the window finishes rendering.\n\t\t\t\tsetTimeout(function(){ fixHeight(); },0);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn doh;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/doh.profile.js":"var testResourceRe = /^doh\\/tests/,\n\tlist = {\n\t\t\"doh/doh.profile\": 1,\n\t\t\"doh/package.json\": 1,\n\t\t\"doh/tests\": 1,\n\t\t\"doh/_parseURLargs\": 1\n\t},\n\tcopyOnly = function(mid){\n\t\treturn (mid in list);\n\t};\n\nvar profile = {\n\tresourceTags: {\n\t\ttest: function(filename, mid){\n\t\t\treturn testResourceRe.test(mid);\n\t\t},\n\n\t\tcopyOnly: function(filename, mid){\n\t\t\treturn copyOnly(mid);\n\t\t},\n\n\t\tamd: function(filename, mid){\n\t\t\treturn !testResourceRe.test(mid) && !copyOnly(mid) && /\\.js$/.test(filename);\n\t\t}\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/main.js":"define([\n\t\"doh/runner\",\n\t\"dojo/has!host-browser?doh/_browserRunner\",\n\t\"dojo/has!host-node?doh/_nodeRunner\",\n\t\"dojo/has!host-rhino?doh/_rhinoRunner\"], function(doh) {\n\treturn doh;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/_nodeRunner.js":"define([\"doh/runner\", \"require\", \"dojo/_base/config\"], function(doh, require, config){\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tModule for running DOH tests in node (as opposed to a browser).\n\t\t//\t\tAugments return value from doh/runner.\n\t};\n\t=====*/\n\n\tdoh.debug= console.log;\n\tdoh.error= console.log;\n\n\t// Override the doh._report method to make it quit with an\n\t// appropriate exit code in case of test failures.\n\tvar oldReport = doh._report;\n\tdoh._report = function(){\n\t\toldReport.apply(doh, arguments);\n\t\tif(this._failureCount > 0 || this._errorCount > 0){\n\t\t\tprocess.exit(1);\n\t\t}\n\t};\n\n\tconsole.log(\"\\n\"+doh._line);\n\tconsole.log(\"The Dojo Unit Test Harness, $Rev: e6490e5 $\");\n\tconsole.log(\"Copyright (c) 2011, The Dojo Foundation, All Rights Reserved\");\n\tconsole.log(\"Running with node.js\");\n\tfor (var tests= [], args= config[\"commandLineArgs\"], i= 0, arg; i<args.length; i++) {\n\t\targ= args[i];\n\t\tif (arg.length==2 && arg[0]==\"test\") {\n\t\t\tvar test= arg[1];\n\t\t\tconsole.log(\"loading test \" + test);\n\t\t\ttests.push(test);\n\t\t}\n\t}\n\tconsole.log(doh._line, \"\\n\");\n\n\trequire(tests, function() {\n\t\tdoh.run();\n\t});\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/_parseURLargs.js":"(function(){\n\tvar\n\t\tboot =\n\t\t\t// zero to many scripts to load a configuration and/or loader.\n\t\t\t// i.e. path-to-util/doh/runner.html?boots=path-to/config.js,path-to/require.js\n\t\t\t[\"../../dojo/dojo.js\"],\n\n\t\tstandardDojoBoot = boot,\n\n\t\ttest =\n\t\t\t// zero to many AMD modules and/or URLs to load; provided by csv URL query parameter=\"test\"\n\t\t\t// For example, the URL...\n\t\t\t//\n\t\t\t//\t\t path-to-util/doh/runner.html?test=doh/selfTest,my/path/test.js\n\t\t\t//\n\t\t\t// ...will load...\n\t\t\t//\n\t\t\t//\t * the AMD module doh/selfTest\n\t\t\t//\t * the plain old Javascript resource my/path/test.js\n\t\t\t//\n\t\t\t[\"dojo/tests/module\"],\n\n\t\tpaths = \n\t\t\t// zero to many path items to pass to the AMD loader; provided by semicolon separated values \n\t\t\t// for URL query parameter=\"paths\"; each path item has the form <from-path>,<to-path>\n\t\t\t// i.e. path-to-util/doh/runner.html?paths=my/from/path,my/to/path;my/from/path2,my/to/path2\n\t\t\t{},\n\t\t\t\n\t\tdohPlugins = \n\t\t\t// Semicolon separated list of files to load before the tests.\n\t\t\t// Idea is to override aspects of DOH for reporting purposes.\n\t\t\t\"\",\n\n\t\tbreakOnError = \n\t\t\t// boolean; instructs doh to call the debugger upon a test failures; this can be helpful when\n\t\t\t// trying to isolate exactly where the test failed\n\t\t\tfalse,\n\n\t\tasync = \n\t\t\t// boolean; config require.async==true before loading boot; this will have the effect of making\n\t\t\t// version 1.7+ dojo bootstrap/loader operating in async mode\n\t\t\tfalse,\n\n\t\tsandbox = \n\t\t\t// boolean; use a loader configuration that sandboxes the dojo and dojox objects used by doh\n\t\t\tfalse,\n\n\t\ttrim = function(text){\n\t\t\tif(text instanceof Array){\n\t\t\t\tfor (var result= [], i= 0; i<text.length; i++) {\n\t\t\t\t\tresult.push(trim(text[i]));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}else{\n\t\t\t\treturn text.match(/[^\\s]*/)[0]; \n\t\t\t}\n\t\t};\n\n\t\tqstr = window.location.search.substr(1);\n\n\tif(qstr.length){\n\t\tfor(var qparts = qstr.split(\"&\"), x = 0; x < qparts.length; x++){\n\t\t\tvar tp = qparts[x].split(\"=\"), name=tp[0], value=(tp[1]||\"\").replace(/[<>\"':\\(\\)]/g, \"\"); // replace() to avoid XSS attack\n\t\t\t//Avoid URLs that use the same protocol but on other domains, for security reasons.\n\t\t\tif (value.indexOf(\"//\") === 0 || value.indexOf(\"\\\\\\\\\") === 0) {\n\t\t\t\tthrow \"Insupported URL\";\n\t\t\t}\n\t\t\tswitch(name){\n\t\t\t\t// Note:\n\t\t\t\t//\t * dojoUrl is deprecated, and is a synonym for boot\n\t\t\t\t//\t * testUrl is deprecated, and is a synonym for test\n\t\t\t\t//\t * testModule is deprecated, and is a synonym for test (dots are automatically replaced with slashes)\n\t\t\t\t//\t * registerModulePath is deprecated, and is a synonym for paths\n\t\t\t\tcase \"boot\":\n\t\t\t\tcase \"dojoUrl\":\n\t\t\t\t\tboot= trim(value.split(\",\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"test\":\n\t\t\t\tcase \"testUrl\":\n\t\t\t\t\ttest= trim(value.split(\",\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"testModule\":\n\t\t\t\t\ttest= trim(value.replace(/\\./g, \"/\").split(\",\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\t// registerModulePath is deprecated; use \"paths\"\n\t\t\t\tcase \"registerModulePath\":\n\t\t\t\tcase \"paths\":\n\t\t\t\t\tfor(var path, modules = value.split(\";\"), i= 0; i<modules.length; i++){\n\t\t\t\t\t\tpath= modules[i].split(\",\");\n\t\t\t\t\t\tpaths[trim(path[0])]= trim(path[1]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"breakOnError\":\n\t\t\t\t\tbreakOnError= true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"sandbox\":\n\t\t\t\t\tsandbox= true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"async\":\n\t\t\t\t\tasync= true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"dohPlugins\":\n\t\t\t\t\tdohPlugins=value.split(\";\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar config;\n\tif(sandbox){\n\t\t// configure the loader assuming the dojo loader; of course the injected boot(s) can override this config\n\t\tconfig= {\n\t\t\tpaths: paths,\n\t\t\t// this config uses the dojo loader's scoping features to sandbox the version of dojo used by doh\n\t\t\tpackages: [{\n\t\t\t\tname: 'doh',\n\t\t\t\tlocation: '../util/doh',\n\t\t\t\t// here's the magic...every time doh asks for a \"dojo\" module, it gets mapped to a \"dohDojo\"\n\t\t\t\t// module; same goes for dojox/dohDojox since doh uses dojox\n\t\t\t\tpackageMap: {dojo:\"dohDojo\", dojox:\"dohDojox\"}\n\t\t\t},{\n\t\t\t\t// now define the dohDojo package...\n\t\t\t\tname: 'dohDojo',\n\t\t\t\tlocation: '../dojo',\n\t\t\t\tpackageMap: {dojo: \"dohDojo\", dojox: \"dohDojox\"}\n\t\t\t},{\n\t\t\t\t// and the dohDojox package...\n\t\t\t\tname: 'dohDojox',\n\t\t\t\tlocation: '../dojox',\n\t\t\t\t// and dojox uses dojo...that is, dohDojox...which must be mapped to dohDojo in the context of dohDojox\n\t\t\t\tpackageMap: {dojo: \"dohDojo\", dojox: \"dohDojox\"}\n\t\t\t}],\n\t\t\t\n\t\t\t// next, we need to preposition a special configuration for dohDojo\n\t\t\tcache: {\n\t\t\t\t\"dohDojo*_base/config\": function(){\n\t\t\t\t\tdefine([], {\n\t\t\t\t\t\t// this configuration keeps dojo, dijit, and dojox out of the global space\n\t\t\t\t\t\tscopeMap: [[\"dojo\", \"dohDojo\"], [\"dijit\", \"dohDijit\"], [\"dojox\", \"dohDojox\"]],\n\t\t\t\t\t\tisDebug: true,\n\t\t\t\t\t\tnoGlobals: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// control the loader; don't boot global dojo, doh will ask for dojo itself\n\t\t\thas: {\n\t\t\t\t\"dojo-sniff\": 0,\n\t\t\t\t\"dojo-loader\": 1,\n\t\t\t\t\"dojo-boot\": 0,\n\t\t\t\t\"dojo-test-sniff\": 1\n\t\t\t},\n\n\t\t\t// no sniffing; therefore, set the baseUrl\n\t\t\tbaseUrl: \"../../dojo\",\n\n\t\t\tdeps: [\"dohDojo/domReady\", \"doh\"],\n\n\t\t\tcallback: function(domReady, doh){\n\t\t\t\tdomReady(function(){\n\t\t\t\t\tdoh._fixHeight();\n\t\t\t\t\tdoh.breakOnError= breakOnError;\n\t\t\t\t\trequire(test, function(){\n\t\t\t\t\t\tdoh.run();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tasync: async\n\t\t};\n\t}else{\n\t\tconfig= {\n\t\t\tpaths: paths,\n\t\t\tdeps: [\"dojo/domReady\", \"doh\"],\n\t\t\tcallback: function(domReady, doh){\n\t\t\t\tdomReady(function(){\n\t\t\t\t\tdoh._fixHeight();\n\t\t\t\t\tdoh.breakOnError= breakOnError;\n\t\t\t\t\trequire(test, function(){\n\t\t\t\t\t\tdoh.run();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tasync: async,\n\t\t\tisDebug: 1\n\t\t};\n\t}\n\t\n\t// load all of the dohPlugins\n\tif(dohPlugins){\n\t\tvar i = 0;\n\t\tfor(i = 0; i < dohPlugins.length; i++){\n\t\t\tconfig.deps.push(dohPlugins[i]);\n\t\t}\n\t}\n\t\n\trequire = config;\n\n\t// now script inject any boots\n\tfor(var e, i = 0; i < boot.length; i++) {\n\t\tif(boot[i]){\n\t\t\te = document.createElement(\"script\");\n\t\t\te.type = \"text/javascript\";\n\t\t\te.src = boot[i];\n\t\t\te.charset = \"utf-8\";\n\t\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(e);\n\t\t}\n\t}\n})();","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/_rhinoRunner.js":"define([\"doh/runner\", \"require\", \"dojo/_base/config\"], function(doh, require, config){\n\t/*=====\n\t return {\n\t // summary:\n\t //\t\tModule for running DOH tests in rhino (as opposed to a browser).\n\t //\t\tAugments return value from doh/runner.\n\t };\n\t =====*/\n\n\tdoh.debug= print;\n\tdoh.error= print;\n\n\t// Override the doh._report method to make it quit with an\n\t// appropriate exit code in case of test failures.\n\tvar oldReport = doh._report;\n\tdoh._report = function(){\n\t\toldReport.apply(doh, arguments);\n\t\tif(this._failureCount > 0 || this._errorCount > 0){\n\t\t\tquit(1);\n\t\t}\n\t};\n\n\tprint(\"\\n\"+doh._line);\n\tprint(\"The Dojo Unit Test Harness, $Rev: e6490e5 $\");\n\tprint(\"Copyright (c) 2011, The Dojo Foundation, All Rights Reserved\");\n\tfor (var tests= [], args= config[\"commandLineArgs\"], i= 0, arg; i<args.length; i++) {\n\t\targ= (args[i]+\"\").split(\"=\");\n\t\tif (arg.length==2 && arg[0]==\"test\") {\n\t\t\tvar test= arg[1];\n\t\t\tprint(\"loading test \" + test);\n\t\t\ttests.push(test);\n\t\t}\n\t}\n\tprint(doh._line, \"\\n\");\n\n\trequire(tests, function() {\n\t\tdoh.run();\n\t});\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/robot.js":"define([\n\t\"doh/_browserRunner\", \"require\",\n\t\"dojo/aspect\", \"dojo/Deferred\", \"dojo/dom-class\", \"dojo/dom-construct\", \"dojo/dom-geometry\", \"dojo/_base/lang\", \"dojo/ready\",\n\t\"dojo/_base/unload\", \"dojo/when\", \"dojo/_base/window\", \"dojo/sniff\", \"dojo/has\", \"dojo/has!android?doh/plugins/android-webdriver-robot\"\n], function(doh, require, aspect, Deferred, domClass, construct, geom, lang, ready, unload, when, win, sniff, has, webdriver){\n\n// loading state\nvar _robot = null;\n\nvar isSecure = (function(){\n\tvar key = Math.random();\n\treturn function(fcn){\n\t\treturn key;\n\t};\n})();\n\nvar _keyPress = function(/*Number*/ charCode, /*Number*/ keyCode, /*Boolean*/ alt, /*Boolean*/ ctrl, /*Boolean*/ shift, /*Boolean*/ meta, /*Integer?*/ delay, /*Boolean*/ async){\n\t// internal function to type one non-modifier key\n\n\t// typecasting Numbers helps Sun's IE plugin lookup methods that take int arguments\n\n\t// otherwise JS will send a double and Sun will complain\n\t_robot.typeKey(isSecure(), Number(charCode), Number(keyCode), Boolean(alt), Boolean(ctrl), Boolean(shift), Boolean(meta), Number(delay||0), Boolean(async||false));\n};\n\n// Queue of pending actions plus the currently executing action registered via sequence().\n// Each action is a function that either:\n//\t\t1. does a setTimeout()\n//\t\t2. calls java Robot (mouse movement, typing a single letter, etc.)\n//\t\t3. executes user defined function (for when app called sequence() directly).\n// Each function can return a Promise, or just a plain value if it executes synchronously.\nvar seqPromise;\naspect.before(doh, \"_runFixture\", function(){\n\t// At the start of each new test fixture, clear any leftover queued actions from the previous test fixture.\n\t// This will happen when the previous test throws an error, or times out.\n\tvar _seqPromise = seqPromise;\n\t// need setTimeout to avoid false error; seqPromise from passing test is not fulfilled until after this execution trace finishes!\n\t// really we should not have both `seqPromise` here and `var d = new doh.Deferred()` in the test\n\tsetTimeout(function(){\n\t\tif(_seqPromise && !_seqPromise.isFulfilled()){\n\t\t\t_seqPromise.cancel(new Error(\"new test starting, cancelling pending & in-progress queued events from previous test\")); \n\t\t}\n\t},0);\n\tseqPromise = new Deferred();\n\tseqPromise.resolve(true);\n});\n\n// Previous mouse position (from most recent mouseMoveTo() command)\nvar lastMouse = {x: 5, y: 5};\n\n// For 2.0, remove code to set doh.robot global.\nvar robot = doh.robot = {\n\t_robotLoaded: true,\n\t_robotInitialized: false,\n\t// prime the event pump for fast browsers like Google Chrome - it's so fast, it doesn't stop to listen for keypresses!\n\t_spaceReceived: false,\n\t_primePump: false,\n\n\t_killApplet: function(){}, // overridden by Robot.html\n\n\tkillRobot: function(){\n\t\tif(robot._robotLoaded){\n\t\t\trobot._robotLoaded = false;\n\t\t\tdomClass.remove(document.documentElement, \"dohRobot\");\n\t\t\trobot._killApplet();\n\t\t}\n\t},\n\n\t// Robot init methods\n\n\t// controls access to doh.run\n\t// basically, doh.run takes two calls to start the robot:\n\t// one (or more after the robot loads) from the test page\n\t// one from either the applet or an error condition\n\t_runsemaphore: {\n\t\tlock: [\"lock\"],\n\t\tunlock: function(){\n\t\t\ttry{\n\t\t\t\treturn this.lock.shift();\n\t\t\t}catch(e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\n\tstartRobot: function(){\n\t\t//startRobot should be called to initialize the robot (after the java applet is loaded).\n\t\t//one good place to do this is in a dojo.addOnLoad handler. This function will be called\n\t\t//automatically if it is not already called when doh.run() is invoked.\n\t\tif(!this._robotInitialized){\n\t\t\tthis._robotInitialized = true;\n\t\t\t// if the iframe requested the applet and got a 404, then _robot is obviously unavailable\n\t\t\t// at least run the non-robot tests!\n\t\t\tif(robot._appletDead){\n\t\t\t\trobot._onKeyboard();\n\t\t\t}else{\n\t\t\t\t_robot._callLoaded(isSecure());\n\t\t\t}\n\t\t}\n\n\t\t// When robot finishes initializing it types a key, firing the _onKeyboard() listener, which calls _run(),\n\t\t// which resolves this Deferred.\n\t\treturn this._started;\n\t},\n\n\t// _loaded: Deferred\n\t//\t\tDeferred that resolves when the _initRobot() has been called.\n\t//\t\tNote to be confused with dojo/robotx.js, which defines initRobot() without an underscore\n\t_loaded: new doh.Deferred(),\n\n\t_initRobot: function(r){\n\t\t// called from Robot\n\t\t// Robot calls _initRobot in its startup sequence\n\n\t\t// Prevent rerunning the whole test (see #8958 for details)\n\t\tif(doh._initRobotCalled){ return; }\n\t\tdoh._initRobotCalled = true;\n\n\t\t// add dohRobot class to HTML element so tests can use that in CSS rules if desired\n\t\tdomClass.add(document.documentElement, \"dohRobot\");\n\t\twindow.scrollTo(0, 0);\n//\t\tdocument.documentElement.scrollTop = document.documentElement.scrollLeft = 0;\n\t\t_robot = r;\n\t\t_robot._setKey(isSecure());\n\t\tthis._loaded.resolve(true);\n\t},\n\n\t// _started: Deferred\n\t//\t\tDeferred that resolves when startRobot() has signaled completing by typing on the keyboard,\n\t//\t\twhich in turn calls _run().\n\t_started: new doh.Deferred(),\n\n\t// some utility functions to help the iframe use private variables\n\t_run: function(frame){\n\t\t// called after the robot has been able to type on the keyboard, indicating that it's started\n\t\tframe.style.visibility = \"hidden\";\n\t\tthis._started.resolve(true);\n\t},\n\n\t_initKeyboard: function(){\n\t\t_robot._initKeyboard(isSecure());\n\t},\n\n\t_onKeyboard: function(){\n\t\t// replaced by iframe when applet present.\n\t\t// remote robots don't have frames so pass a mock frame.\n\t\tthis._run({style:{visibility:\"\"}});\n\t},\n\n\t_initWheel: function(){\n\t\t_robot._initWheel(isSecure());\n\t},\n\n\t_setDocumentBounds: function(docScreenX, docScreenY){\n\t\tvar robotView = document.getElementById(\"dohrobotview\");\n\t\t_robot.setDocumentBounds(isSecure(), Number(docScreenX), Number(docScreenY), Number(robotView.offsetLeft), Number(robotView.offsetTop));\n\t},\n\n\t_notified: function(keystring){\n\t\t_robot._notified(isSecure(), keystring);\n\t},\n\n\t// if the applet is 404 or cert is denied, this becomes true and kills tests\n\t_appletDead: false,\n\n\t_assertRobot: function(){\n\t\t// make sure the applet is there and cert accepted\n\t\t// otherwise, skip the test requesting the robot action\n\t\tif(robot._appletDead){ throw new Error('robot not available; skipping test.'); }\n\t},\n\n\t_mouseMove: function(/*Number*/ x, /*Number*/ y, /*Boolean*/ absolute, /*Integer?*/ duration){\n\t\t// This function is no longer used, but left for back-compat\n\t\tif(absolute){\n\t\t\tvar scroll = {y: (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n\t\t\tx: (window.pageXOffset || geom.fixIeBiDiScrollLeft(document.documentElement.scrollLeft) || document.body.scrollLeft || 0)};\n\t\t\ty -= scroll.y;\n\t\t\tx -= scroll.x;\n\t\t}\n\t\t_robot.moveMouse(isSecure(), Number(x), Number(y), Number(0), Number(duration||100));\n\t},\n\n\t// Main robot API\n\tsequence: function(/*Function*/ f, /*Integer?*/ delay, /*Integer?*/ duration){\n\t\t// summary:\n\t\t//\t\tDefer an action by adding it to the robot's incrementally delayed queue of actions to execute.\n\t\t// f:\n\t\t//\t\tA function containing actions you want to defer.  It can return a Promise\n\t\t//\t\tto delay further actions.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// duration:\n\t\t//\t\tDelay to wait after firing.\n\n\t\tfunction waitFunc(ms){\n\t\t\t// Returns a function that returns a Promise that fires after ms milliseconds.\n\t\t\treturn function(){\n\t\t\t\tvar timer, d;\n\t\t\t\td = new Deferred(function(){ clearTimeout(timer); });\n\t\t\t\ttimer = setTimeout(function(){ d.resolve(true); }, ms);\n\t\t\t\treturn d;\n\t\t\t};\n\t\t}\n\n\t\t// Queue action to run specified function, plus optional \"wait\" actions for delay and duration.\n\t\tif(delay){ seqPromise = seqPromise.then(waitFunc(delay)); }\n\t\tseqPromise = seqPromise.then(f);\n\t\tif(duration){ seqPromise = seqPromise.then(waitFunc(duration)); }\n\t},\n\n\ttypeKeys: function(/*String|Number*/ chars, /*Integer?*/ delay, /*Integer?*/ duration){\n\t\t// summary:\n\t\t//\t\tTypes a string of characters in order, or types a dojo.keys.* constant.\n\t\t// description:\n\t\t//\t\tTypes a string of characters in order, or types a dojo.keys.* constant.\n\t\t// example:\n\t\t// |\trobot.typeKeys(\"dijit.ed\", 500);\n\t\t// chars:\n\t\t//\t\tString of characters to type, or a dojo.keys.* constant\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// duration:\n\t\t//\t\tTime, in milliseconds, to spend pressing all of the keys.\n\t\t//\t\tThe default is (string length)*50 ms.\n\n\t\tthis._assertRobot();\n\t\tvar isNum = typeof(chars) == Number;\n\t\tduration = duration||(isNum?50: chars.length*50);\n\t\tif(isNum){\n\t\t\tthis.sequence(lang.partial(_keyPress, chars, chars, false, false, false, false, 0, 0),\n\t\t\t\tdelay, duration);\n\t\t}else{\n\t\t\tfor(var i = 0; i < chars.length; i++){\n\t\t\t\tthis.sequence(lang.partial(_keyPress, chars.charCodeAt(i), 0, false, false, false, false, 0, 0),\n\t\t\t\t\ti == 0 ? delay : 0, Math.max(Math.ceil(duration/chars.length), 0));\n\t\t\t}\n\t\t}\n\t},\n\n\tkeyPress: function(/*Integer*/ charOrCode, /*Integer?*/ delay, /*Object*/ modifiers, /*Boolean*/ asynchronous){\n\t\t// summary:\n\t\t//\t\tTypes a key combination, like SHIFT-TAB.\n\t\t// description:\n\t\t//\t\tTypes a key combination, like SHIFT-TAB.\n\t\t// example:\n\t\t//\t\tto press shift-tab immediately, call robot.keyPress(dojo.keys.TAB, 0, {shift: true})\n\t\t// charOrCode:\n\t\t//\t\tchar/JS keyCode/dojo.keys.* constant for the key you want to press\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// modifiers:\n\t\t//\t\tJSON object that represents all of the modifier keys being pressed.\n\t\t//\t\tIt takes the following Boolean attributes:\n\t\t//\n\t\t//\t\t- shift\n\t\t//\t\t- alt\n\t\t//\t\t- ctrl\n\t\t//\t\t- meta\n\t\t// asynchronous:\n\t\t//\t\tIf true, the delay happens asynchronously and immediately, outside of the browser's JavaScript thread and any previous calls.\n\t\t//\t\tThis is useful for interacting with the browser's modal dialogs.\n\n\t\tthis._assertRobot();\n\t\tif(!modifiers){\n\t\t\tmodifiers = {alt:false, ctrl:false, shift:false, meta:false};\n\t\t}else{\n\t\t\t// normalize modifiers\n\t\t\tvar attrs = [\"alt\", \"ctrl\", \"shift\", \"meta\"];\n\t\t\tfor(var i = 0; i<attrs.length; i++){\n\t\t\t\tif(!modifiers[attrs[i]]){\n\t\t\t\t\tmodifiers[attrs[i]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar isChar = typeof(charOrCode)==\"string\";\n\t\tif(asynchronous){\n\t\t\t_keyPress(isChar?charOrCode.charCodeAt(0):0, isChar?0:charOrCode, modifiers.alt, modifiers.ctrl, modifiers.shift, modifiers.meta, delay, true);\n\t\t\treturn;\n\t\t}\n\t\tthis.sequence(function(){\n\t\t\t_keyPress(isChar?charOrCode.charCodeAt(0):0, isChar?0:charOrCode, modifiers.alt, modifiers.ctrl, modifiers.shift, modifiers.meta, 0);\n\t\t}, delay);\n\t},\n\n\tkeyDown: function(/*Integer*/ charOrCode, /*Integer?*/ delay){\n\t\t// summary:\n\t\t//\t\tHolds down a single key, like SHIFT or 'a'.\n\t\t// description:\n\t\t//\t\tHolds down a single key, like SHIFT or 'a'.\n\t\t// example:\n\t\t//\t\tto hold down the 'a' key immediately, call robot.keyDown('a')\n\t\t// charOrCode:\n\t\t//\t\tchar/JS keyCode/dojo.keys.* constant for the key you want to hold down\n\t\t//\t\tWarning: holding down a shifted key, like 'A', can have unpredictable results.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\n\t\tthis._assertRobot();\n\t\tthis.sequence(function(){\n\t\t\tvar isChar = typeof(charOrCode)==\"string\";\n\t\t\t_robot.downKey(isSecure(), isChar?charOrCode:0, isChar?0:charOrCode, 0);\n\t\t}, delay);\n\t},\n\n\tkeyUp: function(/*Integer*/ charOrCode, /*Integer?*/ delay){\n\t\t// summary:\n\t\t//\t\tReleases a single key, like SHIFT or 'a'.\n\t\t// description:\n\t\t//\t\tReleases a single key, like SHIFT or 'a'.\n\t\t// example:\n\t\t//\t\tto release the 'a' key immediately, call robot.keyUp('a')\n\t\t// charOrCode:\n\t\t//\t\tchar/JS keyCode/dojo.keys.* constant for the key you want to release\n\t\t//\t\tWarning: releasing a shifted key, like 'A', can have unpredictable results.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\n\t\tthis._assertRobot();\n\t\tthis.sequence(function(){\n\t\t\tvar isChar=typeof(charOrCode)==\"string\";\n\t\t\t_robot.upKey(isSecure(), isChar?charOrCode:0, isChar?0:charOrCode, 0);\n\t\t}, delay);\n\t},\n\n\n\tmouseClick: function(/*Object*/ buttons, /*Integer?*/ delay){\n\t\t// summary:\n\t\t//\t\tConvenience function to do a press/release.\n\t\t//\t\tSee robot.mousePress for more info.\n\t\t// description:\n\t\t//\t\tConvenience function to do a press/release.\n\t\t//\t\tSee robot.mousePress for more info.\n\n\t\tthis._assertRobot();\n\t\trobot.mousePress(buttons, delay);\n\t\trobot.mouseRelease(buttons, 1);\n\t},\n\n\tmousePress: function(/*Object*/ buttons, /*Integer?*/ delay){\n\t\t// summary:\n\t\t//\t\tPresses mouse buttons.\n\t\t// description:\n\t\t//\t\tPresses the mouse buttons you pass as true.\n\t\t//\t\tExample: to press the left mouse button, pass {left: true}.\n\t\t//\t\tMouse buttons you don't specify keep their previous pressed state.\n\t\t// buttons:\n\t\t//\t\tJSON object that represents all of the mouse buttons being pressed.\n\t\t//\t\tIt takes the following Boolean attributes:\n\t\t//\n\t\t//\t\t- left\n\t\t//\t\t- middle\n\t\t//\t\t- right\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\n\t\tthis._assertRobot();\n\t\tif(!buttons){ return; }\n\t\tthis.sequence(function(){\n\t\t\tvar attrs = [\"left\", \"middle\", \"right\"];\n\t\t\tfor(var i = 0; i<attrs.length; i++){\n\t\t\t\tif(!buttons[attrs[i]]){\n\t\t\t\t\tbuttons[attrs[i]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_robot.pressMouse(isSecure(), Boolean(buttons.left), Boolean(buttons.middle), Boolean(buttons.right), Number(0));\n\t\t}, delay);\n\t},\n\n\tmouseMoveTo: function(/*Object*/ point, /*Integer?*/ delay, /*Integer?*/ duration, /*Boolean*/ absolute){\n\t\t// summary:\n\t\t//\t\tMove the mouse from the current position to the specified point.\n\t\t//\t\tDelays reading contents point until queued command starts running.\n\t\t//\t\tSee mouseMove() for details.\n\t\t// point: Object\n\t\t//\t\tx, y position relative to viewport, or if absolute == true, to document\n\n\t\tthis._assertRobot();\n\t\tduration = duration||100;\n\n\t\t// Calculate number of mouse movements we will do, based on specified duration.\n\t\t// IE6-8 timers have a granularity of 15ms, so only do one mouse move every 15ms\n\t\tvar steps = duration<=1 ? 1 : // duration==1 -> user wants to jump the mouse\n\t\t\t(duration/15)|1; // |1 to ensure an odd # of intermediate steps for sensible interpolation\n\t\tvar stepDuration = Math.floor(duration/steps);\n\n\t\t// Starting and ending points of the mouse movement.\n\t\tvar start, end;\n\n\t\tthis.sequence(function(){\n\t\t\t// This runs right before we start moving the mouse.   At this time (but not before), point is guaranteed\n\t\t\t// to be filled w/the correct data.   So set start and end points for the movement of the mouse.\n\t\t\tstart = lastMouse;\n\t\t\tif(absolute){\n\t\t\t\t// Adjust end to be relative to viewport\n\t\t\t\tvar scroll = {y: (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n\t\t\t\t\tx: (window.pageXOffset || geom.fixIeBiDiScrollLeft(document.documentElement.scrollLeft) || document.body.scrollLeft || 0)};\n\t\t\t\tend = { y: point.y - scroll.y, x: point.x - scroll.x };\n\t\t\t}else{\n\t\t\t\tend = point;\n\t\t\t}\n\t\t\t//console.log(\"mouseMoveTo() start, going from (\", lastMouse.x, lastMouse.y, \"), (\", end.x, end.y, \"), delay = \" +\n\t\t\t//\tdelay + \", duration = \" + duration);\n\t\t}, delay || 0);\n\n\t\t// Function to positions the mouse along the line from start to end at the idx'th position (from 0 .. steps)\n\t\tfunction step(idx){\n\t\t\tfunction easeInOutQuad(/*Number*/ t, /*Number*/ b, /*Number*/ c, /*Number*/ d){\n\t\t\t\tt /= d / 2;\n\t\t\t\tif(t < 1)\n\t\t\t\t\treturn Math.round(c / 2 * t * t + b);\n\t\t\t\tt--;\n\t\t\t\treturn Math.round(-c / 2 * (t * (t - 2) - 1) + b);\n\t\t\t}\n\n\t\t\tvar x = idx == steps ? end.x : easeInOutQuad(idx, start.x, end.x - start.x, steps),\n\t\t\t\ty = idx == steps ? end.y : easeInOutQuad(idx, start.y, end.y - start.y, steps);\n\n\t\t\t// If same position as the last time, don't bother calling java robot.\n\t\t\tif(x == lastMouse.x && y == lastMouse.y){ return true; }\n\n\t\t\t_robot.moveMouse(isSecure(), Number(x), Number(y), Number(0), Number(1));\n\t\t\tlastMouse = {x: x, y: y};\n\t\t}\n\n\t\t// Schedule mouse moves from beginning to end of line.\n\t\t// Start from t=1 because there's no need to move the mouse to where it already is\n\t\tfor (var t = 1; t <= steps; t++){\n\t\t\t// Use lang.partial() to lock in value of t before the t++\n\t\t\tthis.sequence(lang.partial(step, t), 0, stepDuration);\n\t\t}\n\t},\n\n\tmouseMove: function(/*Number*/ x, /*Number*/ y, /*Integer?*/ delay, /*Integer?*/ duration, /*Boolean*/ absolute){\n\t\t// summary:\n\t\t//\t\tMoves the mouse to the specified x,y offset relative to the viewport.\n\t\t// x:\n\t\t//\t\tx offset relative to the viewport, in pixels, to move the mouse.\n\t\t// y:\n\t\t//\t\ty offset relative to the viewport, in pixels, to move the mouse.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t// |\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// duration:\n\t\t//\t\tApproximate time Robot will spend moving the mouse\n\t\t//\t\tThe default is 100ms. This also affects how many mousemove events will\n\t\t//\t\tbe generated, which is the log of the duration.\n\t\t// absolute:\n\t\t//\t\tBoolean indicating whether the x and y values are absolute coordinates.\n\t\t//\t\tIf false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)\n\t\t//\t\tIf true, then mouseMove expects that the x,y will be absolute. (pageX/Y)\n\n\t\tthis.mouseMoveTo({x: x, y: y}, delay, duration, absolute);\n\t},\n\n\tmouseRelease: function(/*Object*/ buttons, /*Integer?*/ delay){\n\t\t// summary:\n\t\t//\t\tReleases mouse buttons.\n\t\t// description:\n\t\t//\t\tReleases the mouse buttons you pass as true.\n\t\t//\t\tExample: to release the left mouse button, pass {left: true}.\n\t\t//\t\tMouse buttons you don't specify keep their previous pressed state.\n\t\t//\t\tSee robot.mousePress for more info.\n\n\t\tthis._assertRobot();\n\t\tif(!buttons){ return; }\n\t\tthis.sequence(function(){\n\t\t\tvar attrs = [\"left\", \"middle\", \"right\"];\n\t\t\tfor(var i = 0; i<attrs.length; i++){\n\t\t\t\tif(!buttons[attrs[i]]){\n\t\t\t\t\tbuttons[attrs[i]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_robot.releaseMouse(isSecure(), Boolean(buttons.left), Boolean(buttons.middle), Boolean(buttons.right), Number(0));\n\t\t}, delay);\n\t},\n\n\t// mouseWheelSize: Integer value that determines the amount of wheel motion per unit\n\tmouseWheelSize: 1,\n\n\tmouseWheel: function(/*Number*/ wheelAmt, /*Integer?*/ delay, /*Integer?*/ duration){\n\t\t// summary:\n\t\t//\t\tSpins the mouse wheel.\n\t\t// description:\n\t\t//\t\tSpins the wheel wheelAmt \"notches.\"\n\t\t//\t\tNegative wheelAmt scrolls up/away from the user.\n\t\t//\t\tPositive wheelAmt scrolls down/toward the user.\n\t\t//\t\tNote: this will all happen in one event.\n\t\t//\t\tWarning: the size of one mouse wheel notch is an OS setting.\n\t\t//\t\tYou can access this size from robot.mouseWheelSize\n\t\t// wheelAmt:\n\t\t//\t\tNumber of notches to spin the wheel.\n\t\t//\t\tNegative wheelAmt scrolls up/away from the user.\n\t\t//\t\tPositive wheelAmt scrolls down/toward the user.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t//\t\t\trobot.mouseClick({left: true}, 100) // first call; wait 100ms\n\t\t//\t\t\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// duration:\n\t\t//\t\tApproximate time Robot will spend moving the mouse\n\t\t//\t\tBy default, the Robot will wheel the mouse as fast as possible.\n\n\t\tthis._assertRobot();\n\t\tif(!wheelAmt){ return; }\n\t\tthis.sequence(function(){\n\t\t\t_robot.wheelMouse(isSecure(), Number(wheelAmt), Number(0), Number(duration||0));\n\t\t}, delay, duration);\n\t},\n\n\tsetClipboard: function(/*String*/ data,/*String?*/ format){\n\t\t// summary:\n\t\t//\t\tSet clipboard content.\n\t\t// description:\n\t\t//\t\tSet data as clipboard content, overriding anything already there. The\n\t\t//\t\tdata will be put to the clipboard using the given format.\n\t\t// data:\n\t\t//\t\tNew clipboard content to set\n\t\t// format:\n\t\t//\t\tSet this to \"text/html\" to put richtext to the clipboard.\n\t\t//\t\tOtherwise, data is treated as plaintext. By default, plaintext\n\t\t//\t\tis used.\n\t\tif(format==='text/html'){\n\t\t\t_robot.setClipboardHtml(isSecure(), data);\n\t\t}else{\n\t\t\t_robot.setClipboardText(isSecure(), data);\n\t\t}\n\t}\n};\n\n// After page has finished loading, create the applet iframe.\n// Note: could eliminate dojo/ready dependency by tying this code to startRobot() call, but then users\n// are required to put doh.run() inside of a dojo/ready.   Probably they are already doing that though.\nready(function(){\n\t// console.log(\"creating applet iframe\");\n\tvar iframesrc;\n\tvar scripts = document.getElementsByTagName(\"script\");\n\tfor(var x = 0; x<scripts.length; x++){\n\t\tvar s = scripts[x].getAttribute('src');\n\t\tif(s && (s.substr(s.length-9) == \"runner.js\")){\n\t\t\tiframesrc = s.substr(0, s.length-9)+'Robot.html';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(!iframesrc){\n\t\t// if user set document.domain to something else, send it to the Robot too\n\t\tiframesrc = require.toUrl(\"./Robot.html\") + \"?domain=\" + escape(document.domain);\n\t}\n\tconstruct.place('<div id=\"dohrobotview\" style=\"border:0px none; margin:0px; padding:0px; position:absolute; bottom:0px; right:0px; width:1px; height:1px; overflow:hidden; visibility:hidden; background-color:red;\"></div>',\n\t\twin.body());\n\n\tif(!has(\"doh-custom-robot\")){\n\t\t// load default robot when not custom def given\n\t\tconstruct.place('<iframe application=\"true\" style=\"border:0px none; z-index:32767; padding:0px; margin:0px; position:absolute; left:0px; top:0px; height:100px; width:200px; overflow:hidden; background-color:transparent;\" tabIndex=\"-1\" src=\"'+iframesrc+'\" ALLOWTRANSPARENCY=\"true\"></iframe>',\n\t\t\twin.body());\n\t}else{\n\t\t// custom def given\n\t\tconsole.log(\"using custom robot\");\n\t\t_robot = webdriver;\n\t\t// mix in exports\n\t\tfor(var i in _robot){\n\t\t\tif(robot[i]&&_robot[i]){\n\t\t\t\trobot[i]=_robot[i];\n\t\t\t}\n\t\t}\n\t\t// continue init instead of waiting on frame\n\t\trobot._initRobot(_robot);\n\t}\n});\n\n// Start the robot as the first \"test\" when DOH runs.\ndoh.registerGroup(\"initialize robot\", [\n\t{\n\t\tname: \"load robot\",\n\t\ttimeout: 20000,\n\t\trunTest: function(){\n\t\t\t// first wait for robot to tell us it's loaded, i.e. that _initRobot() has been called\n\t\t\treturn robot._loaded;\n\t\t}\n\t},\n\t{\n\t\tname: \"start robot\",\n\t\ttimeout: 20000,\n\t\trunTest: function(){\n\t\t\t// then we call startRobot(), and wait it to asynchronously complete\n\t\t\treturn robot.startRobot();\n\t\t}\n\t}\n]);\n\n// Register the killRobot() command as the last \"test\" to run.\n// There's no good API to do this, so instead call doh.registerGroup() when the app first calls doh.run(),\n// since presumably all the real tests have already been registered.   Note that doh.run() is called multiple times,\n// so make sure to only call registerGroup() once.\nvar _oldRun = doh.run;\ndoh.run = function(){\n\tdoh.registerGroup(\"kill robot\", {\n\t\tname: \"killRobot\",\n\t\ttimeout: 10000,\n\t\trunTest: function(){\n\t\t\trobot.killRobot();\n\t\t}\n\t});\n\tdoh.run = _oldRun;\n\tdoh.run();\n};\n\n\nreturn robot;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/doh/runner.js":"define(\"doh/runner\", [\"dojo/_base/lang\"], function(lang){\n\nvar doh = {\n\t// summary:\n\t//\t\tFunctions for registering and running automated tests.\n};\n\n// intentionally define global tests and global doh symbols\n// TODO: scrub these globals from tests and remove this pollution for 2.0\ntests = doh;\nthis.doh = doh;\n\ndoh._line = \"------------------------------------------------------------\";\n\ndoh.debug = function(){\n\t// summary:\n\t//\t\ttakes any number of arguments and sends them to whatever debugging\n\t//\t\tor logging facility is available in this environment\n\n\t// YOUR TEST RUNNER NEEDS TO IMPLEMENT THIS\n};\n\ndoh.error = function(){\n\t// summary:\n\t//\t\tlogging method to be used to send Error objects, so that\n\t//\t\twhatever debugging or logging facility you have can decide to treat it\n\t//\t\tas an Error object and show additional information - such as stack trace\n\n\t// YOUR TEST RUNNER NEEDS TO IMPLEMENT THIS\n};\n\ndoh._AssertFailure = function(msg, hint){\n\tif (doh.breakOnError) {\n\t\t//>>excludeStart(\"debuggerCrashesRhino\", /^shrinksafe.comments/.test(kwArgs.optimize));\n\t\tdebugger;\n\t\t//>>excludeEnd(\"debuggerCrashesRhino\")\n\t}\n\tif(!(this instanceof doh._AssertFailure)){\n\t\treturn new doh._AssertFailure(msg, hint);\n\t}\n\tif(hint){\n\t\tmsg = (new String(msg||\"\"))+\" with hint: \\n\\t\\t\"+(new String(hint)+\"\\n\");\n\t}\n\tthis.message = new String(msg||\"\");\n\treturn this;\n};\ndoh._AssertFailure.prototype = new Error();\ndoh._AssertFailure.prototype.constructor = doh._AssertFailure;\ndoh._AssertFailure.prototype.name = \"doh._AssertFailure\";\n\ndoh.Deferred = function(canceller){\n\tthis.chain = [];\n\tthis.id = this._nextId();\n\tthis.fired = -1;\n\tthis.paused = 0;\n\tthis.results = [null, null];\n\tthis.canceller = canceller;\n\tthis.silentlyCancelled = false;\n};\n\nlang.extend(doh.Deferred, {\n\tgetTestErrback: function(cb, scope){\n\t\t// summary:\n\t\t//\t\tReplaces outer getTextCallback's in nested situations to avoid multiple callback(true)'s\n\t\tvar _this = this;\n\t\treturn function(){\n\t\t\ttry{\n\t\t\t\tcb.apply(scope||doh.global||_this, arguments);\n\t\t\t}catch(e){\n\t\t\t\t_this.reject(e);\n\t\t\t}\n\t\t};\n\t},\n\n\tgetTestCallback: function(cb, scope){\n\t\tvar _this = this;\n\t\treturn function(){\n\t\t\ttry{\n\t\t\t\tcb.apply(scope||doh.global||_this, arguments);\n\t\t\t}catch(e){\n\t\t\t\t_this.reject(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_this.resolve(true);\n\t\t};\n\t},\n\n\t_nextId: (function(){\n\t\tvar n = 1;\n\t\treturn function(){ return n++; };\n\t})(),\n\n\tcancel: function(){\n\t\tif(this.fired == -1){\n\t\t\tif (this.canceller){\n\t\t\t\tthis.canceller(this);\n\t\t\t}else{\n\t\t\t\tthis.silentlyCancelled = true;\n\t\t\t}\n\t\t\tif(this.fired == -1){\n\t\t\t\tthis.reject(new Error(\"Deferred(unfired)\"));\n\t\t\t}\n\t\t}else if(this.fired == 0 && this.results[0] && this.results[0].cancel){\n\t\t\tthis.results[0].cancel();\n\t\t}\n\t},\n\n\t_pause: function(){\n\t\tthis.paused++;\n\t},\n\n\t_unpause: function(){\n\t\tthis.paused--;\n\t\tif ((this.paused == 0) && (this.fired >= 0)) {\n\t\t\tthis._fire();\n\t\t}\n\t},\n\n\t_continue: function(res){\n\t\tthis._resback(res);\n\t\tthis._unpause();\n\t},\n\n\t_resback: function(res){\n\t\tthis.fired = ((res instanceof Error) ? 1 : 0);\n\t\tthis.results[this.fired] = res;\n\t\tthis._fire();\n\t},\n\n\t_check: function(){\n\t\tif(this.fired != -1){\n\t\t\tif(!this.silentlyCancelled){\n\t\t\t\tthrow new Error(\"already called!\");\n\t\t\t}\n\t\t\tthis.silentlyCancelled = false;\n\t\t}\n\t},\n\n\tresolve: function(res){\n\t\tthis._check();\n\t\tthis._resback(res);\n\t},\n\n\treject: function(res){\n\t\tthis._check();\n\t\tif(!(res instanceof Error)){\n\t\t\tres = new Error(res);\n\t\t}\n\t\tthis._resback(res);\n\t},\n\n\tthen: function(cb, eb){\n\t\tthis.chain.push([cb, eb]);\n\t\tif(this.fired >= 0){\n\t\t\tthis._fire();\n\t\t}\n\t\treturn this;\n\t},\n\n\talways: function(cb){\n\t\tthis.then(cb, cb);\n\t},\n\n\totherwise: function(eb){\n\t\tthis.then(null, eb);\n\t},\n\n\tisFulfilled: function(){\n\t\treturn this.fired >= 0;\n\t},\n\n\tisResolved: function(){\n\t\treturn this.fired == 0;\n\t},\n\n\tisRejected: function(){\n\t\treturn this.fired == 1;\n\t},\n\n\t_fire: function(){\n\t\tvar chain = this.chain;\n\t\tvar fired = this.fired;\n\t\tvar res = this.results[fired];\n\t\tvar self = this;\n\t\tvar cb = null;\n\t\twhile(chain.length > 0 && this.paused == 0){\n\t\t\t// Array\n\t\t\tvar pair = chain.shift();\n\t\t\tvar f = pair[fired];\n\t\t\tif(f == null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tres = f(res);\n\t\t\t\tfired = ((res instanceof Error) ? 1 : 0);\n\t\t\t\tif(res && res.then){\n\t\t\t\t\tcb = function(res){\n\t\t\t\t\t\tself._continue(res);\n\t\t\t\t\t};\n\t\t\t\t\tthis._pause();\n\t\t\t\t}\n\t\t\t}catch(err){\n\t\t\t\tfired = 1;\n\t\t\t\tres = err;\n\t\t\t}\n\t\t}\n\t\tthis.fired = fired;\n\t\tthis.results[fired] = res;\n\t\tif((cb)&&(this.paused)){\n\t\t\tres.always(cb);\n\t\t}\n\t}\n});\n\nlang.extend(doh.Deferred, {\n\t// Back compat methods, remove for 2.0\n\n\tgetFunctionFromArgs: function(){\n\t\t// Like lang.hitch but first arg (context) is optional\n\t\tvar a = arguments;\n\t\tif((a[0])&&(!a[1])){\n\t\t\tif(typeof a[0] == \"function\"){\n\t\t\t\treturn a[0];\n\t\t\t}else if(typeof a[0] == \"string\"){\n\t\t\t\treturn doh.global[a[0]];\n\t\t\t}\n\t\t}else if((a[0])&&(a[1])){\n\t\t\treturn lang.hitch(a[0], a[1]);\n\t\t}\n\t\treturn null;\n\t},\n\n\taddCallbacks: function(cb, eb){\n\t\tthis.then(cb, eb);\n\t},\n\n\n    addCallback: function(cb, cbfn){\n\t\tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = lang.hitch(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.then(enclosed);\n\t},\n\n\taddErrback: function(cb, cbfn){\n\t\tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = lang.hitch(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.otherwise(enclosed);\n\t},\n\n\taddBoth: function(cb, cbfn){\n\t\tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = lang.hitch(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.always(enclosed);\n\t},\n\n\tcallback: function(val){\n\t\tthis.resolve(val);\n\t},\n\n\terrback: function(val){\n\t\tthis.reject(val);\n\t}\n});\n\n//\n// State Keeping and Reporting\n//\n\ndoh._testCount = 0;\ndoh._groupCount = 0;\ndoh._errorCount = 0;\ndoh._failureCount = 0;\ndoh._currentGroup = null;\ndoh._currentTest = null;\ndoh._paused = true;\n\ndoh._init = function(){\n\tthis._currentGroup = null;\n\tthis._currentTest = null;\n\tthis._errorCount = 0;\n\tthis._failureCount = 0;\n\tthis.debug(this._testCount, \"tests to run in\", this._groupCount, \"groups\");\n};\n\ndoh._groups = {};\n\n//\n// Test Types\n//\ndoh._testTypes= {};\n\ndoh.registerTestType= function(name, initProc){\n\t// summary:\n\t//\t\tAdds a test type and associates a function used to initialize each test of the given type\n\t// name: String\n\t//\t\tThe name of the type.\n\t// initProc: Function\n\t//\t\tType specific test initializer; called after the test object is created.\n\tdoh._testTypes[name]= initProc;\n};\n\ndoh.registerTestType(\"perf\", function(group, tObj, type){\n\t// Augment the test with some specific options to make it identifiable as a\n\t// particular type of test so it can be executed properly.\n\tif(type === \"perf\" || tObj.testType === \"perf\"){\n\t\ttObj.testType = \"perf\";\n\n\t\t// Build an object on the root DOH class to contain all the test results.\n\t\t// Cache it on the test object for quick lookup later for results storage.\n\t\tif(!doh.perfTestResults){\n\t\t\tdoh.perfTestResults = {};\n\t\t\tdoh.perfTestResults[group] = {};\n\t\t}\n\t\tif(!doh.perfTestResults[group]){\n\t\t\tdoh.perfTestResults[group] = {};\n\t\t}\n\t\tif(!doh.perfTestResults[group][tObj.name]){\n\t\t\tdoh.perfTestResults[group][tObj.name] = {};\n\t\t}\n\t\ttObj.results = doh.perfTestResults[group][tObj.name];\n\n\t\t// If it's not set, then set the trial duration; default to 100ms.\n\t\tif(!(\"trialDuration\" in tObj)){\n\t\t\ttObj.trialDuration = 100;\n\t\t}\n\n\t\t// If it's not set, then set the delay between trial runs to 100ms\n\t\t// default to 100ms to allow for GC and to make IE happy.\n\t\tif(!(\"trialDelay\" in tObj)){\n\t\t\ttObj.trialDelay = 100;\n\t\t}\n\n\t\t// If it's not set, then set number of times a trial is run to 10.\n\t\tif(!(\"trialIterations\" in tObj)){\n\t\t\ttObj.trialIterations = 10;\n\t\t}\n\t}\n});\n\n\n//\n// Test Registration\n//\nvar\n\tcreateFixture= function(group, test, type){\n\t\t// test is a function, string, or fixture object\n\t\tvar tObj = test;\n\t\tif(lang.isString(test)){\n\t\t\ttObj = {\n\t\t\t\tname: test.replace(\"/\\s/g\", \"_\"), // FIXME: bad escapement\n\t\t\t\trunTest: new Function(\"t\", test)\n\t\t\t};\n\t\t}else if(lang.isFunction(test)){\n\t\t\t// if we didn't get a fixture, wrap the function\n\t\t\ttObj = { \"runTest\": test };\n\t\t\tif(test[\"name\"]){\n\t\t\t\ttObj.name = test.name;\n\t\t\t}else{\n\t\t\t\ttry{\n\t\t\t\t\tvar fStr = \"function \";\n\t\t\t\t\tvar ts = tObj.runTest+\"\";\n\t\t\t\t\tif(0 <= ts.indexOf(fStr)){\n\t\t\t\t\t\ttObj.name = ts.split(fStr)[1].split(\"(\", 1)[0];\n\t\t\t\t\t}\n\t\t\t\t\t// doh.debug(tObj.runTest.toSource());\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t}\n\t\t\t// FIXME: try harder to get the test name here\n\t\t}else if(lang.isString(tObj.runTest)){\n\t\t\ttObj.runTest= new Function(\"t\", tObj.runTest);\n\t\t}\n\t\tif(!tObj.runTest){\n\t\t\treturn 0;\n\t\t}\n\n\t\t// if the test is designated as a particular type, do type-specific initialization\n\t\tvar testType= doh._testTypes[type] || doh._testTypes[tObj.testType];\n\t\tif(testType){\n\t\t\ttestType(group, tObj);\n\t\t}\n\n\t\t// add the test to this group\n\t\tdoh._groups[group].push(tObj);\n\t\tdoh._testCount++;\n\t\tdoh._testRegistered(group, tObj);\n\n\t\treturn tObj;\n\t},\n\n\tdumpArg= function(arg){\n\t\tif(lang.isString(arg)){\n\t\t\treturn \"string(\" + arg + \")\";\n\t\t} else {\n\t\t\treturn typeof arg;\n\t\t}\n\t},\n\n\tillegalRegister= function(args, testArgPosition){\n\t\tvar hint= \"\\targuments: \";\n\t\tfor(var i= 0; i<5; i++){\n\t\t\thint+= dumpArg(args[i]);\n\t\t}\n\t\tdoh.debug(\"ERROR:\");\n\t\tif(testArgPosition){\n\t\t\tdoh.debug(\"\\tillegal arguments provided to doh.register; the test at argument \" + testArgPosition + \" wasn't a test.\");\n\t\t}else{\n\t\t\tdoh.debug(\"\\tillegal arguments provided to doh.register\");\n\t\t}\n\t\tdoh.debug(hint);\n\t};\n\ndoh._testRegistered = function(group, fixture){\n\t// slot to be filled in\n};\n\ndoh._groupStarted = function(group){\n\t// slot to be filled in\n};\n\ndoh._groupFinished = function(group, success){\n\t// slot to be filled in\n};\n\ndoh._testStarted = function(group, fixture){\n\t// slot to be filled in\n};\n\ndoh._testFinished = function(group, fixture, success){\n\t// slot to be filled in\n};\n\ndoh._registerTest = function(group, test, type){\n\t// summary:\n\t//\t\tadd the provided test function or fixture object to the specified\n\t//\t\ttest group.\n\t// group: String\n\t//\t\tstring name of the group to add the test to\n\t// test: Function||String||Object\n\t//\t\tTODOC\n\t// type: String?\n\t//\t\tAn identifier denoting the type of testing that the test performs, such\n\t//\t\tas a performance test. If falsy, defaults to test.type.\n\n\t// get, possibly create, the group object\n\n\tvar groupObj = this._groups[group];\n\tif(!groupObj){\n\t\tthis._groupCount++;\n\t\tgroupObj = this._groups[group] = [];\n\t\tgroupObj.inFlight = 0;\n\t}\n\tif(!test){\n\t\treturn groupObj;\n\t}\n\n\t// create the test fixture\n\tvar tObj;\n\tif(lang.isFunction(test) || lang.isString(test) || \"runTest\" in test){\n\t\treturn createFixture(group, test, type) ? groupObj : 0;\n\t}else if(lang.isArray(test)){\n\t\t// a vector of tests...\n\t\tfor(var i=0; i<test.length; i++){\n\t\t\ttObj = createFixture(group, test[i], type);\n\t\t\tif(!tObj){\n\t\t\t\tthis.debug(\"ERROR:\");\n\t\t\t\tthis.debug(\"\\tillegal test is test array; more information follows...\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn groupObj;\n\t}else{\n\t\t// a hash of tests...\n\t\tfor(var testName in test){\n\t\t\tvar theTest = test[testName];\n\t\t\tif(lang.isFunction(theTest) || lang.isString(theTest)){\n\t\t\t\ttObj = createFixture(group, {name: testName, runTest: theTest}, type);\n\t\t\t}else{\n\t\t\t\t// should be an object\n\t\t\t\ttheTest.name = theTest.name || testName;\n\t\t\t\ttObj = createFixture(group, theTest, type);\n\t\t\t}\n\t\t\tif(!tObj){\n\t\t\t\tthis.debug(\"ERROR:\");\n\t\t\t\tthis.debug(\"\\tillegal test is test hash; more information follows...\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn groupObj;\n\t}\n};\n\ndoh._registerTestAndCheck = function(groupId, test, type, testArgPosition, args, setUp, tearDown){\n\tvar amdMid = 0;\n\tif(groupId){\n\t\tif(type){\n\t\t\t// explicitly provided type; therefore don't try to get type from groupId\n\t\t\tvar match = groupId.match(/([^\\!]+)\\!(.+)/);\n\t\t\tif(match){\n\t\t\t\tamdMid = match[1];\n\t\t\t\tgroupId = match[2];\n\t\t\t}\n\t\t}else{\n\t\t\tvar parts = groupId && groupId.split(\"!\");\n\t\t\tif(parts.length == 3){\n\t\t\t\tamdMid = parts[0];\n\t\t\t\tgroupId = parts[1];\n\t\t\t\ttype = parts[2];\n\t\t\t}else if(parts.length == 2){\n\t\t\t\t// either (amdMid, group) or (group, type)\n\t\t\t\tif(parts[1] in doh._testTypes){\n\t\t\t\t\tgroupId = parts[0];\n\t\t\t\t\ttype = parts[1];\n\t\t\t\t}else{\n\t\t\t\t\tamdMid = parts[0];\n\t\t\t\t\tgroupId = parts[1];\n\t\t\t\t}\n\t\t\t} // else, no ! and just a groupId\n\t\t}\n\t}\n\n\tvar group = doh._registerTest(groupId, test, type);\n\tif(group){\n\t\tif(amdMid){\n\t\t\tgroup.amdMid = amdMid;\n\t\t}\n\t\tif(setUp){\n\t\t\tgroup.setUp = setUp;\n\t\t}\n\t\tif(tearDown){\n\t\t\tgroup.tearDown = tearDown;\n\t\t}\n\t}else{\n\t\tillegalRegister(arguments, testArgPosition);\n\t}\n};\n\ndoh._registerUrl = function(/*String*/ group, /*String*/ url, /*Integer*/ timeout, /*String*/ type, /*object*/ dohArgs){\n\t// slot to be filled in\n\tthis.debug(\"ERROR:\");\n\tthis.debug(\"\\tNO registerUrl() METHOD AVAILABLE.\");\n};\n\nvar typeSigs = (function(){\n\t// Generate machinery to decode the many register signatures; these are the possible signatures.\n\n\tvar sigs = [\n\t\t// note: to===timeout, up===setUp, down===tearDown\n\n\t\t// 1 arg\n\t\t\"test\", function(args, a1){doh._registerTestAndCheck(\"ungrouped\", a1, 0, 0, args, 0, 0);},\n\t\t\"url\", function(args, a1){doh._registerUrl(\"ungrouped\", a1);},\n\n\t\t// 2 args\n\t\t\"group-test\", function(args, a1, a2){doh._registerTestAndCheck(a1, a2, 0, 0, args, 0, 0);},\n\t\t\"test-type\", function(args, a1, a2){doh._registerTestAndCheck(\"ungrouped\", a1, a2, 1, args, 0, 0);},\n\t\t\"test-up\", function(args, a1, a2){doh._registerTestAndCheck(\"ungrouped\", a1, 0, 0, args, a2, 0);},\n\t\t\"group-url\", function(args, a1, a2){doh._registerUrl(a1, a2);},\n\t\t\"url-to\", function(args, a1, a2){doh._registerUrl(\"ungrouped\", a1, a2);},\n\t\t\"url-type\", function(args, a1, a2){doh._registerUrl(\"ungrouped\", a1, undefined, a2);},\n\t\t\"url-args\", function(args, a1, a2){doh._registerUrl(\"ungrouped\", a1, undefined, 0, a2);},\n\n\t\t// 3 args\n\t\t\"group-test-type\", function(args, a1, a2, a3){doh._registerTestAndCheck(a1, a2, a3, 2, args, 0, 0);},\n\t\t\"group-test-up\", function(args, a1, a2, a3){doh._registerTestAndCheck(a1, a2, 0, 2, args, a3, 0);},\n\t\t\"test-type-up\", function(args, a1, a2, a3){doh._registerTestAndCheck(\"ungrouped\", a1, a2, 0, args, a3, 0);},\n\t\t\"test-up-down\", function(args, a1, a2, a3){doh._registerTestAndCheck(\"ungrouped\", a1, 0, 0, args, a2, a3);},\n\t\t\"group-url-to\", function(args, a1, a2, a3){doh._registerUrl(a1, a2, a3);},\n\t\t\"group-url-type\", function(args, a1, a2, a3){doh._registerUrl(a1, a2, undefined, a3);},\n\t\t\"group-url-args\", function(args, a1, a2, a3){doh._registerUrl(a1, a2, undefined, 0, a3);},\n\t\t\"url-to-type\", function(args, a1, a2, a3){doh._registerUrl(\"ungrouped\", a1, a2, a3);},\n\t\t\"url-to-args\", function(args, a1, a2, a3){doh._registerUrl(\"ungrouped\", a1, a2, 0, a3);},\n\t\t\"url-type-args\", function(args, a1, a2, a3){doh._registerUrl(\"ungrouped\", a1, undefined, a2, a3);},\n\n\t\t// 4 args\n\t\t\"group-test-type-up\", function(args, a1, a2, a3, a4){doh._registerTestAndCheck(a1, a2, a3, 2, args, a4, 0);},\n\t\t\"group-test-up-down\", function(args, a1, a2, a3, a4){doh._registerTestAndCheck(a1, a2, 0, 2, args, a3, a4);},\n\t\t\"test-type-up-down\", function(args, a1, a2, a3, a4){doh._registerTestAndCheck(\"ungrouped\", a1, 2, 0, args, a3, a4);},\n\t\t\"group-url-to-type\", function(args, a1, a2, a3, a4){doh._registerUrl(a1, a2, a3, a4);},\n\t\t\"group-url-to-args\", function(args, a1, a2, a3, a4){doh._registerUrl(a1, a2, a3, 0, a4);},\n\t\t\"group-url-type-args\", function(args, a1, a2, a3, a4){doh._registerUrl(a1, a2, undefined, a3, a4);},\n\t\t\"url-to-type-args\", function(args, a1, a2, a3, a4){doh._registerUrl(\"ungrouped\", a1, a2, a3, a4);},\n\n\t\t// 5 args\n\t\t\"group-test-type-up-down\", function(args, a1, a2, a3, a4, a5){doh._registerTestAndCheck(a1, a2, a3, 2, args, a4, a5);},\n\t\t\"group-url-to-type-args\", function(args, a1, a2, a3, a4, a5){doh._registerUrl(a1, a2, a3, a4, a5);}\n\t];\n\n\t// type-ids\n\t// a - array\n\t// st - string, possible type\n\t// sf - string, possible function\n\t// s - string not a type or function\n\t// o - object\n\t// f - function\n\t// n - number\n    // see getTypeId inside doh.register\n\tvar argTypes = {\n\t\tgroup:\"st.sf.s\",\n\t\ttest:\"a.sf.o.f\",\n\t\ttype:\"st\",\n\t\tup:\"f\",\n\t\tdown:\"f\",\n\t\turl:\"s\",\n\t\tto:\"n\",\n\t\targs:\"o\"\n\t};\n\tfor(var p in argTypes){\n\t\targTypes[p]= argTypes[p].split(\".\");\n\t}\n\n\tfunction generateTypeSignature(sig, pattern, dest, func){\n\t\tfor(var nextPattern, reducedSig= sig.slice(1), typeList= argTypes[sig[0]], i=0; i<typeList.length; i++){\n\t\t\tnextPattern =  pattern + (pattern ? \"-\" : \"\") + typeList[i];\n\t\t\tif(reducedSig.length){\n\t\t\t\tgenerateTypeSignature(reducedSig, nextPattern, dest, func);\n\t\t\t}else{\n\t\t\t\tdest.push(nextPattern, func);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar typeSigs = [];\n\tfor(var sig, func, dest, i = 0; i<sigs.length; i++){\n\t\tsig = sigs[i++].split(\"-\");\n\t\tfunc = sigs[i];\n\t\tdest = typeSigs[sig.length-1] || (typeSigs[sig.length-1]= []);\n\t\tgenerateTypeSignature(sig, \"\", dest, func);\n\t}\n\treturn typeSigs;\n})();\n\n\ndoh.register = function(a1, a2, a3, a4, a5){\n\t/*=====\n\tdoh.register = function(groupId, testOrTests, timeoutOrSetUp, tearDown){\n\t// summary:\n\t//\t\tAdd a test or group of tests.\n\t// description:\n\t//\t\tAdds the test or tests given by testsOrUrl to the group given by group (if any). For URL tests, unless\n\t//\t\ta group is explicitly provided the group given by the URL until the document arrives at which\n\t//\t\tpoint the group is renamed to the title of the document. For non-URL tests, if groupId is\n\t//\t\tnot provided, then tests are added to the group \"ungrouped\"; otherwise if the given groupId does not\n\t//\t\texist, it is created; otherwise, tests are added to the already-existing group.\n\t//\n\t//\t\tgroupIds may contain embedded AMD module identifiers as prefixes and/or test types as suffixes. Prefixes\n\t//\t\tand suffixes are denoted by a \"!\". For example\n\t// groupId: String?\n\t//\t\tThe name of the group, optionally with an AMD module identifier prefix and/or\n\t//\t\ttest type suffix. The value character set for group names and AMD module indentifiers\n\t//\t\tis given by [A-Za-z0-9_/.-]. If provided, prefix and suffix are denoted by \"!\". If\n\t//\t\tprovided, type must be a valid test type.\n\t// testOrTests: Array||Function||Object||String||falsy\n\t//\t\tWhen a function, implies a function that defines a single test. DOH passes the\n\t//\t\tDOH object to the function as the sole argument when the test is executed. When\n\t//\t\ta string, implies the definition of a single test given by `new Function(\"t\", testOrTests)`.\n\t//\t\tWhen an object that contains the method `runTest` (which *must* be a function),\n\t//\t\timplies a single test given by the value of the property `runTest`. In this case,\n\t//\t\tthe object may also contain the methods `setup` and `tearDown`, and, if provided, these\n\t//\t\twill be invoked on either side of the test function. Otherwise when an object (that is,\n\t//\t\tan object that does not contain the method `runTest`), then a hash from test name to\n\t//\t\ttest function (either a function or string as described above); any names that begin\n\t//\t\twith \"_\" are ignored. When an array, the array must exclusively contain functions,\n\t//\t\tstrings, and/or objects as described above and each item is added to the group as\n\t//\t\tper the items semantics.\n\t// timeoutOrSetUp: integer||Function?\n\t//\t\tIf tests is a URL, then must be an integer giving the number milliseconds to wait for the test\n\t//\t\tpage to load before signaling an error; otherwise, a function for initializing the test group.\n\t//\t\tIf a tearDown function is given, then a setup function must also be given.\n\t// tearDown: Function?\n\t//\t\tA function for deinitializing the test group.\n\t// example:\n\t// | `\"myTest/MyGroup\"`\t\t\t\t\t\t\t// just a group, group ids need not include a slash\n\t// | `\"myTest/MyGroup!perf\"`\t\t\t\t\t// group with test type\n\t// | `\"path/to/amd/module!myTest/MyGroup\"`\t\t// group with AMD module identifier\n\t// | `\"path/to/amd/module!myTest/MyGroup!perf\"`\t// group with both AMD module identifier and test type\n\t//\n\t//\t\tGroups associated with AMD module identifiers may be unloaded/reloaded if using an AMD loader with\n\t//\t\treload support (dojo's AMD loader includes such support). If no AMD module identifier is given,\n\t//\t\tthe loader supports reloading, and the user demands a reload, then the groupId will be used\n\t//\t\tas the AMD module identifier.\n\t//\n\t//\t\tFor URL tests, the groupId is changed to the document title (if any) upon document arrival. The\n\t//\t\ttitle may include a test type suffix denoted with a \"!\" as described above.\n\t//\n\t//\t\tFor URL tests, if timeout is a number, then sets the timeout for loading\n\t//\t\tthe particular URL; otherwise, timeout is set to DOH.iframeTimeout.\n\t//\n\t//\t\tFor non-URL tests, if setUp and/or tearDown are provided, then any previous setUp and/or\n\t//\t\ttearDown functions for the group are replaced as given. You may affect just setUp and/or tearDown\n\t//\t\tfor a group and not provide/add any tests by providing falsy for the test argument.\n\t// example:\n\t// | var\n\t// |\tt1= function(t) {\n\t// |\t\t// this is a test\n\t// |\t\t// t will be set to DOH when the test is executed by DOH\n\t// |\t\t// etc.\n\t// |\t},\n\t// |\n\t// |\tt2= {\n\t// |\t\t// this is a test fixture and may be passed as a test\n\t// |\n\t// |\t\t// runTest is always required...\n\t// |\t\trunTest: function(t){\n\t// |\t\t\t// the test...\n\t// |\t\t},\n\t// |\n\t// |\t\t// name is optional, but recommended...\n\t// |\t\tname:\"myTest\",\n\t// |\n\t// |\t\t// preamble is optional...\n\t// |\t\tsetUp: function(){\n\t// |\t\t\t// will be executed by DOH prior to executing the test\n\t// |\t\t},\n\t// |\n\t// |\t\t// postscript is optional...\n\t// |\t\ttearDown: function(){ // op\n\t// |\t\t\t// will be executed by DOH after executing the test\n\t// |\t\t}\n\t// |\t}\n\t// |\n\t// |\tt3= [\n\t// |\t\t// this is a vector of tests...\n\t// |\t\tt1, t2\n\t// |\t],\n\t// |\n\t// |\tt4= {\n\t// |\t\t// this is a map from test name to test or test fixture\n\t// |\t\tt5: function(t){\n\t// |\t\t\t// etc.\n\t// |\t\t},\n\t// |\n\t// |\t\tt6: {\n\t// |\t\t\trunTest: function(t){\n\t// |\t\t\t// etc.\n\t// |\t\t\t}\n\t// |\t\t\t// name will be automatically added as \"t6\"\n\t// |\t\t}\n\t// |\t},\n\t// |\n\t// |\taSetup: function(){\n\t// |\t\t// etc.\n\t// |\t},\n\t// |\n\t// |\taTearDown: function(){\n\t// |\t\t// etc.\n\t// |\t};\n\t// | // (test); note, can't provide setup/tearDown without a group\n\t// | doh.register(t1);\n\t// |\n\t// | // (group, test, setUp, tearDown) test and/or setUp and/or tearDown can be missing\n\t// | doh.register(\"myGroup\", 0, aSetUp, aTearDown);\n\t// | doh.register(\"myGroup\", t1, aSetUp, aTearDown);\n\t// | doh.register(\"myGroup\", t1, aSetUp);\n\t// | doh.register(\"myGroup\", t1, 0, aTearDown);\n\t// | doh.register(\"myGroup\", t1);\n\t// |\n\t// | // various kinds of test arguments are allowed\n\t// | doh.register(\"myGroup\", t2);\n\t// | doh.register(\"myGroup\", t3);\n\t// | doh.register(\"myGroup\", t4);\n\t// |\n\t// | // add a perf test\n\t// | doh.register(\"myGroup!perf\", t1);\n\t// |\n\t// | // add a perf test with an AMD module identifier\n\t// | doh.register(\"path/to/my/module!myGroup!perf\", t1);\n\t//\n\t//\tdoh.register also supports Dojo, v1.6- signature (group, test, type), although this signature is deprecated.\n\t};\n\t=====*/\n\n\tfunction getTypeId(a){\n\t\tif(a instanceof Array){\n\t\t\treturn \"a\";\n\t\t}else if(typeof a == \"function\"){\n\t\t\treturn \"f\";\n\t\t}else if(typeof a == \"number\"){\n\t\t\treturn \"n\";\n\t\t}else if(typeof a == \"string\"){\n\t\t\tif(a in doh._testTypes){\n\t\t\t\treturn \"st\";\n\t\t\t}else if(/\\(/.test(a)){\n\t\t\t\treturn \"sf\";\n\t\t\t}else{\n\t\t\t\treturn \"s\";\n\t\t\t}\n\t\t}else{\n\t\t\treturn \"o\";\n\t\t}\n\t}\n\n\tvar\n\t\tarity = arguments.length,\n\t\tsearch = typeSigs[arity-1],\n\t\tsig = [],\n\t\ti;\n\tfor(i =0; i<arity; i++){\n\t\tsig.push(getTypeId(arguments[i]));\n\t}\n\tsig = sig.join(\"-\");\n\tfor(i=0; i<search.length; i+= 2){\n\t\tif(search[i]==sig){\n\t\t\tsearch[i+1](arguments, a1, a2, a3, a4, a5);\n\t\t\treturn;\n\t\t}\n\t}\n\tillegalRegister(arguments);\n};\n\ndoh.registerDocTests = function(module){\n\t// summary:\n\t//\t\tDeprecated.    Won't work unless you manually load dojox.testing.DocTest, and likely not even then.\n\t//\t\tGets all the doctests from the given module and register each of them as a single test case here.\n\n\tvar docTest = new dojox.testing.DocTest();\n\tvar docTests = docTest.getTests(module);\n\tvar len = docTests.length;\n\tvar tests = [];\n\tfor (var i=0; i<len; i++){\n\t\tvar test = docTests[i];\n\t\t// Extract comment on first line and add to test name.\n\t\tvar comment = \"\";\n\t\tif (test.commands.length && test.commands[0].indexOf(\"//\")!=-1) {\n\t\t\tvar parts = test.commands[0].split(\"//\");\n\t\t\tcomment = \", \"+parts[parts.length-1]; // Get all after the last //, so we don't get trapped by http:// or alikes :-).\n\t\t}\n\t\ttests.push({\n\t\t\trunTest: (function(test){\n\t\t\t\treturn function(t){\n\t\t\t\t\tvar r = docTest.runTest(test.commands, test.expectedResult);\n\t\t\t\t\tt.assertTrue(r.success);\n\t\t\t\t};\n\t\t\t})(test),\n\t\t\tname:\"Line \"+test.line+comment\n\t\t}\n\t\t);\n\t}\n\tthis.register(\"DocTests: \"+module, tests);\n};\n\n//\n// deprecated v1.6- register API follows\n//\n\ndoh.registerTest = function(/*String*/ group, /*Array||Function||Object*/ test, /*String*/ type){\n\t// summary:\n\t//\t\tDeprecated.  Use doh.register(group/type, test) instead\n\tdoh.register(group + (type ? \"!\" + type : \"\"), test);\n};\n\ndoh.registerGroup = function(/*String*/ group, /*Array||Function||Object*/ tests, /*Function*/ setUp, /*Function*/ tearDown, /*String*/ type){\n\t// summary:\n\t//\t\tDeprecated.  Use doh.register(group/type, tests, setUp, tearDown) instead\n\tvar args = [(group ? group : \"\") + (type ? \"!\" + type : \"\"), tests];\n\tsetUp && args.push(setUp);\n\ttearDown && args.push(tearDown);\n\tdoh.register.apply(doh, args);\n};\n\ndoh.registerTestNs = function(/*String*/ group, /*Object*/ ns){\n\t// summary:\n\t//\t\tDeprecated.  Use doh.register(group, ns) instead\n\tdoh.register(group, ns);\n};\n\ndoh.registerTests = function(/*String*/ group, /*Array*/ testArr, /*String*/ type){\n\t// summary:\n\t//\t\tDeprecated.  Use doh.register(group/type, testArr) instead\n\tdoh.register(group + (type ? \"!\" + type : \"\"), testArr);\n};\n\ndoh.registerUrl = function(/*String*/ group, /*String*/ url, /*Integer*/ timeout, /*String*/ type, /*Object*/ args){\n\t// summary:\n\t//\t\tDeprecated.  Use doh.register(group/type, url, timeout) instead\n\tdoh.register(group + (type ? \"!\" + type : \"\"), url+\"\", timeout || 10000, args || {});\n};\n\n//\n// Assertions and In-Test Utilities\n//\ndoh.t = doh.assertTrue = function(/*Object*/ condition, /*String?*/ hint){\n\t// summary:\n\t//\t\tis the passed item \"truthy\"?\n\tif(arguments.length < 1){\n\t\tthrow new doh._AssertFailure(\"assertTrue failed because it was not passed at least 1 argument\");\n\t}\n\t//if(lang.isString(condition) && condition.length){\n\t//\treturn true;\n\t//}\n\tif(!eval(condition)){\n\t\tthrow new doh._AssertFailure(\"assertTrue('\" + condition + \"') failed\", hint);\n\t}\n};\n\ndoh.f = doh.assertFalse = function(/*Object*/ condition, /*String?*/ hint){\n\t// summary:\n\t//\t\tis the passed item \"falsey\"?\n\tif(arguments.length < 1){\n\t\tthrow new doh._AssertFailure(\"assertFalse failed because it was not passed at least 1 argument\");\n\t}\n\tif(eval(condition)){\n\t\tthrow new doh._AssertFailure(\"assertFalse('\" + condition + \"') failed\", hint);\n\t}\n};\n\ndoh.e = doh.assertError = function(/*Error object*/expectedError, /*Object*/scope, /*String*/functionName, /*Array*/args, /*String?*/ hint){\n\t// summary:\n\t//\t\tTest for a certain error to be thrown by the given function.\n\t// example:\n\t//\t\tt.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, \"getValue\", [item, \"NOT THERE\"]);\n\t//\t\tt.assertError(dojox.data.QueryReadStore.InvalidItemError, store, \"getValue\", [\"not an item\", \"NOT THERE\"]);\n\ttry{\n\t\tscope[functionName].apply(scope, args);\n\t}catch (e){\n\t\tif(e instanceof expectedError){\n\n\t\t\treturn true;\n\t\t}else{\n\t\t\tthrow new doh._AssertFailure(\"assertError() failed:\\n\\texpected error\\n\\t\\t\"+expectedError+\"\\n\\tbut got\\n\\t\\t\"+e+\"\\n\\n\", hint);\n\t\t}\n\t}\n\tthrow new doh._AssertFailure(\"assertError() failed:\\n\\texpected error\\n\\t\\t\"+expectedError+\"\\n\\tbut no error caught\\n\\n\", hint);\n};\n\ndoh.is = doh.assertEqual = function(/*Object*/ expected, /*Object*/ actual, /*String?*/ hint, doNotThrow){\n\t// summary:\n\t//\t\tare the passed expected and actual objects/values deeply\n\t//\t\tequivalent?\n\n\t// Compare undefined always with three equal signs, because undefined==null\n\t// is true, but undefined===null is false.\n\tif((expected === undefined)&&(actual === undefined)){\n\t\treturn true;\n\t}\n\tif(arguments.length < 2){\n\t\tthrow doh._AssertFailure(\"assertEqual failed because it was not passed 2 arguments\");\n\t}\n\tif((expected === actual)||(expected == actual)||\n\t\t\t\t( typeof expected == \"number\" && typeof actual == \"number\" && isNaN(expected) && isNaN(actual) )){\n\n\t\treturn true;\n\t}\n\tif( (lang.isArray(expected) && lang.isArray(actual))&&\n\t\t(this._arrayEq(expected, actual)) ){\n\t\treturn true;\n\t}\n\tif( ((typeof expected == \"object\")&&((typeof actual == \"object\")))&&\n\t\t(this._objPropEq(expected, actual)) ){\n\t\treturn true;\n\t}\n\tif (doNotThrow) {\n\t\treturn false;\n\t}\n\tthrow new doh._AssertFailure(\"assertEqual() failed:\\n\\texpected\\n\\t\\t\"+expected+\"\\n\\tbut got\\n\\t\\t\"+actual+\"\\n\\n\", hint);\n};\n\ndoh.isNot = doh.assertNotEqual = function(/*Object*/ notExpected, /*Object*/ actual, /*String?*/ hint){\n\t// summary:\n\t//\t\tare the passed notexpected and actual objects/values deeply\n\t//\t\tnot equivalent?\n\n\t// Compare undefined always with three equal signs, because undefined==null\n\t// is true, but undefined===null is false.\n\tif((notExpected === undefined)&&(actual === undefined)){\n\t\t\t\tthrow new doh._AssertFailure(\"assertNotEqual() failed: not expected |\"+notExpected+\"| but got |\"+actual+\"|\", hint);\n\t}\n\tif(arguments.length < 2){\n\t\tthrow doh._AssertFailure(\"assertEqual failed because it was not passed 2 arguments\");\n\t}\n\tif((notExpected === actual)||(notExpected == actual)){\n\t\t\t\tthrow new doh._AssertFailure(\"assertNotEqual() failed: not expected |\"+notExpected+\"| but got |\"+actual+\"|\", hint);\n\t}\n\tif( (lang.isArray(notExpected) && lang.isArray(actual))&&\n\t\t(this._arrayEq(notExpected, actual)) ){\n\t\tthrow new doh._AssertFailure(\"assertNotEqual() failed: not expected |\"+notExpected+\"| but got |\"+actual+\"|\", hint);\n\t}\n\tif( ((typeof notExpected == \"object\")&&((typeof actual == \"object\"))) ){\n\t\tvar isequal = false;\n\t\ttry{\n\t\t\tisequal = this._objPropEq(notExpected, actual);\n\t\t}catch(e){\n\t\t\tif(!(e instanceof doh._AssertFailure)){\n\t\t\t\tthrow e; // other exceptions, just throw it\n\t\t\t}\n\t\t}\n\t\tif(isequal){\n\t\t\t\tthrow new doh._AssertFailure(\"assertNotEqual() failed: not expected |\"+notExpected+\"| but got |\"+actual+\"|\", hint);\n\t\t}\n\t}\n\treturn true;\n};\n\ndoh._arrayEq = function(expected, actual){\n\tif(expected.length != actual.length){ return false; }\n\t// FIXME: we're not handling circular refs. Do we care?\n\tfor(var x=0; x<expected.length; x++){\n\t\tif(!doh.assertEqual(expected[x], actual[x], 0, true)){ return false; }\n\t}\n\treturn true;\n};\n\ndoh._objPropEq = function(expected, actual){\n\t// Degenerate case: if they are both null, then their \"properties\" are equal.\n\tif(expected === null && actual === null){\n\t\treturn true;\n\t}\n\t// If only one is null, they aren't equal.\n\tif(expected === null || actual === null){\n\t\treturn false;\n\t}\n\tif(expected instanceof Date){\n\t\treturn actual instanceof Date && expected.getTime()==actual.getTime();\n\t}\n\tvar x;\n\t// Make sure ALL THE SAME properties are in both objects!\n\tfor(x in actual){ // Lets check \"actual\" here, expected is checked below.\n\t\tif(!(x in expected)){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor(x in expected){\n\t\tif(!(x in actual)){\n\t\t\treturn false;\n\t\t}\n\t\tif(!doh.assertEqual(expected[x], actual[x], 0, true)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\n//\n// Runner-Wrapper\n//\n\ndoh._setupGroupForRun = function(/*String*/ groupName){\n\tvar tg = this._groups[groupName];\n\tthis.debug(this._line);\n\tthis.debug(\"GROUP\", \"\\\"\"+groupName+\"\\\"\", \"has\", tg.length, \"test\"+((tg.length > 1) ? \"s\" : \"\")+\" to run\");\n\tdoh._groupStarted(groupName);\n};\n\ndoh._handleFailure = function(groupName, fixture, e){\n\t// this.debug(\"FAILED test:\", fixture.name);\n\t// mostly borrowed from JUM\n\tthis._groups[groupName].failures++;\n\tvar out = \"\";\n\tif(e instanceof this._AssertFailure){\n\t\tthis._failureCount++;\n\t\tif(e[\"fileName\"]){ out += e.fileName + ':'; }\n\t\tif(e[\"lineNumber\"]){ out += e.lineNumber + ' '; }\n\t\tout += e.message;\n\t\tthis.error(\"\\t_AssertFailure:\", out);\n\t}else{\n\t\tthis._errorCount++;\n\t\tthis.error(\"\\tError:\", e.message || e); // printing Error on IE9 (and other browsers?) yields \"[Object Error]\"\n\t}\n\tif(fixture.runTest[\"toSource\"]){\n\t\tvar ss = fixture.runTest.toSource();\n\t\tthis.debug(\"\\tERROR IN:\\n\\t\\t\", ss);\n\t}else{\n\t\tthis.debug(\"\\tERROR IN:\\n\\t\\t\", fixture.runTest);\n\t}\n\tif(e.rhinoException){\n\t\te.rhinoException.printStackTrace();\n\t}else if(e.javaException){\n\t\te.javaException.printStackTrace();\n\t}\n};\n\ndoh._runPerfFixture = function(/*String*/ groupName, /*Object*/ fixture){\n\t// summary:\n\t//\t\tThis function handles how to execute a 'performance' test\n\t//\t\twhich is different from a straight UT style test.  These\n\t//\t\twill often do numerous iterations of the same operation and\n\t//\t\tgather execution statistics about it, like max, min, average,\n\t//\t\tetc.\tIt makes use of the already in place DOH deferred test\n\t//\t\thandling since it is a good idea to put a pause in between each\n\t//\t\titeration to allow for GC cleanup and the like.\n\t// groupName:\n\t//\t\tThe test group that contains this performance test.\n\t// fixture:\n\t//\t\tThe performance test fixture.\n\tvar tg = this._groups[groupName];\n\tfixture.startTime = new Date();\n\n\t// Perf tests always need to act in an async manner as there is a\n\t// number of iterations to flow through.\n\tvar def = new doh.Deferred();\n\ttg.inFlight++;\n\tdef.groupName = groupName;\n\tdef.fixture = fixture;\n\n\tvar threw = false;\n\tdef.otherwise(function(err){\n\t\tdoh._handleFailure(groupName, fixture, err);\n\t\tthrew = true;\n\t});\n\n\t// Set up the finalizer.\n\tvar fulfilled;\n\tvar retEnd = function(){\n\t\tfulfilled = true;\n\t\tif(fixture[\"tearDown\"]){ fixture.tearDown(doh); }\n\t\ttg.inFlight--;\n\t\tif((!tg.inFlight)&&(tg.iterated)){\n\t\t\tdoh._groupFinished(groupName, !tg.failures);\n\t\t}\n\t\tdoh._testFinished(groupName, fixture, !threw);\n\t\tif(doh._paused){\n\t\t\tdoh.run();\n\t\t}\n\t};\n\n\t// Since these can take who knows how long, we don't want to timeout\n\t// unless explicitly set\n\tvar timer;\n\tvar to = fixture.timeout;\n\tif(to > 0) {\n\t\ttimer = setTimeout(function(){\n\t\t\tdef.reject(new Error(\"test timeout in \"+fixture.name.toString()));\n\t\t}, to);\n\t}\n\n\t// Set up the end calls to the test into the deferred we'll return.\n\tdef.always(function(){\n\t\tif(timer){\n\t\t\tclearTimeout(timer);\n\t\t}\n\t\tretEnd();\n\t});\n\n\t// Okay, now set up the timing loop for the actual test.\n\t// This is down as an async type test where there is a delay\n\t// between each execution to allow for GC time, etc, so the GC\n\t// has less impact on the tests.\n\tvar res = fixture.results;\n\tres.trials = [];\n\n\t// Try to figure out how many calls are needed to hit a particular threshold.\n\tvar itrDef = doh._calcTrialIterations(groupName, fixture);\n\n\t// Blah, since tests can be deferred, the actual run has to be deferred until after\n\t// we know how many iterations to run.  This is just plain ugly.\n\titrDef.then(\n\t\tfunction(iterations){\n\t\t\tif(iterations){\n\t\t\t\tvar countdown = fixture.trialIterations;\n\t\t\t\tdoh.debug(\"TIMING TEST: [\" + fixture.name +\n\t\t\t\t\t\t\t\"]\\n\\t\\tITERATIONS PER TRIAL: \" +\n\t\t\t\t\t\t\titerations + \"\\n\\tTRIALS: \" +\n\t\t\t\t\t\t\tcountdown);\n\n\t\t\t\t// Figure out how many times we want to run our 'trial'.\n\t\t\t\t// Where each trial consists of 'iterations' of the test.\n\n\t\t\t\tvar trialRunner = function() {\n\t\t\t\t\t// Set up our function to execute a block of tests\n\t\t\t\t\tvar start = new Date();\n\t\t\t\t\tvar tTimer = new doh.Deferred();\n\n\t\t\t\t\tvar tState = {\n\t\t\t\t\t\tcountdown: iterations\n\t\t\t\t\t};\n\t\t\t\t\tvar testRunner = function(state){\n\t\t\t\t\t\twhile(state){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tstate.countdown--;\n\t\t\t\t\t\t\t\tif(state.countdown){\n\t\t\t\t\t\t\t\t\tvar ret = fixture.runTest(doh);\n\t\t\t\t\t\t\t\t\tif(ret && ret.then){\n\t\t\t\t\t\t\t\t\t\t// Deferreds have to be handled async,\n\t\t\t\t\t\t\t\t\t\t// otherwise we just keep looping.\n\t\t\t\t\t\t\t\t\t\tvar atState = {\n\t\t\t\t\t\t\t\t\t\t\tcountdown: state.countdown\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tret.then(\n\t\t\t\t\t\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\t\t\t\t\t\ttestRunner(atState)\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfunction(err){\n\t\t\t\t\t\t\t\t\t\t\t\tdoh._handleFailure(groupName, fixture, err);\n\t\t\t\t\t\t\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\t\t\t\t\t\t\tdef.reject(err);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tstate = null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\ttTimer.resolve(new Date());\n\t\t\t\t\t\t\t\t\tstate = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}catch(err){\n\t\t\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\t\t\ttTimer.reject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\ttTimer.then(\n\t\t\t\t\t\tfunction(end){\n\t\t\t\t\t\t\t// Figure out the results and try to factor out function call costs.\n\t\t\t\t\t\t\tvar tResults = {\n\t\t\t\t\t\t\t\ttrial: (fixture.trialIterations - countdown),\n\t\t\t\t\t\t\t\ttestIterations: iterations,\n\t\t\t\t\t\t\t\texecutionTime: (end.getTime() - start.getTime()),\n\t\t\t\t\t\t\t\taverage: (end.getTime() - start.getTime())/iterations\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tres.trials.push(tResults);\n\t\t\t\t\t\t\tdoh.debug(\"\\n\\t\\tTRIAL #: \" +\n\t\t\t\t\t\t\t\t\t\ttResults.trial + \"\\n\\tTIME: \" +\n\t\t\t\t\t\t\t\t\t\ttResults.executionTime + \"ms.\\n\\tAVG TEST TIME: \" +\n\t\t\t\t\t\t\t\t\t\t(tResults.executionTime/tResults.testIterations) + \"ms.\");\n\n\t\t\t\t\t\t\t// Okay, have we run all the trials yet?\n\t\t\t\t\t\t\tcountdown--;\n\t\t\t\t\t\t\tif(countdown){\n\t\t\t\t\t\t\t\tsetTimeout(trialRunner, fixture.trialDelay);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// Okay, we're done, let's compute some final performance results.\n\t\t\t\t\t\t\t\tvar t = res.trials;\n\n\t\t\t\t\t\t\t\t// We're done.\n\t\t\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\t\t\tdef.resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Handler if tTimer gets an error\n\t\t\t\t\t\tfunction(err){\n\t\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\t\tdef.reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\ttestRunner(tState);\n\t\t\t\t};\n\t\t\t\ttrialRunner();\n\t\t\t}\n\t\t},\n\n\t\t// Handler if itrDef gets an error\n\t\tfunction(err){\n\t\t\tfixture.endTime = new Date();\n\t\t\tdef.reject(err);\n\t\t}\n\t);\n\n\t// Set for a pause, returned the deferred.\n\tif(!fulfilled){\n\t\tdoh.pause();\n\t}\n\treturn def;\n};\n\ndoh._calcTrialIterations =\tfunction(/*String*/ groupName, /*Object*/ fixture){\n\t// summary:\n\t//\t\tThis function determines the rough number of iterations to\n\t//\t\tuse to reach a particular MS threshold.  This returns a deferred\n\t//\t\tsince tests can theoretically by async.  Async tests aren't going to\n\t//\t\tgive great perf #s, though.\n\t//\t\tThe callback is passed the # of iterations to hit the requested\n\t//\t\tthreshold.\n\t// fixture:\n\t//\t\tThe test fixture we want to calculate iterations for.\n\tvar def = new doh.Deferred();\n\tvar calibrate = function () {\n\t\tvar testFunc = lang.hitch(fixture, fixture.runTest);\n\n\t\t// Set the initial state.\tWe have to do this as a loop instead\n\t\t// of a recursive function.\tOtherwise, it blows the call stack\n\t\t// on some browsers.\n\t\tvar iState = {\n\t\t\tstart: new Date(),\n\t\t\tcurIter: 0,\n\t\t\titerations: 5\n\t\t};\n\t\tvar handleIteration = function(state){\n\t\t\twhile(state){\n\t\t\t\tif(state.curIter < state.iterations){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar ret = testFunc(doh);\n\t\t\t\t\t\tif(ret && ret.then){\n\t\t\t\t\t\t\tvar aState = {\n\t\t\t\t\t\t\t\tstart: state.start,\n\t\t\t\t\t\t\t\tcurIter: state.curIter + 1,\n\t\t\t\t\t\t\t\titerations: state.iterations\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tret.then(\n\t\t\t\t\t\t\t\tfunction(){\n\t\t\t\t\t\t\t\t\thandleIteration(aState);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfunction(err) {\n\t\t\t\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\t\t\t\tdef.reject(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tstate = null;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstate.curIter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(err){\n\t\t\t\t\t\tfixture.endTime = new Date();\n\t\t\t\t\t\tdef.reject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar end = new Date();\n\t\t\t\t\tvar totalTime = (end.getTime() - state.start.getTime());\n\t\t\t\t\tif(totalTime < fixture.trialDuration){\n\t\t\t\t\t\tvar nState = {\n\t\t\t\t\t\t\titerations: state.iterations * 2,\n\t\t\t\t\t\t\tcurIter: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tstate = null;\n\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tnState.start = new Date();\n\t\t\t\t\t\t\thandleIteration(nState);\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar itrs = state.iterations;\n\t\t\t\t\t\tsetTimeout(function(){def.resolve(itrs)}, 50);\n\t\t\t\t\t\tstate = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thandleIteration(iState);\n\t};\n\tsetTimeout(calibrate, 10);\n\treturn def;\n};\n\ndoh._runRegFixture = function(/*String*/ groupName, /*Object*/ fixture){\n\t// summary:\n\t//\t\tFunction to help run a generic doh test.  Called from _runFixture().  These are not\n\t//\t\tspecialized tests, like performance groups and such.\n\t// groupName:\n\t//\t\tThe groupName of the test.\n\t// fixture:\n\t//\t\tThe test fixture to execute.\n\n\tvar tg = this._groups[groupName];\n\n\tfixture.startTime = new Date();\n\n\tvar ret = fixture.runTest(this);\n\n\t// if we get a deferred back from the test runner, we know we're\n\t// gonna wait for an async result. It's up to the test code to trap\n\t// errors and give us an errback or callback.\n\tif(ret && ret.then){\n\n\t\t// If ret is a dojo/Deferred, get the corresponding Promise; it has some additional methods we need.\n\t\tif(ret.promise){\n\t\t\tret = ret.promise;\n\t\t}\n\n\t\ttg.inFlight++;\n\t\tret.groupName = groupName;\n\t\tret.fixture = fixture;\n\n\t\t// Setup handler for when test fails.\n\t\tvar threw = false;\n\t\tret.otherwise(function(err){\n\t\t\tif(threw){\n\t\t\t\t// the fixture timeout (below) must have already fired\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdoh._handleFailure(groupName, fixture, err);\n\t\t\tthrew = true;\n\t\t});\n\n\t\tvar fulfilled;\n\t\tvar retEnd = function(){\n\t\t\t// summary:\n\t\t\t//\t\tCalled when tests finishes successfully, fails, or times out\n\n\t\t\tif(fulfilled){\n\t\t\t\t// retEnd() has already executed; probably the timeout above fired and then later ret completed.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfulfilled = true;\n\n\t\t\tfixture.endTime = new Date();\n\n\t\t\tif(fixture.tearDown){\n\t\t\t\ttry {\n\t\t\t\t\tfixture.tearDown(doh);\n\t\t\t\t}catch(e){\n\t\t\t\t\tthis.debug(\"Error tearing down test: \"+e.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttg.inFlight--;\n\t\t\tdoh._testFinished(groupName, fixture, !threw);\n\n\t\t\tif((!tg.inFlight)&&(tg.iterated)){\n\t\t\t\tdoh._groupFinished(groupName, !tg.failures);\n\t\t\t}\n\n\t\t\t// Go on to next test\n\t\t\tif(doh._paused){\n\t\t\t\tdoh.run();\n\t\t\t}\n\t\t};\n\n\t\tvar timer = setTimeout(function(){\n\t\t\tif(!timer){\n\t\t\t\t// we already called clearTimeout(), but it fired anyway, due to IE bug; just ignore.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Note: cannot call ret.reject() because ret may be a readonly promise\n\t\t\tdoh._handleFailure(groupName, fixture, new Error(\"test timeout in \" + fixture.name.toString()));\n\t\t\tthrew = true;\n\t\t\tretEnd();\n\t\t}, fixture[\"timeout\"]||100000);\n\n\t\tret.always(function(){\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t\tretEnd();\n\t\t});\n\n\t\tif(!fulfilled){\n\t\t\tdoh.pause();\n\t\t}\n\n\t\treturn ret;\n\t}else{\n\t\t// Synchronous test; tearDown etc. handled in _runFixture(), the function that called me\n\t}\n};\n\ndoh._runFixture = function(groupName, fixture){\n\tvar tg = this._groups[groupName];\n\tthis._testStarted(groupName, fixture);\n\tvar threw = false;\n\tvar err = null;\n\t// run it, catching exceptions and reporting them\n\ttry{\n\t\t// let doh reference \"this.group.thinger...\" which can be set by\n\t\t// another test or group-level setUp function\n\t\tfixture.group = tg;\n\t\t// only execute the parts of the fixture we've got\n\n\t\tif(fixture[\"setUp\"]){ fixture.setUp(this); }\n\t\tif(fixture[\"runTest\"]){\t\t// should we error out of a fixture doesn't have a runTest?\n\t\t\tif(fixture.testType === \"perf\"){\n\t\t\t\t// Always async deferred, so return it.\n\t\t\t\treturn doh._runPerfFixture(groupName, fixture);\n\t\t\t}else{\n\t\t\t\t// May or may not by async.\n\t\t\t\tvar ret = doh._runRegFixture(groupName, fixture);\n\t\t\t\tif(ret){\n\t\t\t\t\t// this design is ridiculous, but tearDown etc. is handled in _runRegFixture iff fixture is async;\n\t\t\t\t\t// likewise with runPerfFixture\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}catch(e){\n\t\tthrew = true;\n\t\terr = e;\n\t}\n\n\t// The rest of the code in this function executes only if test returns synchronously...\n\n\tfixture.endTime = new Date();\n\n\t// should try to tear down regardless whether test passed or failed...\n\ttry{\n\t\tif(fixture[\"tearDown\"]){ fixture.tearDown(this); }\n\t}catch(e){\n\t\tthis.debug(\"Error tearing down test: \"+e.message);\n\t}\n\n\tvar d = new doh.Deferred();\n\tsetTimeout(lang.hitch(this, function(){\n\t\tif(threw){\n\t\t\tthis._handleFailure(groupName, fixture, err);\n\t\t}\n\t\tthis._testFinished(groupName, fixture, !threw);\n\n\t\tif((!tg.inFlight)&&(tg.iterated)){\n\t\t\tdoh._groupFinished(groupName, !tg.failures);\n\t\t}else if(tg.inFlight > 0){\n\t\t\tsetTimeout(lang.hitch(this, function(){\n\t\t\t\tdoh.runGroup(groupName);\n\t\t\t}), 100);\n\t\t\tthis._paused = true;\n\t\t}\n\t\tif(doh._paused){\n\t\t\tdoh.run();\n\t\t}\n\t}), 30);\n\tdoh.pause();\n\treturn d;\n};\n\ndoh.runGroup = function(/*String*/ groupName, /*Integer*/ idx){\n\t// summary:\n\t//\t\truns the specified test group\n\n\t// the general structure of the algorithm is to run through the group's\n\t// list of doh, checking before and after each of them to see if we're in\n\t// a paused state. This can be caused by the test returning a deferred or\n\t// the user hitting the pause button. In either case, we want to halt\n\t// execution of the test until something external to us restarts it. This\n\t// means we need to pickle off enough state to pick up where we left off.\n\n\t// FIXME: need to make fixture execution async!!\n\n\tidx = idx || 0;\n\tvar tg = this._groups[groupName];\n\tif(tg.skip === true){ return; }\n\tif(lang.isArray(tg)){\n\t\tif(tg.iterated===undefined){\n\t\t\ttg.iterated = false;\n\t\t\ttg.inFlight = 0;\n\t\t\ttg.failures = 0;\n\t\t\tthis._setupGroupForRun(groupName);\n\t\t\tif(tg[\"setUp\"]){ tg.setUp(this); }\n\t\t}\n\t\tfor(var y=idx; y<tg.length; y++){\n\t\t\tif(this._paused){\n\t\t\t\tthis._currentTest = y;\n\t\t\t\t// this.debug(\"PAUSED at:\", tg[y].name, this._currentGroup, this._currentTest);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdoh._runFixture(groupName, tg[y]);\n\t\t\tif(this._paused){\n\t\t\t\tthis._currentTest = y+1;\n\t\t\t\tif(this._currentTest == tg.length){ // RCG--don't think we need this; the next time through it will be taken care of\n\t\t\t\t\ttg.iterated = true;\n\t\t\t\t}\n\t\t\t\t// this.debug(\"PAUSED at:\", tg[y].name, this._currentGroup, this._currentTest);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttg.iterated = true;\n\t\tif(!tg.inFlight){\n\t\t\tif(tg[\"tearDown\"]){ tg.tearDown(this); }\n\t\t\tdoh._groupFinished(groupName, !tg.failures);\n\t\t}\n\t}\n};\n\ndoh._onEnd = function(){};\n\ndoh._report = function(){\n\t// summary:\n\t//\t\ta private method to be implemented/replaced by the \"locally\n\t//\t\tappropriate\" test runner\n\n\t// this.debug(\"ERROR:\");\n\t// this.debug(\"\\tNO REPORTING OUTPUT AVAILABLE.\");\n\t// this.debug(\"\\tIMPLEMENT doh._report() IN YOUR TEST RUNNER\");\n\n\tthis.debug(this._line);\n\tthis.debug(\"| TEST SUMMARY:\");\n\tthis.debug(this._line);\n\tthis.debug(\"\\t\", this._testCount, \"tests in\", this._groupCount, \"groups\");\n\tthis.debug(\"\\t\", this._errorCount, \"errors\");\n\tthis.debug(\"\\t\", this._failureCount, \"failures\");\n};\n\ndoh.togglePaused = function(){\n\tthis[(this._paused) ? \"run\" : \"pause\"]();\n};\n\ndoh.pause = function(){\n\t// summary:\n\t//\t\thalt test run. Can be resumed.\n\tthis._paused = true;\n};\n\ndoh.run = function(){\n\t// summary:\n\t//\t\tbegins or resumes the test process.\n\t\n\tthis._paused = false;\n\tvar cg = this._currentGroup;\n\tvar ct = this._currentTest;\n\tvar found = false;\n\tif(!cg){\n\t\tthis._init(); // we weren't paused\n\t\tfound = true;\n\t}\n\tthis._currentGroup = null;\n\tthis._currentTest = null;\n\tfor(var x in this._groups){\n\t\tif(\n\t\t\t( (!found)&&(x == cg) )||( found )\n\t\t){\n\t\t\tif(this._paused){ return; }\n\t\t\tthis._currentGroup = x;\n\t\t\tif(!found){\n\t\t\t\tfound = true;\n\t\t\t\tthis.runGroup(x, ct);\n\t\t\t}else{\n\t\t\t\tthis.runGroup(x);\n\t\t\t}\n\t\t\tif(this._paused){ return; }\n\t\t}\n\t}\n\tthis._currentGroup = null;\n\tthis._currentTest = null;\n\tthis._paused = false;\n\tthis._onEnd();\n\tthis._report();\n};\n\ndoh.runOnLoad = function(){\n\trequire([\"dojo/ready\"], function(ready){\n\t\tready(doh, \"run\");\n\t});\n};\n\nreturn doh;\n\n});\n\n// backcompat hack: if in the browser, then loading doh/runner implies loading doh/_browserRunner. This is the\n// behavior of 1.6- and is leveraged on many test documents that dojo.require(\"doh.runner\"). Note that this\n// hack will only work in synchronous mode; but if you're not in synchronous mode, you don't care about this.\n// Remove for 2.0.\nif (typeof window!=\"undefined\" && typeof location!=\"undefined\" && typeof document!=\"undefined\" && window.location==location && window.document==document) {\n\trequire([\"doh/_browserRunner\"]);\n}\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/AdapterRegistry.js":"define([\"./_base/kernel\", \"./_base/lang\"], function(dojo, lang){\n// module:\n//\t\tdojo/AdapterRegistry\n\nvar AdapterRegistry = dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){\n\t// summary:\n\t//\t\tA registry to make contextual calling/searching easier.\n\t// description:\n\t//\t\tObjects of this class keep list of arrays in the form [name, check,\n\t//\t\twrap, directReturn] that are used to determine what the contextual\n\t//\t\tresult of a set of checked arguments is. All check/wrap functions\n\t//\t\tin this registry should be of the same arity.\n\t// example:\n\t//\t|\t// create a new registry\n\t//\t|\trequire([\"dojo/AdapterRegistry\"],\n\t//\t|\tfunction(AdapterRegistry){\n\t//\t|\t\tvar reg = new AdapterRegistry();\n\t//\t|\t\treg.register(\"handleString\",\n\t//\t|\t\t\tfunction(str){\n\t//\t|\t\t\t\treturn typeof val == \"string\"\n\t//\t|\t\t\t},\n\t//\t|\t\t\tfunction(str){\n\t//\t|\t\t\t\t// do something with the string here\n\t//\t|\t\t\t}\n\t//\t|\t\t);\n\t//\t|\t\treg.register(\"handleArr\",\n\t//\t|\t\t\tdojo.isArray,\n\t//\t|\t\t\tfunction(arr){\n\t//\t|\t\t\t\t// do something with the array here\n\t//\t|\t\t\t}\n\t//\t|\t\t);\n\t//\t|\n\t//\t|\t\t// now we can pass reg.match() *either* an array or a string and\n\t//\t|\t\t// the value we pass will get handled by the right function\n\t//\t|\t\treg.match(\"someValue\"); // will call the first function\n\t//\t|\t\treg.match([\"someValue\"]); // will call the second\n\t//\t|\t});\n\n\tthis.pairs = [];\n\tthis.returnWrappers = returnWrappers || false; // Boolean\n};\n\nlang.extend(AdapterRegistry, {\n\tregister: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){\n\t\t// summary:\n\t\t//\t\tregister a check function to determine if the wrap function or\n\t\t//\t\tobject gets selected\n\t\t// name:\n\t\t//\t\ta way to identify this matcher.\n\t\t// check:\n\t\t//\t\ta function that arguments are passed to from the adapter's\n\t\t//\t\tmatch() function.  The check function should return true if the\n\t\t//\t\tgiven arguments are appropriate for the wrap function.\n\t\t// directReturn:\n\t\t//\t\tIf directReturn is true, the value passed in for wrap will be\n\t\t//\t\treturned instead of being called. Alternately, the\n\t\t//\t\tAdapterRegistry can be set globally to \"return not call\" using\n\t\t//\t\tthe returnWrappers property. Either way, this behavior allows\n\t\t//\t\tthe registry to act as a \"search\" function instead of a\n\t\t//\t\tfunction interception library.\n\t\t// override:\n\t\t//\t\tIf override is given and true, the check function will be given\n\t\t//\t\thighest priority. Otherwise, it will be the lowest priority\n\t\t//\t\tadapter.\n\t\tthis.pairs[((override) ? \"unshift\" : \"push\")]([name, check, wrap, directReturn]);\n\t},\n\n\tmatch: function(/* ... */){\n\t\t// summary:\n\t\t//\t\tFind an adapter for the given arguments. If no suitable adapter\n\t\t//\t\tis found, throws an exception. match() accepts any number of\n\t\t//\t\targuments, all of which are passed to all matching functions\n\t\t//\t\tfrom the registered pairs.\n\t\tfor(var i = 0; i < this.pairs.length; i++){\n\t\t\tvar pair = this.pairs[i];\n\t\t\tif(pair[1].apply(this, arguments)){\n\t\t\t\tif((pair[3])||(this.returnWrappers)){\n\t\t\t\t\treturn pair[2];\n\t\t\t\t}else{\n\t\t\t\t\treturn pair[2].apply(this, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"No match found\");\n\t},\n\n\tunregister: function(name){\n\t\t// summary:\n\t\t//\t\tRemove a named adapter from the registry\n\t\t// name: String\n\t\t//\t\tThe name of the adapter.\n\t\t// returns: Boolean\n\t\t//\t\tReturns true if operation is successful.\n\t\t//\t\tReturns false if operation fails.\n\t\n\t\t// FIXME: this is kind of a dumb way to handle this. On a large\n\t\t// registry this will be slow-ish and we can use the name as a lookup\n\t\t// should we choose to trade memory for speed.\n\t\tfor(var i = 0; i < this.pairs.length; i++){\n\t\t\tvar pair = this.pairs[i];\n\t\t\tif(pair[0] == name){\n\t\t\t\tthis.pairs.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nreturn AdapterRegistry;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/aspect.js":"define([], function(){\n\n\t// module:\n\t//\t\tdojo/aspect\n\n\t\"use strict\";\n\tvar undefined, nextId = 0;\n\tfunction advise(dispatcher, type, advice, receiveArguments){\n\t\tvar previous = dispatcher[type];\n\t\tvar around = type == \"around\";\n\t\tvar signal;\n\t\tif(around){\n\t\t\tvar advised = advice(function(){\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t});\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(advised){\n\t\t\t\t\t\tadvised = dispatcher = advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadvice: function(target, args){\n\t\t\t\t\treturn advised ?\n\t\t\t\t\t\tadvised.apply(target, args) :  // called the advised function\n\t\t\t\t\t\tprevious.advice(target, args); // cancelled, skip to next one\n\t\t\t\t}\n\t\t\t};\n\t\t}else{\n\t\t\t// create the remove handler\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(signal.advice){\n\t\t\t\t\t\tvar previous = signal.previous;\n\t\t\t\t\t\tvar next = signal.next;\n\t\t\t\t\t\tif(!next && !previous){\n\t\t\t\t\t\t\tdelete dispatcher[type];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(previous){\n\t\t\t\t\t\t\t\tprevious.next = next;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatcher[type] = next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(next){\n\t\t\t\t\t\t\t\tnext.previous = previous;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove the advice to signal that this signal has been removed\n\t\t\t\t\t\tdispatcher = advice = signal.advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: nextId++,\n\t\t\t\tadvice: advice,\n\t\t\t\treceiveArguments: receiveArguments\n\t\t\t};\n\t\t}\n\t\tif(previous && !around){\n\t\t\tif(type == \"after\"){\n\t\t\t\t// add the listener to the end of the list\n\t\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\t\twhile(previous.next && (previous = previous.next)){}\n\t\t\t\tprevious.next = signal;\n\t\t\t\tsignal.previous = previous;\n\t\t\t}else if(type == \"before\"){\n\t\t\t\t// add to beginning\n\t\t\t\tdispatcher[type] = signal;\n\t\t\t\tsignal.next = previous;\n\t\t\t\tprevious.previous = signal;\n\t\t\t}\n\t\t}else{\n\t\t\t// around or first one just replaces\n\t\t\tdispatcher[type] = signal;\n\t\t}\n\t\treturn signal;\n\t}\n\tfunction aspect(type){\n\t\treturn function(target, methodName, advice, receiveArguments){\n\t\t\tvar existing = target[methodName], dispatcher;\n\t\t\tif(!existing || existing.target != target){\n\t\t\t\t// no dispatcher in place\n\t\t\t\ttarget[methodName] = dispatcher = function(){\n\t\t\t\t\tvar executionId = nextId;\n\t\t\t\t\t// before advice\n\t\t\t\t\tvar args = arguments;\n\t\t\t\t\tvar before = dispatcher.before;\n\t\t\t\t\twhile(before){\n\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t\t\tbefore = before.next;\n\t\t\t\t\t}\n\t\t\t\t\t// around advice\n\t\t\t\t\tif(dispatcher.around){\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\n\t\t\t\t\t}\n\t\t\t\t\t// after advice\n\t\t\t\t\tvar after = dispatcher.after;\n\t\t\t\t\twhile(after && after.id < executionId){\n\t\t\t\t\t\tif(after.receiveArguments){\n\t\t\t\t\t\t\tvar newResults = after.advice.apply(this, args);\n\t\t\t\t\t\t\t// change the return value only if a new value was returned\n\t\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafter = after.next;\n\t\t\t\t\t}\n\t\t\t\t\treturn results;\n\t\t\t\t};\n\t\t\t\tif(existing){\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\n\t\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tdispatcher.target = target;\n\t\t\t}\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\n\t\t\tadvice = null;\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// TODOC: after/before/around return object\n\n\tvar after = aspect(\"after\");\n\t/*=====\n\tafter = function(target, methodName, advice, receiveArguments){\n\t\t// summary:\n\t\t//\t\tThe \"after\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"after\" advice to a method. This function will be executed after the original method\n\t\t//\t\tis executed. By default the function will be called with a single argument, the return\n\t\t//\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\n\t\t//\t\tThe fourth (optional) argument can be set to true to so the function receives the original\n\t\t//\t\targuments (from when the original method was called) rather than the return value.\n\t\t//\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called after the original method\n\t\t// receiveArguments: Boolean?\n\t\t//\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\n\t\t//\t\twas called) rather than the return value of the original/previous method.\n\t\t// returns:\n\t\t//\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\n\t\t//\t\tstop the advice function from being executed.\n\t};\n\t=====*/\n\n\tvar before = aspect(\"before\");\n\t/*=====\n\tbefore = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"before\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"before\" advice to a method. This function will be executed before the original method\n\t\t//\t\tis executed. This function will be called with the arguments used to call the method.\n\t\t//\t\tThis function may optionally return an array as the new arguments to use to call\n\t\t//\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\n\t\t//\t\tIf the before method doesn't return anything (returns undefined) the original arguments\n\t\t//\t\twill be preserved.\n\t\t//\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called before the original method\n\t};\n\t=====*/\n\n\tvar around = aspect(\"around\");\n\t/*=====\n\t around = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"around\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"around\" advice to a method. The advisor function is immediately executed when\n\t\t//\t\tthe around() is called, is passed a single argument that is a function that can be\n\t\t//\t\tcalled to continue execution of the original method (or the next around advisor).\n\t\t//\t\tThe advisor function should return a function, and this function will be called whenever\n\t\t//\t\tthe method is called. It will be called with the arguments used to call the method.\n\t\t//\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\n\t\t// example:\n\t\t//\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\n\t\t//\t\twhich can then delegate to the next one and so on. For example:\n\t\t//\t\t|\taround(obj, \"foo\", function(originalFoo){\n\t\t//\t\t|\t\treturn function(){\n\t\t//\t\t|\t\t\tvar start = new Date().getTime();\n\t\t//\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); // call the original\n\t\t//\t\t|\t\t\tvar end = new Date().getTime();\n\t\t//\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\n\t\t//\t\t|\t\t\treturn results;\n\t\t//\t\t|\t\t};\n\t\t//\t\t|\t});\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called around the original method\n\t};\n\t=====*/\n\n\treturn {\n\t\t// summary:\n\t\t//\t\tprovides aspect oriented programming functionality, allowing for\n\t\t//\t\tone to add before, around, or after advice on existing methods.\n\t\t// example:\n\t\t//\t|\tdefine([\"dojo/aspect\"], function(aspect){\n\t\t//\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\n\t\t//\t|\t\t});\n\t\t//\n\t\t// example:\n\t\t//\tThe returned signal object can be used to cancel the advice.\n\t\t//\t|\tsignal.remove(); // this will stop the advice from being executed anymore\n\t\t//\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t// this will be called when targetObject.methodName() is called, before the original function is called\n\t\t//\t|\t });\n\n\t\tbefore: before,\n\t\taround: around,\n\t\tafter: after\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/back.js":"define([\"./_base/config\", \"./_base/lang\", \"./sniff\", \"./dom\", \"./dom-construct\", \"./_base/window\", \"require\"],\n\tfunction(config, lang, has, dom, domConstruct, baseWindow, require){\n\t// module:\n\t//\t\tdojo/back\n\n\tvar back = {\n\t\t// summary:\n\t\t//\t\tBrowser history management resources\n\t};\n\thas(\"extend-dojo\") && lang.setObject(\"dojo.back\", back);\n\n\t// everyone deals with encoding the hash slightly differently\n\n\tvar getHash = back.getHash = function(){\n\t\tvar h = window.location.hash;\n\t\tif(h.charAt(0) == \"#\"){ h = h.substring(1); }\n\t\treturn has(\"mozilla\") ? h : decodeURIComponent(h);\n\t},\n\n\tsetHash = back.setHash = function(h){\n\t\tif(!h){ h = \"\"; }\n\t\twindow.location.hash = encodeURIComponent(h);\n\t\thistoryCounter = history.length;\n\t};\n\n\tvar initialHref = (typeof(window) !== \"undefined\") ? window.location.href : \"\";\n\tvar initialHash = (typeof(window) !== \"undefined\") ? getHash() : \"\";\n\tvar initialState = null;\n\n\tvar locationTimer = null;\n\tvar bookmarkAnchor = null;\n\tvar historyIframe = null;\n\tvar forwardStack = [];\n\tvar historyStack = [];\n\tvar moveForward = false;\n\tvar changingUrl = false;\n\tvar historyCounter;\n\n\tfunction handleBackButton(){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\n\t\t//The \"current\" page is always at the top of the history stack.\n\t\tvar current = historyStack.pop();\n\t\tif(!current){ return; }\n\t\tvar last = historyStack[historyStack.length-1];\n\t\tif(!last && historyStack.length == 0){\n\t\t\tlast = initialState;\n\t\t}\n\t\tif(last){\n\t\t\tif(last.kwArgs[\"back\"]){\n\t\t\t\tlast.kwArgs[\"back\"]();\n\t\t\t}else if(last.kwArgs[\"backButton\"]){\n\t\t\t\tlast.kwArgs[\"backButton\"]();\n\t\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\t\tlast.kwArgs.handle(\"back\");\n\t\t\t}\n\t\t}\n\t\tforwardStack.push(current);\n\t}\n\n\tback.goBack = handleBackButton;\n\n\tfunction handleForwardButton(){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\t\tvar last = forwardStack.pop();\n\t\tif(!last){ return; }\n\t\tif(last.kwArgs[\"forward\"]){\n\t\t\tlast.kwArgs.forward();\n\t\t}else if(last.kwArgs[\"forwardButton\"]){\n\t\t\tlast.kwArgs.forwardButton();\n\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\tlast.kwArgs.handle(\"forward\");\n\t\t}\n\t\thistoryStack.push(last);\n\t}\n\n\tback.goForward = handleForwardButton;\n\n\tfunction createState(url, args, hash){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\t\treturn {\"url\": url, \"kwArgs\": args, \"urlHash\": hash};\t//Object\n\t}\n\n\tfunction getUrlQuery(url){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\t\tvar segments = url.split(\"?\");\n\t\tif(segments.length < 2){\n\t\t\treturn null; //null\n\t\t}\n\t\telse{\n\t\t\treturn segments[1]; //String\n\t\t}\n\t}\n\n\tfunction loadIframeHistory(){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\t\tvar url = (config[\"dojoIframeHistoryUrl\"] || require.toUrl(\"./resources/iframe_history.html\")) + \"?\" + (new Date()).getTime();\n\t\tmoveForward = true;\n\t\tif(historyIframe){\n\t\t\thas(\"webkit\") ? historyIframe.location = url : window.frames[historyIframe.name].location = url;\n\t\t}else{\n\t\t\t//console.warn(\"dojo/back: Not initialised. You need to call back.init() from a <script> block that lives inside the <body> tag.\");\n\t\t}\n\t\treturn url; //String\n\t}\n\n\tfunction checkLocation(){\n\t\tif(!changingUrl){\n\t\t\tvar hsl = historyStack.length;\n\n\t\t\tvar hash = getHash();\n\n\t\t\tif((hash === initialHash||window.location.href == initialHref)&&(hsl == 1)){\n\t\t\t\t// FIXME: could this ever be a forward button?\n\t\t\t\t// we can't clear it because we still need to check for forwards. Ugg.\n\t\t\t\t// clearInterval(this.locationTimer);\n\t\t\t\thandleBackButton();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// first check to see if we could have gone forward. We always halt on\n\t\t\t// a no-hash item.\n\t\t\tif(forwardStack.length > 0){\n\t\t\t\tif(forwardStack[forwardStack.length-1].urlHash === hash){\n\t\t\t\t\thandleForwardButton();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ok, that didn't work, try someplace back in the history stack\n\t\t\tif((hsl >= 2)&&(historyStack[hsl-2])){\n\t\t\t\tif(historyStack[hsl-2].urlHash === hash){\n\t\t\t\t\thandleBackButton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tback.init = function(){\n\t\t// summary:\n\t\t//\t\tInitializes the undo stack. This must be called from a <script>\n\t\t//\t\tblock that lives inside the `<body>` tag to prevent bugs on IE.\n\t\t//\n\t\t//\t\tOnly call this method before the page's DOM is finished loading. Otherwise\n\t\t//\t\tit will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,\n\t\t//\t\tin order for this method to work, dojo/back will need to be part of a build layer.\n\n\t\t// prevent reinit\n\t\tif(dom.byId(\"dj_history\")){ return; } \n\n\t\tvar src = config[\"dojoIframeHistoryUrl\"] || require.toUrl(\"./resources/iframe_history.html\");\n\t\tif (config.afterOnLoad){\n\t\t\tconsole.error(\"dojo/back::init() must be called before the DOM has loaded. \"\n\t\t\t\t\t\t+ \"Include dojo/back in a build layer.\");\n\t\t}else{\n\t\t\tdocument.write('<iframe style=\"border:0;width:1px;height:1px;position:absolute;visibility:hidden;bottom:0;right:0;\" name=\"dj_history\" id=\"dj_history\" src=\"' + src + '\"></iframe>');\n\t\t}\n\t};\n\n\tback.setInitialState = function(/*Object*/args){\n\t\t// summary:\n\t\t//\t\tSets the state object and back callback for the very first page\n\t\t//\t\tthat is loaded.\n\t\t//\n\t\t//\t\tIt is recommended that you call this method as part of an event\n\t\t//\t\tlistener that is registered via dojo/ready.\n\t\t// args: Object\n\t\t//\t\tSee the addToHistory() function for the list of valid args properties.\n\t\tinitialState = createState(initialHref, args, initialHash);\n\t};\n\n\t//FIXME: Make these doc comments not be awful. At least they're not wrong.\n\t//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.\n\t//FIXME: is there a slight race condition in moz using change URL with the timer check and when\n\t//\t\t the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.\n\n\n\t/*=====\n\tvar __backArgs = {\n\t\t// back: Function?\n\t\t//\t\tA function to be called when this state is reached via the user\n\t\t//\t\tclicking the back button.\n\t\t// forward: Function?\n\t\t//\t\tUpon return to this state from the \"back, forward\" combination\n\t\t//\t\tof navigation steps, this function will be called. Somewhat\n\t\t//\t\tanalogous to the semantic of an \"onRedo\" event handler.\n\t\t// changeUrl: Boolean|String?\n\t\t//\t\tBoolean indicating whether or not to create a unique hash for\n\t\t//\t\tthis state. If a string is passed instead, it is used as the\n\t\t//\t\thash.\n\t};\n\t=====*/\n\n\tback.addToHistory = function(args){\n\t\t// summary:\n\t\t//\t\tadds a state object (args) to the history list.\n\t\t// args: __backArgs\n\t\t//\t\tThe state object that will be added to the history list.\n\t\t// description:\n\t\t//\t\tTo support getting back button notifications, the object\n\t\t//\t\targument should implement a function called either \"back\",\n\t\t//\t\t\"backButton\", or \"handle\". The string \"back\" will be passed as\n\t\t//\t\tthe first and only argument to this callback.\n\t\t//\n\t\t//\t\tTo support getting forward button notifications, the object\n\t\t//\t\targument should implement a function called either \"forward\",\n\t\t//\t\t\"forwardButton\", or \"handle\". The string \"forward\" will be\n\t\t//\t\tpassed as the first and only argument to this callback.\n\t\t//\n\t\t//\t\tIf you want the browser location string to change, define \"changeUrl\" on the object. If the\n\t\t//\t\tvalue of \"changeUrl\" is true, then a unique number will be appended to the URL as a fragment\n\t\t//\t\tidentifier (http://some.domain.com/path#uniquenumber). If it is any other value that does\n\t\t//\t\tnot evaluate to false, that value will be used as the fragment identifier. For example,\n\t\t//\t\tif changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1\n\t\t//\n\t\t//\t\tThere are problems with using dojo/back with semantically-named fragment identifiers\n\t\t//\t\t(\"hash values\" on an URL). In most browsers it will be hard for dojo/back to know\n\t\t//\t\tdistinguish a back from a forward event in those cases. For back/forward support to\n\t\t//\t\twork best, the fragment ID should always be a unique value (something using new Date().getTime()\n\t\t//\t\tfor example). If you want to detect hash changes using semantic fragment IDs, then\n\t\t//\t\tconsider using dojo/hash instead (in Dojo 1.4+).\n\t\t//\n\t\t// example:\n\t\t//\t\t|\tback.addToHistory({\n\t\t//\t\t|\t\tback: function(){ console.log('back pressed'); },\n\t\t//\t\t|\t\tforward: function(){ console.log('forward pressed'); },\n\t\t//\t\t|\t\tchangeUrl: true\n\t\t//\t\t|\t});\n\n\t\t//\tBROWSER NOTES:\n\t\t//\tSafari 1.2:\n\t\t//\tback button \"works\" fine, however it's not possible to actually\n\t\t//\tDETECT that you've moved backwards by inspecting window.location.\n\t\t//\tUnless there is some other means of locating.\n\t\t//\tFIXME: perhaps we can poll on history.length?\n\t\t//\tSafari 2.0.3+ (and probably 1.3.2+):\n\t\t//\tworks fine, except when changeUrl is used. When changeUrl is used,\n\t\t//\tSafari jumps all the way back to whatever page was shown before\n\t\t//\tthe page that uses dojo.undo.browser support.\n\t\t//\tIE 5.5 SP2:\n\t\t//\tback button behavior is macro. It does not move back to the\n\t\t//\tprevious hash value, but to the last full page load. This suggests\n\t\t//\tthat the iframe is the correct way to capture the back button in\n\t\t//\tthese cases.\n\t\t//\tDon't test this page using local disk for MSIE. MSIE will not create\n\t\t//\ta history list for iframe_history.html if served from a file: URL.\n\t\t//\tThe XML served back from the XHR tests will also not be properly\n\t\t//\tcreated if served from local disk. Serve the test pages from a web\n\t\t//\tserver to test in that browser.\n\t\t//\tIE 6.0:\n\t\t//\tsame behavior as IE 5.5 SP2\n\t\t//\tFirefox 1.0+:\n\t\t//\tthe back button will return us to the previous hash on the same\n\t\t//\tpage, thereby not requiring an iframe hack, although we do then\n\t\t//\tneed to run a timer to detect inter-page movement.\n\n\t\t//If addToHistory is called, then that means we prune the\n\t\t//forward stack -- the user went back, then wanted to\n\t\t//start a new forward path.\n\t\tforwardStack = [];\n\n\t\tvar hash = null;\n\t\tvar url = null;\n\t\tif(!historyIframe){\n\t\t\tif(config[\"useXDomain\"] && !config[\"dojoIframeHistoryUrl\"]){\n\t\t\t\tconsole.warn(\"dojo/back: When using cross-domain Dojo builds,\"\n\t\t\t\t\t+ \" please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl\"\n\t\t\t\t\t+ \" to the path on your domain to iframe_history.html\");\n\t\t\t}\n\t\t\thistoryIframe = window.frames[\"dj_history\"];\n\t\t}\n\t\tif(!bookmarkAnchor){\n\t\t\tbookmarkAnchor = domConstruct.create(\"a\", {style: {display: \"none\"}}, baseWindow.body());\n\t\t}\n\t\tif(args[\"changeUrl\"]){\n\t\t\thash = \"\"+ ((args[\"changeUrl\"]!==true) ? args[\"changeUrl\"] : (new Date()).getTime());\n\n\t\t\t//If the current hash matches the new one, just replace the history object with\n\t\t\t//this new one. It doesn't make sense to track different state objects for the same\n\t\t\t//logical URL. This matches the browser behavior of only putting in one history\n\t\t\t//item no matter how many times you click on the same #hash link, at least in Firefox\n\t\t\t//and Safari, and there is no reliable way in those browsers to know if a #hash link\n\t\t\t//has been clicked on multiple times. So making this the standard behavior in all browsers\n\t\t\t//so that dojo/back's behavior is the same in all browsers.\n\t\t\tif(historyStack.length == 0 && initialState.urlHash == hash){\n\t\t\t\tinitialState = createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}else if(historyStack.length > 0 && historyStack[historyStack.length - 1].urlHash == hash){\n\t\t\t\thistoryStack[historyStack.length - 1] = createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchangingUrl = true;\n\t\t\tsetTimeout(function(){\n\t\t\t\t\tsetHash(hash);\n\t\t\t\t\tchangingUrl = false;\n\t\t\t\t}, 1);\n\t\t\tbookmarkAnchor.href = hash;\n\n\t\t\tif(has(\"ie\")){\n\t\t\t\turl = loadIframeHistory();\n\n\t\t\t\tvar oldCB = args[\"back\"]||args[\"backButton\"]||args[\"handle\"];\n\n\t\t\t\t//The function takes handleName as a parameter, in case the\n\t\t\t\t//callback we are overriding was \"handle\". In that case,\n\t\t\t\t//we will need to pass the handle name to handle.\n\t\t\t\tvar tcb = function(handleName){\n\t\t\t\t\tif(getHash() != \"\"){\n\t\t\t\t\t\tsetTimeout(function(){ setHash(hash); }, 1);\n\t\t\t\t\t}\n\t\t\t\t\t//Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\toldCB.apply(this, [handleName]);\n\t\t\t\t};\n\n\t\t\t\t//Set interceptor function in the right place.\n\t\t\t\tif(args[\"back\"]){\n\t\t\t\t\targs.back = tcb;\n\t\t\t\t}else if(args[\"backButton\"]){\n\t\t\t\t\targs.backButton = tcb;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tcb;\n\t\t\t\t}\n\n\t\t\t\tvar oldFW = args[\"forward\"]||args[\"forwardButton\"]||args[\"handle\"];\n\n\t\t\t\t//The function takes handleName as a parameter, in case the\n\t\t\t\t//callback we are overriding was \"handle\". In that case,\n\t\t\t\t//we will need to pass the handle name to handle.\n\t\t\t\tvar tfw = function(handleName){\n\t\t\t\t\tif(getHash() != \"\"){\n\t\t\t\t\t\tsetHash(hash);\n\t\t\t\t\t}\n\t\t\t\t\tif(oldFW){ // we might not actually have one\n\t\t\t\t\t\t//Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t//Set interceptor function in the right place.\n\t\t\t\tif(args[\"forward\"]){\n\t\t\t\t\targs.forward = tfw;\n\t\t\t\t}else if(args[\"forwardButton\"]){\n\t\t\t\t\targs.forwardButton = tfw;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tfw;\n\t\t\t\t}\n\n\t\t\t}else if(!has(\"ie\")){\n\t\t\t\t// start the timer\n\t\t\t\tif(!locationTimer){\n\t\t\t\t\tlocationTimer = setInterval(checkLocation, 200);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}else{\n\t\t\turl = loadIframeHistory();\n\t\t}\n\n\t\thistoryStack.push(createState(url, args, hash));\n\t};\n\n\tback._iframeLoaded = function(evt, ifrLoc){\n\t\t// summary:\n\t\t//\t\tprivate method. Do not call this directly.\n\t\tvar query = getUrlQuery(ifrLoc.href);\n\t\tif(query == null){\n\t\t\t// alert(\"iframeLoaded\");\n\t\t\t// we hit the end of the history, so we should go back\n\t\t\tif(historyStack.length == 1){\n\t\t\t\thandleBackButton();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(moveForward){\n\t\t\t// we were expecting it, so it's not either a forward or backward movement\n\t\t\tmoveForward = false;\n\t\t\treturn;\n\t\t}\n\n\t\t//Check the back stack first, since it is more likely.\n\t\t//Note that only one step back or forward is supported.\n\t\tif(historyStack.length >= 2 && query == getUrlQuery(historyStack[historyStack.length-2].url)){\n\t\t\thandleBackButton();\n\t\t}else if(forwardStack.length > 0 && query == getUrlQuery(forwardStack[forwardStack.length-1].url)){\n\t\t\thandleForwardButton();\n\t\t}\n\t};\n\n\treturn back;\n\t\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/behavior.js":"define([\"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/connect\", \"./query\", \"./domReady\"],\nfunction(dojo, lang, darray, connect, query, domReady){\n\n// module:\n//\t\tdojo/behavior\n\ndojo.deprecated(\"dojo.behavior\", \"Use dojo/on with event delegation (on.selector())\");\n\nvar Behavior = function(){\n\t// summary:\n\t//\t\tDeprecated.   dojo/behavior's functionality can be achieved using event delegation using dojo/on\n\t//\t\tand on.selector().\n\t// description:\n\t//\t\tA very simple, lightweight mechanism for applying code to\n\t//\t\texisting documents, based around `dojo/query` (CSS3 selectors) for node selection,\n\t//\t\tand a simple two-command API: `add()` and `apply()`;\n\t//\n\t//\t\tBehaviors apply to a given page, and are registered following the syntax\n\t//\t\toptions described by `add()` to match nodes to actions, or \"behaviors\".\n\t//\n\t//\t\tAdded behaviors are applied to the current DOM when .apply() is called,\n\t//\t\tmatching only new nodes found since .apply() was last called.\n\n\tfunction arrIn(obj, name){\n\t\tif(!obj[name]){ obj[name] = []; }\n\t\treturn obj[name];\n\t}\n\n\tvar _inc = 0;\n\n\tfunction forIn(obj, scope, func){\n\t\tvar tmpObj = {};\n\t\tfor(var x in obj){\n\t\t\tif(typeof tmpObj[x] == \"undefined\"){\n\t\t\t\tif(!func){\n\t\t\t\t\tscope(obj[x], x);\n\t\t\t\t}else{\n\t\t\t\t\tfunc.call(scope, obj[x], x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// FIXME: need a better test so we don't exclude nightly Safari's!\n\tthis._behaviors = {};\n\tthis.add = function(/* Object */behaviorObj){\n\t\t// summary:\n\t\t//\t\tAdd the specified behavior to the list of behaviors, ignoring existing\n\t\t//\t\tmatches.\n\t\t// behaviorObj: Object\n\t\t//\t\tThe behavior object that will be added to behaviors list. The behaviors\n\t\t//\t\tin the list will be applied the next time apply() is called.\n\t\t// description:\n\t\t//\t\tAdd the specified behavior to the list of behaviors which will\n\t\t//\t\tbe applied the next time apply() is called. Calls to add() for\n\t\t//\t\tan already existing behavior do not replace the previous rules,\n\t\t//\t\tbut are instead additive. New nodes which match the rule will\n\t\t//\t\thave all add()-ed behaviors applied to them when matched.\n\t\t//\n\t\t//\t\tThe \"found\" method is a generalized handler that's called as soon\n\t\t//\t\tas the node matches the selector. Rules for values that follow also\n\t\t//\t\tapply to the \"found\" key.\n\t\t//\n\t\t//\t\tThe \"on*\" handlers are attached with `dojo.connect()`, using the\n\t\t//\t\tmatching node\n\t\t//\n\t\t//\t\tIf the value corresponding to the ID key is a function and not a\n\t\t//\t\tlist, it's treated as though it was the value of \"found\".\n\t\t//\n\t\t//\t\tdojo/behavior.add() can be called any number of times before\n\t\t//\t\tthe DOM is ready. `dojo/behavior.apply()` is called automatically\n\t\t//\t\tby `dojo.addOnLoad`, though can be called to re-apply previously added\n\t\t//\t\tbehaviors anytime the DOM changes.\n\t\t//\n\t\t//\t\tThere are a variety of formats permitted in the behaviorObject\n\t\t//\n\t\t// example:\n\t\t//\t\tSimple list of properties. \"found\" is special. \"Found\" is assumed if\n\t\t//\t\tno property object for a given selector, and property is a function.\n\t\t//\n\t\t//\t|\tbehavior.add({\n\t\t//\t|\t\t\"#id\": {\n\t\t//\t|\t\t\t\"found\": function(element){\n\t\t//\t|\t\t\t\t// node match found\n\t\t//\t|\t\t\t},\n\t\t//\t|\t\t\t\"onclick\": function(evt){\n\t\t//\t|\t\t\t\t// register onclick handler for found node\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t},\n\t\t// \t|\t\t\"#otherid\": function(element){\n\t\t//\t|\t\t\t// assumes \"found\" with this syntax\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\t If property is a string, a dojo.publish will be issued on the channel:\n\t\t//\n\t\t//\t|\tbehavior.add({\n\t\t//\t|\t\t// topic.publish() whenever class=\"noclick\" found on anchors\n\t\t//\t|\t\t\"a.noclick\": \"/got/newAnchor\",\n\t\t//\t|\t\t\"div.wrapper\": {\n\t\t//\t|\t\t\t\"onclick\": \"/node/wasClicked\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\ttopic.subscribe(\"/got/newAnchor\", function(node){\n\t\t//\t|\t\t// handle node finding when dojo/behavior.apply() is called,\n\t\t//\t|\t\t// provided a newly matched node is found.\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tScoping can be accomplished by passing an object as a property to\n\t\t//\t\ta connection handle (on*):\n\t\t//\n\t\t//\t|\tbehavior.add({\n\t\t//\t|\t\t \t\"#id\": {\n\t\t//\t|\t\t\t\t// like calling dojo.hitch(foo,\"bar\"). execute foo.bar() in scope of foo\n\t\t//\t|\t\t\t\t\"onmouseenter\": { targetObj: foo, targetFunc: \"bar\" },\n\t\t//\t|\t\t\t\t\"onmouseleave\": { targetObj: foo, targetFunc: \"baz\" }\n\t\t//\t|\t\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tBehaviors match on CSS3 Selectors, powered by dojo/query. Example selectors:\n\t\t//\n\t\t//\t|\tbehavior.add({\n\t\t//\t|\t\t// match all direct descendants\n\t\t//\t|\t\t\"#id4 > *\": function(element){\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t},\n\t\t//\t|\n\t\t//\t|\t\t// match the first child node that's an element\n\t\t//\t|\t\t\"#id4 > :first-child\": { ... },\n\t\t//\t|\n\t\t//\t|\t\t// match the last child node that's an element\n\t\t//\t|\t\t\"#id4 > :last-child\":  { ... },\n\t\t//\t|\n\t\t//\t|\t\t// all elements of type tagname\n\t\t//\t|\t\t\"tagname\": {\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t},\n\t\t//\t|\n\t\t//\t|\t\t\"tagname1 tagname2 tagname3\": {\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t},\n\t\t//\t|\n\t\t//\t|\t\t\".classname\": {\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t},\n\t\t//\t|\n\t\t//\t|\t\t\"tagname.classname\": {\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\n\t\tforIn(behaviorObj, this, function(behavior, name){\n\t\t\tvar tBehavior = arrIn(this._behaviors, name);\n\t\t\tif(typeof tBehavior[\"id\"] != \"number\"){\n\t\t\t\ttBehavior.id = _inc++;\n\t\t\t}\n\t\t\tvar cversion = [];\n\t\t\ttBehavior.push(cversion);\n\t\t\tif((lang.isString(behavior))||(lang.isFunction(behavior))){\n\t\t\t\tbehavior = { found: behavior };\n\t\t\t}\n\t\t\tforIn(behavior, function(rule, ruleName){\n\t\t\t\tarrIn(cversion, ruleName).push(rule);\n\t\t\t});\n\t\t});\n\t};\n\n\tvar _applyToNode = function(node, action, ruleSetName){\n\t\tif(lang.isString(action)){\n\t\t\tif(ruleSetName == \"found\"){\n\t\t\t\tconnect.publish(action, [ node ]);\n\t\t\t}else{\n\t\t\t\tconnect.connect(node, ruleSetName, function(){\n\t\t\t\t\tconnect.publish(action, arguments);\n\t\t\t\t});\n\t\t\t}\n\t\t}else if(lang.isFunction(action)){\n\t\t\tif(ruleSetName == \"found\"){\n\t\t\t\taction(node);\n\t\t\t}else{\n\t\t\t\tconnect.connect(node, ruleSetName, action);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.apply = function(){\n\t\t// summary:\n\t\t//\t\tApplies all currently registered behaviors to the document.\n\t\t//\n\t\t// description:\n\t\t//\t\tApplies all currently registered behaviors to the document,\n\t\t//\t\ttaking care to ensure that only incremental updates are made\n\t\t//\t\tsince the last time add() or apply() were called.\n\t\t//\n\t\t//\t\tIf new matching nodes have been added, all rules in a behavior will be\n\t\t//\t\tapplied to that node. For previously matched nodes, only\n\t\t//\t\tbehaviors which have been added since the last call to apply()\n\t\t//\t\twill be added to the nodes.\n\t\t//\n\t\t//\t\tapply() is called once automatically by `dojo.addOnLoad`, so\n\t\t//\t\tregistering behaviors with `dojo/behavior.add()` before the DOM is\n\t\t//\t\tready is acceptable, provided the dojo.behavior module is ready.\n\t\t//\n\t\t//\t\tCalling appy() manually after manipulating the DOM is required\n\t\t//\t\tto rescan the DOM and apply newly .add()ed behaviors, or to match\n\t\t//\t\tnodes that match existing behaviors when those nodes are added to\n\t\t//\t\tthe DOM.\n\t\t//\n\t\tforIn(this._behaviors, function(tBehavior, id){\n\t\t\tquery(id).forEach(\n\t\t\t\tfunction(elem){\n\t\t\t\t\tvar runFrom = 0;\n\t\t\t\t\tvar bid = \"_dj_behavior_\"+tBehavior.id;\n\t\t\t\t\tif(typeof elem[bid] == \"number\"){\n\t\t\t\t\t\trunFrom = elem[bid];\n\t\t\t\t\t\tif(runFrom == (tBehavior.length)){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// run through the versions, applying newer rules at each step\n\n\t\t\t\t\tfor(var x=runFrom, tver; tver = tBehavior[x]; x++){\n\t\t\t\t\t\tforIn(tver, function(ruleSet, ruleSetName){\n\t\t\t\t\t\t\tif(lang.isArray(ruleSet)){\n\t\t\t\t\t\t\t\tdarray.forEach(ruleSet, function(action){\n\t\t\t\t\t\t\t\t\t_applyToNode(elem, action, ruleSetName);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// ensure that re-application only adds new rules to the node\n\t\t\t\t\telem[bid] = tBehavior.length;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t};\n};\n\ndojo.behavior = new Behavior();\n\ndomReady( function(){ dojo.behavior.apply(); } );\n\nreturn dojo.behavior;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/cache.js":"define([\"./_base/kernel\", \"./text\"], function(dojo){\n\t// module:\n\t//\t\tdojo/cache\n\n\t// dojo.cache is defined in dojo/text\n\treturn dojo.cache;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/colors.js":"define([\"./_base/kernel\", \"./_base/lang\", \"./_base/Color\", \"./_base/array\"], function(dojo, lang, Color, ArrayUtil){\n\t// module:\n\t//\t\tdojo/colors\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tColor utilities, extending Base dojo.Color\n\t};\n\t=====*/\n\n\tvar ColorExt = {};\n\tlang.setObject(\"dojo.colors\", ColorExt);\n\n//TODO: this module appears to break naming conventions\n\n\t// this is a standard conversion prescribed by the CSS3 Color Module\n\tvar hue2rgb = function(m1, m2, h){\n\t\tif(h < 0){ ++h; }\n\t\tif(h > 1){ --h; }\n\t\tvar h6 = 6 * h;\n\t\tif(h6 < 1){ return m1 + (m2 - m1) * h6; }\n\t\tif(2 * h < 1){ return m2; }\n\t\tif(3 * h < 2){ return m1 + (m2 - m1) * (2 / 3 - h) * 6; }\n\t\treturn m1;\n\t};\n\t// Override base Color.fromRgb with the impl in this module\n\tdojo.colorFromRgb = Color.fromRgb = function(/*String*/ color, /*dojo/_base/Color?*/ obj){\n\t\t// summary:\n\t\t//\t\tget rgb(a) array from css-style color declarations\n\t\t// description:\n\t\t//\t\tthis function can handle all 4 CSS3 Color Module formats: rgb,\n\t\t//\t\trgba, hsl, hsla, including rgb(a) with percentage values.\n\t\tvar m = color.toLowerCase().match(/^(rgba?|hsla?)\\(([\\s\\.\\-,%0-9]+)\\)/);\n\t\tif(m){\n\t\t\tvar c = m[2].split(/\\s*,\\s*/), l = c.length, t = m[1], a;\n\t\t\tif((t == \"rgb\" && l == 3) || (t == \"rgba\" && l == 4)){\n\t\t\t\tvar r = c[0];\n\t\t\t\tif(r.charAt(r.length - 1) == \"%\"){\n\t\t\t\t\t// 3 rgb percentage values\n\t\t\t\t\ta = ArrayUtil.map(c, function(x){\n\t\t\t\t\t\treturn parseFloat(x) * 2.56;\n\t\t\t\t\t});\n\t\t\t\t\tif(l == 4){ a[3] = c[3]; }\n\t\t\t\t\treturn Color.fromArray(a, obj); // dojo/_base/Color\n\t\t\t\t}\n\t\t\t\treturn Color.fromArray(c, obj); // dojo/_base/Color\n\t\t\t}\n\t\t\tif((t == \"hsl\" && l == 3) || (t == \"hsla\" && l == 4)){\n\t\t\t\t// normalize hsl values\n\t\t\t\tvar H = ((parseFloat(c[0]) % 360) + 360) % 360 / 360,\n\t\t\t\t\tS = parseFloat(c[1]) / 100,\n\t\t\t\t\tL = parseFloat(c[2]) / 100,\n\t\t\t\t\t// calculate rgb according to the algorithm\n\t\t\t\t\t// recommended by the CSS3 Color Module\n\t\t\t\t\tm2 = L <= 0.5 ? L * (S + 1) : L + S - L * S,\n\t\t\t\t\tm1 = 2 * L - m2;\n\t\t\t\ta = [\n\t\t\t\t\thue2rgb(m1, m2, H + 1 / 3) * 256,\n\t\t\t\t\thue2rgb(m1, m2, H) * 256,\n\t\t\t\t\thue2rgb(m1, m2, H - 1 / 3) * 256,\n\t\t\t\t\t1\n\t\t\t\t];\n\t\t\t\tif(l == 4){ a[3] = c[3]; }\n\t\t\t\treturn Color.fromArray(a, obj); // dojo/_base/Color\n\t\t\t}\n\t\t}\n\t\treturn null;\t// dojo/_base/Color\n\t};\n\n\tvar confine = function(c, low, high){\n\t\t// summary:\n\t\t//\t\tsanitize a color component by making sure it is a number,\n\t\t//\t\tand clamping it to valid values\n\t\tc = Number(c);\n\t\treturn isNaN(c) ? high : c < low ? low : c > high ? high : c;\t// Number\n\t};\n\n\tColor.prototype.sanitize = function(){\n\t\t// summary:\n\t\t//\t\tmakes sure that the object has correct attributes\n\t\tvar t = this;\n\t\tt.r = Math.round(confine(t.r, 0, 255));\n\t\tt.g = Math.round(confine(t.g, 0, 255));\n\t\tt.b = Math.round(confine(t.b, 0, 255));\n\t\tt.a = confine(t.a, 0, 1);\n\t\treturn this;\t// dojo/_base/Color\n\t};\n\n\tColorExt.makeGrey = Color.makeGrey = function(/*Number*/ g, /*Number?*/ a){\n\t\t// summary:\n\t\t//\t\tcreates a greyscale color with an optional alpha\n\t\treturn Color.fromArray([g, g, g, a]);\t// dojo/_base/Color\n\t};\n\n\t// mixin all CSS3 named colors not already in _base, along with SVG 1.0 variant spellings\n\tlang.mixin(Color.named, {\n\t\t\"aliceblue\":\t[240,248,255],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"aquamarine\":\t[127,255,212],\n\t\t\"azure\":\t[240,255,255],\n\t\t\"beige\":\t[245,245,220],\n\t\t\"bisque\":\t[255,228,196],\n\t\t\"blanchedalmond\":\t[255,235,205],\n\t\t\"blueviolet\":\t[138,43,226],\n\t\t\"brown\":\t[165,42,42],\n\t\t\"burlywood\":\t[222,184,135],\n\t\t\"cadetblue\":\t[95,158,160],\n\t\t\"chartreuse\":\t[127,255,0],\n\t\t\"chocolate\":\t[210,105,30],\n\t\t\"coral\":\t[255,127,80],\n\t\t\"cornflowerblue\":\t[100,149,237],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"crimson\":\t[220,20,60],\n\t\t\"cyan\": [0,255,255],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"darkgoldenrod\":\t[184,134,11],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgreen\":\t[0,100,0],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"darkkhaki\":\t[189,183,107],\n\t\t\"darkmagenta\":\t[139,0,139],\n\t\t\"darkolivegreen\":\t[85,107,47],\n\t\t\"darkorange\":\t[255,140,0],\n\t\t\"darkorchid\":\t[153,50,204],\n\t\t\"darkred\":\t[139,0,0],\n\t\t\"darksalmon\":\t[233,150,122],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"darkslateblue\":\t[72,61,139],\n\t\t\"darkslategray\":\t[47,79,79],\n\t\t\"darkslategrey\":\t[47,79,79],\n\t\t\"darkturquoise\":\t[0,206,209],\n\t\t\"darkviolet\":\t[148,0,211],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"deepskyblue\":\t[0,191,255],\n\t\t\"dimgray\":\t[105,105,105],\n\t\t\"dimgrey\":\t[105,105,105],\n\t\t\"dodgerblue\":\t[30,144,255],\n\t\t\"firebrick\":\t[178,34,34],\n\t\t\"floralwhite\":\t[255,250,240],\n\t\t\"forestgreen\":\t[34,139,34],\n\t\t\"gainsboro\":\t[220,220,220],\n\t\t\"ghostwhite\":\t[248,248,255],\n\t\t\"gold\": [255,215,0],\n\t\t\"goldenrod\":\t[218,165,32],\n\t\t\"greenyellow\":\t[173,255,47],\n\t\t\"grey\": [128,128,128],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"hotpink\":\t[255,105,180],\n\t\t\"indianred\":\t[205,92,92],\n\t\t\"indigo\":\t[75,0,130],\n\t\t\"ivory\":\t[255,255,240],\n\t\t\"khaki\":\t[240,230,140],\n\t\t\"lavender\": [230,230,250],\n\t\t\"lavenderblush\":\t[255,240,245],\n\t\t\"lawngreen\":\t[124,252,0],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"lightblue\":\t[173,216,230],\n\t\t\"lightcoral\":\t[240,128,128],\n\t\t\"lightcyan\":\t[224,255,255],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"lightgray\":\t[211,211,211],\n\t\t\"lightgreen\":\t[144,238,144],\n\t\t\"lightgrey\":\t[211,211,211],\n\t\t\"lightpink\":\t[255,182,193],\n\t\t\"lightsalmon\":\t[255,160,122],\n\t\t\"lightseagreen\":\t[32,178,170],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"lightslategray\":\t[119,136,153],\n\t\t\"lightslategrey\":\t[119,136,153],\n\t\t\"lightsteelblue\":\t[176,196,222],\n\t\t\"lightyellow\":\t[255,255,224],\n\t\t\"limegreen\":\t[50,205,50],\n\t\t\"linen\":\t[250,240,230],\n\t\t\"magenta\":\t[255,0,255],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"mediumblue\":\t[0,0,205],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"mediumpurple\": [147,112,219],\n\t\t\"mediumseagreen\":\t[60,179,113],\n\t\t\"mediumslateblue\":\t[123,104,238],\n\t\t\"mediumspringgreen\":\t[0,250,154],\n\t\t\"mediumturquoise\":\t[72,209,204],\n\t\t\"mediumvioletred\":\t[199,21,133],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"mintcream\":\t[245,255,250],\n\t\t\"mistyrose\":\t[255,228,225],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"navajowhite\":\t[255,222,173],\n\t\t\"oldlace\":\t[253,245,230],\n\t\t\"olivedrab\":\t[107,142,35],\n\t\t\"orange\":\t[255,165,0],\n\t\t\"orangered\":\t[255,69,0],\n\t\t\"orchid\":\t[218,112,214],\n\t\t\"palegoldenrod\":\t[238,232,170],\n\t\t\"palegreen\":\t[152,251,152],\n\t\t\"paleturquoise\":\t[175,238,238],\n\t\t\"palevioletred\":\t[219,112,147],\n\t\t\"papayawhip\":\t[255,239,213],\n\t\t\"peachpuff\":\t[255,218,185],\n\t\t\"peru\": [205,133,63],\n\t\t\"pink\": [255,192,203],\n\t\t\"plum\": [221,160,221],\n\t\t\"powderblue\":\t[176,224,230],\n\t\t\"rosybrown\":\t[188,143,143],\n\t\t\"royalblue\":\t[65,105,225],\n\t\t\"saddlebrown\":\t[139,69,19],\n\t\t\"salmon\":\t[250,128,114],\n\t\t\"sandybrown\":\t[244,164,96],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"seashell\": [255,245,238],\n\t\t\"sienna\":\t[160,82,45],\n\t\t\"skyblue\":\t[135,206,235],\n\t\t\"slateblue\":\t[106,90,205],\n\t\t\"slategray\":\t[112,128,144],\n\t\t\"slategrey\":\t[112,128,144],\n\t\t\"snow\": [255,250,250],\n\t\t\"springgreen\":\t[0,255,127],\n\t\t\"steelblue\":\t[70,130,180],\n\t\t\"tan\":\t[210,180,140],\n\t\t\"thistle\":\t[216,191,216],\n\t\t\"tomato\":\t[255,99,71],\n\t\t\"turquoise\":\t[64,224,208],\n\t\t\"violet\":\t[238,130,238],\n\t\t\"wheat\":\t[245,222,179],\n\t\t\"whitesmoke\":\t[245,245,245],\n\t\t\"yellowgreen\":\t[154,205,50]\n\t});\n\n\treturn Color;\t// TODO: return ColorExt, not Color\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/cookie.js":"define([\"./_base/kernel\", \"./regexp\"], function(dojo, regexp){\n\n// module:\n//\t\tdojo/cookie\n\n/*=====\nvar __cookieProps = {\n\t// expires: Date|String|Number?\n\t//\t\tIf a number, the number of days from today at which the cookie\n\t//\t\twill expire. If a date, the date past which the cookie will expire.\n\t//\t\tIf expires is in the past, the cookie will be deleted.\n\t//\t\tIf expires is omitted or is 0, the cookie will expire when the browser closes.\n\t// path: String?\n\t//\t\tThe path to use for the cookie.\n\t// domain: String?\n\t//\t\tThe domain to use for the cookie.\n\t// secure: Boolean?\n\t//\t\tWhether to only send the cookie on secure connections\n};\n=====*/\n\n\ndojo.cookie = function(/*String*/name, /*String?*/ value, /*__cookieProps?*/ props){\n\t// summary:\n\t//\t\tGet or set a cookie.\n\t// description:\n\t//\t\tIf one argument is passed, returns the value of the cookie\n\t//\t\tFor two or more arguments, acts as a setter.\n\t// name:\n\t//\t\tName of the cookie\n\t// value:\n\t//\t\tValue for the cookie\n\t// props:\n\t//\t\tProperties for the cookie\n\t// example:\n\t//\t\tset a cookie with the JSON-serialized contents of an object which\n\t//\t\twill expire 5 days from now:\n\t//\t|\trequire([\"dojo/cookie\", \"dojo/json\"], function(cookie, json){\n\t//\t|\t\tcookie(\"configObj\", json.stringify(config, {expires: 5 }));\n\t//\t|\t});\n\t//\n\t// example:\n\t//\t\tde-serialize a cookie back into a JavaScript object:\n\t//\t|\trequire([\"dojo/cookie\", \"dojo/json\"], function(cookie, json){\n\t//\t|\t\tconfig = json.parse(cookie(\"configObj\"));\n\t//\t|\t});\n\t//\n\t// example:\n\t//\t\tdelete a cookie:\n\t//\t|\trequire([\"dojo/cookie\"], function(cookie){\n\t//\t|\t\tcookie(\"configObj\", null, {expires: -1});\n\t//\t|\t});\n\tvar c = document.cookie, ret;\n\tif(arguments.length == 1){\n\t\tvar matches = c.match(new RegExp(\"(?:^|; )\" + regexp.escapeString(name) + \"=([^;]*)\"));\n\t\tret = matches ? decodeURIComponent(matches[1]) : undefined; \n\t}else{\n\t\tprops = props || {};\n// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?\n\t\tvar exp = props.expires;\n\t\tif(typeof exp == \"number\"){\n\t\t\tvar d = new Date();\n\t\t\td.setTime(d.getTime() + exp*24*60*60*1000);\n\t\t\texp = props.expires = d;\n\t\t}\n\t\tif(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }\n\n\t\tvalue = encodeURIComponent(value);\n\t\tvar updatedCookie = name + \"=\" + value, propName;\n\t\tfor(propName in props){\n\t\t\tupdatedCookie += \"; \" + propName;\n\t\t\tvar propValue = props[propName];\n\t\t\tif(propValue !== true){ updatedCookie += \"=\" + propValue; }\n\t\t}\n\t\tdocument.cookie = updatedCookie;\n\t}\n\treturn ret; // String|undefined\n};\n\ndojo.cookie.isSupported = function(){\n\t// summary:\n\t//\t\tUse to determine if the current browser supports cookies or not.\n\t//\n\t//\t\tReturns true if user allows cookies.\n\t//\t\tReturns false if user doesn't allow cookies.\n\n\tif(!(\"cookieEnabled\" in navigator)){\n\t\tthis(\"__djCookieTest__\", \"CookiesAllowed\");\n\t\tnavigator.cookieEnabled = this(\"__djCookieTest__\") == \"CookiesAllowed\";\n\t\tif(navigator.cookieEnabled){\n\t\t\tthis(\"__djCookieTest__\", \"\", {expires: -1});\n\t\t}\n\t}\n\treturn navigator.cookieEnabled;\n};\n\nreturn dojo.cookie;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/currency.js":"define([\n\t\"./_base/array\",\n\t\"./_base/lang\",\n\t/*===== \"./_base/declare\", =====*/\n\t\"./number\",\n\t\"./i18n\", \"./i18n!./cldr/nls/currency\",\n\t\"./cldr/monetary\"\n], function(darray, lang, /*===== declare, =====*/ dnumber, i18n, nlsCurrency, cldrMonetary){\n\n// module:\n//\t\tdojo/currency\n\nvar currency = {\n\t// summary:\n\t//\t\tlocalized formatting and parsing routines for currencies\n\t// description:\n\t//\t\textends dojo.number to provide culturally-appropriate formatting of values\n\t//\t\tin various world currencies, including use of a currency symbol.  The currencies are specified\n\t//\t\tby a three-letter international symbol in all uppercase, and support for the currencies is\n\t//\t\tprovided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which\n\t//\t\tcurrency support is included.  A fixed number of decimal places is determined based\n\t//\t\ton the currency type and is not determined by the 'pattern' argument.  The fractional\n\t//\t\tportion is optional, by default, and variable length decimals are not supported.\n};\nlang.setObject(\"dojo.currency\", currency);\n\ncurrency._mixInDefaults = function(options){\n\toptions = options || {};\n\toptions.type = \"currency\";\n\n\t// Get locale-dependent currency data, like the symbol\n\tvar bundle = i18n.getLocalization(\"dojo.cldr\", \"currency\", options.locale) || {};\n\n\t// Mixin locale-independent currency data, like # of places\n\tvar iso = options.currency;\n\tvar data = cldrMonetary.getData(iso);\n\n\tdarray.forEach([\"displayName\",\"symbol\",\"group\",\"decimal\"], function(prop){\n\t\tdata[prop] = bundle[iso+\"_\"+prop];\n\t});\n\n\tdata.fractional = [true, false];\n\n\t// Mixin with provided options\n\treturn lang.mixin(data, options);\n};\n\n/*=====\ncurrency.__FormatOptions = declare([dnumber.__FormatOptions], {\n\t// type: String?\n\t//\t\tShould not be set.  Value is assumed to be \"currency\".\n\t// symbol: String?\n\t//\t\tlocalized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`\n\t//\t\tA [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.\n\t// currency: String?\n\t//\t\tan [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like \"USD\".\n\t//\t\tFor use with dojo.currency only.\n\t// places: Number?\n\t//\t\tnumber of decimal places to show.  Default is defined based on which currency is used.\n\ttype: \"\",\n\tsymbol: \"\",\n\tcurrency: \"\",\n\tplaces: \"\"\n});\n=====*/\n\ncurrency.format = function(/*Number*/ value, /*__FormatOptions?*/ options){\n\t// summary:\n\t//\t\tFormat a Number as a currency, using locale-specific settings\n\t//\n\t// description:\n\t//\t\tCreate a string from a Number using a known, localized pattern.\n\t//\t\t[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)\n\t//\t\tappropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)\n\t//\t\tas well as the appropriate symbols and delimiters and number of decimal places.\n\t//\n\t// value:\n\t//\t\tthe number to be formatted.\n\n\treturn dnumber.format(value, currency._mixInDefaults(options));\n};\n\ncurrency.regexp = function(/*dnumber.__RegexpOptions?*/ options){\n\t//\n\t// summary:\n\t//\t\tBuilds the regular needed to parse a currency value\n\t//\n\t// description:\n\t//\t\tReturns regular expression with positive and negative match, group and decimal separators\n\t//\t\tNote: the options.places default, the number of decimal places to accept, is defined by the currency type.\n\treturn dnumber.regexp(currency._mixInDefaults(options)); // String\n};\n\n/*=====\nvar __ParseOptions = currency.__ParseOptions = declare(dnumber.__ParseOptions, {\n\t// type: String?\n\t//\t\tShould not be set.  Value is assumed to be currency.\n\t// currency: String?\n\t//\t\tan [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like \"USD\".\n\t//\t\tFor use with dojo.currency only.\n\t// symbol: String?\n\t//\t\tlocalized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`\n\t//\t\tA [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.\n\t// places: Number?\n\t//\t\tfixed number of decimal places to accept.  The default is determined based on which currency is used.\n\t// fractional: Boolean|Array?\n\t//\t\tWhether to include the fractional portion, where the number of decimal places are implied by the currency\n\t//\t\tor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.\n\t//\t\tBy default for currencies, it the fractional portion is optional.\n});\n=====*/\n\ncurrency.parse = function(/*String*/ expression, /*__ParseOptions?*/ options){\n\t//\n\t// summary:\n\t//\t\tConvert a properly formatted currency string to a primitive Number,\n\t//\t\tusing locale-specific settings.\n\t// description:\n\t//\t\tCreate a Number from a string using a known, localized pattern.\n\t//\t\t[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n\t//\t\tare chosen appropriate to the locale, as well as the appropriate symbols and delimiters\n\t//\t\tand number of decimal places.\n\t// expression:\n\t//\t\tA string representation of a currency value\n\n\treturn dnumber.parse(expression, currency._mixInDefaults(options));\n};\n\nreturn currency;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/date.js":"define([\"./has\", \"./_base/lang\"], function(has, lang){\n// module:\n//\t\tdojo/date\n\nvar date = {\n\t// summary:\n\t//\t\tDate manipulation utilities\n};\n\ndate.getDaysInMonth = function(/*Date*/dateObject){\n\t// summary:\n\t//\t\tReturns the number of days in the month used by dateObject\n\tvar month = dateObject.getMonth();\n\tvar days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\tif(month == 1 && date.isLeapYear(dateObject)){ return 29; } // Number\n\treturn days[month]; // Number\n};\n\ndate.isLeapYear = function(/*Date*/dateObject){\n\t// summary:\n\t//\t\tDetermines if the year of the dateObject is a leap year\n\t// description:\n\t//\t\tLeap years are years with an additional day YYYY-02-29, where the\n\t//\t\tyear number is a multiple of four with the following exception: If\n\t//\t\ta year is a multiple of 100, then it is only a leap year if it is\n\t//\t\talso a multiple of 400. For example, 1900 was not a leap year, but\n\t//\t\t2000 is one.\n\n\tvar year = dateObject.getFullYear();\n\treturn !(year%400) || (!(year%4) && !!(year%100)); // Boolean\n};\n\n// FIXME: This is not localized\ndate.getTimezoneName = function(/*Date*/dateObject){\n\t// summary:\n\t//\t\tGet the user's time zone as provided by the browser\n\t// dateObject:\n\t//\t\tNeeded because the timezone may vary with time (daylight savings)\n\t// description:\n\t//\t\tTry to get time zone info from toString or toLocaleString method of\n\t//\t\tthe Date object -- UTC offset is not a time zone.  See\n\t//\t\thttp://www.twinsun.com/tz/tz-link.htm Note: results may be\n\t//\t\tinconsistent across browsers.\n\n\tvar str = dateObject.toString(); // Start looking in toString\n\tvar tz = ''; // The result -- return empty string if nothing found\n\tvar match;\n\n\t// First look for something in parentheses -- fast lookup, no regex\n\tvar pos = str.indexOf('(');\n\tif(pos > -1){\n\t\ttz = str.substring(++pos, str.indexOf(')'));\n\t}else{\n\t\t// If at first you don't succeed ...\n\t\t// If IE knows about the TZ, it appears before the year\n\t\t// Capital letters or slash before a 4-digit year\n\t\t// at the end of string\n\t\tvar pat = /([A-Z\\/]+) \\d{4}$/;\n\t\tif((match = str.match(pat))){\n\t\t\ttz = match[1];\n\t\t}else{\n\t\t// Some browsers (e.g. Safari) glue the TZ on the end\n\t\t// of toLocaleString instead of putting it in toString\n\t\t\tstr = dateObject.toLocaleString();\n\t\t\t// Capital letters or slash -- end of string,\n\t\t\t// after space\n\t\t\tpat = / ([A-Z\\/]+)$/;\n\t\t\tif((match = str.match(pat))){\n\t\t\t\ttz = match[1];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure it doesn't somehow end up return AM or PM\n\treturn (tz == 'AM' || tz == 'PM') ? '' : tz; // String\n};\n\n// Utility methods to do arithmetic calculations with Dates\n\ndate.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){\n\t// summary:\n\t//\t\tCompare two date objects by date, time, or both.\n\t// description:\n\t//\t\tReturns 0 if equal, positive if a > b, else negative.\n\t// date1:\n\t//\t\tDate object\n\t// date2:\n\t//\t\tDate object.  If not specified, the current Date is used.\n\t// portion:\n\t//\t\tA string indicating the \"date\" or \"time\" portion of a Date object.\n\t//\t\tCompares both \"date\" and \"time\" by default.  One of the following:\n\t//\t\t\"date\", \"time\", \"datetime\"\n\n\t// Extra step required in copy for IE - see #3112\n\tdate1 = new Date(+date1);\n\tdate2 = new Date(+(date2 || new Date()));\n\n\tif(portion == \"date\"){\n\t\t// Ignore times and compare dates.\n\t\tdate1.setHours(0, 0, 0, 0);\n\t\tdate2.setHours(0, 0, 0, 0);\n\t}else if(portion == \"time\"){\n\t\t// Ignore dates and compare times.\n\t\tdate1.setFullYear(0, 0, 0);\n\t\tdate2.setFullYear(0, 0, 0);\n\t}\n\n\tif(date1 > date2){ return 1; } // int\n\tif(date1 < date2){ return -1; } // int\n\treturn 0; // int\n};\n\ndate.add = function(/*Date*/date, /*String*/interval, /*int*/amount){\n\t// summary:\n\t//\t\tAdd to a Date in intervals of different size, from milliseconds to years\n\t// date: Date\n\t//\t\tDate object to start with\n\t// interval:\n\t//\t\tA string representing the interval.  One of the following:\n\t//\t\t\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\",\n\t//\t\t\"millisecond\", \"quarter\", \"week\", \"weekday\"\n\t// amount:\n\t//\t\tHow much to add to the date.\n\n\tvar sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)\n\tvar fixOvershoot = false;\n\tvar property = \"Date\";\n\n\tswitch(interval){\n\t\tcase \"day\":\n\t\t\tbreak;\n\t\tcase \"weekday\":\n\t\t\t//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo/cldr/supplemental\n\n\t\t\t// Divide the increment time span into weekspans plus leftover days\n\t\t\t// e.g., 8 days is one 5-day weekspan / and two leftover days\n\t\t\t// Can't have zero leftover days, so numbers divisible by 5 get\n\t\t\t// a days value of 5, and the remaining days make up the number of weeks\n\t\t\tvar days, weeks;\n\t\t\tvar mod = amount % 5;\n\t\t\tif(!mod){\n\t\t\t\tdays = (amount > 0) ? 5 : -5;\n\t\t\t\tweeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);\n\t\t\t}else{\n\t\t\t\tdays = mod;\n\t\t\t\tweeks = parseInt(amount/5);\n\t\t\t}\n\t\t\t// Get weekday value for orig date param\n\t\t\tvar strt = date.getDay();\n\t\t\t// Orig date is Sat / positive incrementer\n\t\t\t// Jump over Sun\n\t\t\tvar adj = 0;\n\t\t\tif(strt == 6 && amount > 0){\n\t\t\t\tadj = 1;\n\t\t\t}else if(strt == 0 && amount < 0){\n\t\t\t// Orig date is Sun / negative incrementer\n\t\t\t// Jump back over Sat\n\t\t\t\tadj = -1;\n\t\t\t}\n\t\t\t// Get weekday val for the new date\n\t\t\tvar trgt = strt + days;\n\t\t\t// New date is on Sat or Sun\n\t\t\tif(trgt == 0 || trgt == 6){\n\t\t\t\tadj = (amount > 0) ? 2 : -2;\n\t\t\t}\n\t\t\t// Increment by number of weeks plus leftover days plus\n\t\t\t// weekend adjustments\n\t\t\tamount = (7 * weeks) + days + adj;\n\t\t\tbreak;\n\t\tcase \"year\":\n\t\t\tproperty = \"FullYear\";\n\t\t\t// Keep increment/decrement from 2/29 out of March\n\t\t\tfixOvershoot = true;\n\t\t\tbreak;\n\t\tcase \"week\":\n\t\t\tamount *= 7;\n\t\t\tbreak;\n\t\tcase \"quarter\":\n\t\t\t// Naive quarter is just three months\n\t\t\tamount *= 3;\n\t\t\t// fallthrough...\n\t\tcase \"month\":\n\t\t\t// Reset to last day of month if you overshoot\n\t\t\tfixOvershoot = true;\n\t\t\tproperty = \"Month\";\n\t\t\tbreak;\n//\t\tcase \"hour\":\n//\t\tcase \"minute\":\n//\t\tcase \"second\":\n//\t\tcase \"millisecond\":\n\t\tdefault:\n\t\t\tproperty = \"UTC\"+interval.charAt(0).toUpperCase() + interval.substring(1) + \"s\";\n\t}\n\n\tif(property){\n\t\tsum[\"set\"+property](sum[\"get\"+property]()+amount);\n\t}\n\n\tif(fixOvershoot && (sum.getDate() < date.getDate())){\n\t\tsum.setDate(0);\n\t}\n\n\treturn sum; // Date\n};\n\ndate.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){\n\t// summary:\n\t//\t\tGet the difference in a specific unit of time (e.g., number of\n\t//\t\tmonths, weeks, days, etc.) between two dates, rounded to the\n\t//\t\tnearest integer.\n\t// date1:\n\t//\t\tDate object\n\t// date2:\n\t//\t\tDate object.  If not specified, the current Date is used.\n\t// interval:\n\t//\t\tA string representing the interval.  One of the following:\n\t//\t\t\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\",\n\t//\t\t\"millisecond\", \"quarter\", \"week\", \"weekday\"\n\t//\n\t//\t\tDefaults to \"day\".\n\n\tdate2 = date2 || new Date();\n\tinterval = interval || \"day\";\n\tvar yearDiff = date2.getFullYear() - date1.getFullYear();\n\tvar delta = 1; // Integer return value\n\n\tswitch(interval){\n\t\tcase \"quarter\":\n\t\t\tvar m1 = date1.getMonth();\n\t\t\tvar m2 = date2.getMonth();\n\t\t\t// Figure out which quarter the months are in\n\t\t\tvar q1 = Math.floor(m1/3) + 1;\n\t\t\tvar q2 = Math.floor(m2/3) + 1;\n\t\t\t// Add quarters for any year difference between the dates\n\t\t\tq2 += (yearDiff * 4);\n\t\t\tdelta = q2 - q1;\n\t\t\tbreak;\n\t\tcase \"weekday\":\n\t\t\tvar days = Math.round(date.difference(date1, date2, \"day\"));\n\t\t\tvar weeks = parseInt(date.difference(date1, date2, \"week\"));\n\t\t\tvar mod = days % 7;\n\n\t\t\t// Even number of weeks\n\t\t\tif(mod == 0){\n\t\t\t\tdays = weeks*5;\n\t\t\t}else{\n\t\t\t\t// Weeks plus spare change (< 7 days)\n\t\t\t\tvar adj = 0;\n\t\t\t\tvar aDay = date1.getDay();\n\t\t\t\tvar bDay = date2.getDay();\n\n\t\t\t\tweeks = parseInt(days/7);\n\t\t\t\tmod = days % 7;\n\t\t\t\t// Mark the date advanced by the number of\n\t\t\t\t// round weeks (may be zero)\n\t\t\t\tvar dtMark = new Date(date1);\n\t\t\t\tdtMark.setDate(dtMark.getDate()+(weeks*7));\n\t\t\t\tvar dayMark = dtMark.getDay();\n\n\t\t\t\t// Spare change days -- 6 or less\n\t\t\t\tif(days > 0){\n\t\t\t\t\tswitch(true){\n\t\t\t\t\t\t// Range starts on Sat\n\t\t\t\t\t\tcase aDay == 6:\n\t\t\t\t\t\t\tadj = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range starts on Sun\n\t\t\t\t\t\tcase aDay == 0:\n\t\t\t\t\t\t\tadj = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range ends on Sat\n\t\t\t\t\t\tcase bDay == 6:\n\t\t\t\t\t\t\tadj = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range ends on Sun\n\t\t\t\t\t\tcase bDay == 0:\n\t\t\t\t\t\t\tadj = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range contains weekend\n\t\t\t\t\t\tcase (dayMark + mod) > 5:\n\t\t\t\t\t\t\tadj = -2;\n\t\t\t\t\t}\n\t\t\t\t}else if(days < 0){\n\t\t\t\t\tswitch(true){\n\t\t\t\t\t\t// Range starts on Sat\n\t\t\t\t\t\tcase aDay == 6:\n\t\t\t\t\t\t\tadj = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range starts on Sun\n\t\t\t\t\t\tcase aDay == 0:\n\t\t\t\t\t\t\tadj = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range ends on Sat\n\t\t\t\t\t\tcase bDay == 6:\n\t\t\t\t\t\t\tadj = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range ends on Sun\n\t\t\t\t\t\tcase bDay == 0:\n\t\t\t\t\t\t\tadj = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Range contains weekend\n\t\t\t\t\t\tcase (dayMark + mod) < 0:\n\t\t\t\t\t\t\tadj = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdays += adj;\n\t\t\t\tdays -= (weeks*2);\n\t\t\t}\n\t\t\tdelta = days;\n\t\t\tbreak;\n\t\tcase \"year\":\n\t\t\tdelta = yearDiff;\n\t\t\tbreak;\n\t\tcase \"month\":\n\t\t\tdelta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);\n\t\t\tbreak;\n\t\tcase \"week\":\n\t\t\t// Truncate instead of rounding\n\t\t\t// Don't use Math.floor -- value may be negative\n\t\t\tdelta = parseInt(date.difference(date1, date2, \"day\")/7);\n\t\t\tbreak;\n\t\tcase \"day\":\n\t\t\tdelta /= 24;\n\t\t\t// fallthrough\n\t\tcase \"hour\":\n\t\t\tdelta /= 60;\n\t\t\t// fallthrough\n\t\tcase \"minute\":\n\t\t\tdelta /= 60;\n\t\t\t// fallthrough\n\t\tcase \"second\":\n\t\t\tdelta /= 1000;\n\t\t\t// fallthrough\n\t\tcase \"millisecond\":\n\t\t\tdelta *= date2.getTime() - date1.getTime();\n\t}\n\n\t// Round for fractional values and DST leaps\n\treturn Math.round(delta); // Number (integer)\n};\n\n// Don't use setObject() because it may overwrite dojo/date/stamp (if that has already been loaded)\nhas(\"extend-dojo\") && lang.mixin(lang.getObject(\"dojo.date\", true), date);\n\nreturn date;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/Deferred.js":"define([\n\t\"./has\",\n\t\"./_base/lang\",\n\t\"./errors/CancelError\",\n\t\"./promise/Promise\",\n\t\"./has!config-deferredInstrumentation?./promise/instrumentation\"\n], function(has, lang, CancelError, Promise, instrumentation){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/Deferred\n\n\tvar PROGRESS = 0,\n\t\t\tRESOLVED = 1,\n\t\t\tREJECTED = 2;\n\tvar FULFILLED_ERROR_MESSAGE = \"This deferred has already been fulfilled.\";\n\n\tvar freezeObject = Object.freeze || function(){};\n\n\tvar signalWaiting = function(waiting, type, result, rejection, deferred){\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){\n\t\t\t\tDeferred.instrumentRejected(result, false, rejection, deferred);\n\t\t\t}\n\t\t}\n\n\t\tfor(var i = 0; i < waiting.length; i++){\n\t\t\tsignalListener(waiting[i], type, result, rejection);\n\t\t}\n\t};\n\n\tvar signalListener = function(listener, type, result, rejection){\n\t\tvar func = listener[type];\n\t\tvar deferred = listener.deferred;\n\t\tif(func){\n\t\t\ttry{\n\t\t\t\tvar newResult = func(result);\n\t\t\t\tif(type === PROGRESS){\n\t\t\t\t\tif(typeof newResult !== \"undefined\"){\n\t\t\t\t\t\tsignalDeferred(deferred, type, newResult);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(newResult && typeof newResult.then === \"function\"){\n\t\t\t\t\t\tlistener.cancel = newResult.cancel;\n\t\t\t\t\t\tnewResult.then(\n\t\t\t\t\t\t\t\t// Only make resolvers if they're actually going to be used\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, RESOLVED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, REJECTED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, PROGRESS));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsignalDeferred(deferred, RESOLVED, newResult);\n\t\t\t\t}\n\t\t\t}catch(error){\n\t\t\t\tsignalDeferred(deferred, REJECTED, error);\n\t\t\t}\n\t\t}else{\n\t\t\tsignalDeferred(deferred, type, result);\n\t\t}\n\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected){\n\t\t\t\tDeferred.instrumentRejected(result, !!func, rejection, deferred.promise);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar makeDeferredSignaler = function(deferred, type){\n\t\treturn function(value){\n\t\t\tsignalDeferred(deferred, type, value);\n\t\t};\n\t};\n\n\tvar signalDeferred = function(deferred, type, result){\n\t\tif(!deferred.isCanceled()){\n\t\t\tswitch(type){\n\t\t\t\tcase PROGRESS:\n\t\t\t\t\tdeferred.progress(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RESOLVED:\n\t\t\t\t\tdeferred.resolve(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REJECTED:\n\t\t\t\t\tdeferred.reject(result);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar Deferred = function(canceler){\n\t\t// summary:\n\t\t//\t\tCreates a new deferred. This API is preferred over\n\t\t//\t\t`dojo/_base/Deferred`.\n\t\t// description:\n\t\t//\t\tCreates a new deferred, as an abstraction over (primarily)\n\t\t//\t\tasynchronous operations. The deferred is the private interface\n\t\t//\t\tthat should not be returned to calling code. That's what the\n\t\t//\t\t`promise` is for. See `dojo/promise/Promise`.\n\t\t// canceler: Function?\n\t\t//\t\tWill be invoked if the deferred is canceled. The canceler\n\t\t//\t\treceives the reason the deferred was canceled as its argument.\n\t\t//\t\tThe deferred is rejected with its return value, or a new\n\t\t//\t\t`dojo/errors/CancelError` instance.\n\n\t\t// promise: dojo/promise/Promise\n\t\t//\t\tThe public promise object that clients can add callbacks to. \n\t\tvar promise = this.promise = new Promise();\n\n\t\tvar deferred = this;\n\t\tvar fulfilled, result, rejection;\n\t\tvar canceled = false;\n\t\tvar waiting = [];\n\n\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\tError.captureStackTrace(deferred, Deferred);\n\t\t\tError.captureStackTrace(promise, Deferred);\n\t\t}\n\n\t\tthis.isResolved = promise.isResolved = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === RESOLVED;\n\t\t};\n\n\t\tthis.isRejected = promise.isRejected = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === REJECTED;\n\t\t};\n\n\t\tthis.isFulfilled = promise.isFulfilled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved or rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn !!fulfilled;\n\t\t};\n\n\t\tthis.isCanceled = promise.isCanceled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been canceled.\n\t\t\t// returns: Boolean\n\n\t\t\treturn canceled;\n\t\t};\n\n\t\tthis.progress = function(update, strict){\n\t\t\t// summary:\n\t\t\t//\t\tEmit a progress update on the deferred.\n\t\t\t// description:\n\t\t\t//\t\tEmit a progress update on the deferred. Progress updates\n\t\t\t//\t\tcan be used to communicate updates about the asynchronous\n\t\t\t//\t\toperation before it has finished.\n\t\t\t// update: any\n\t\t\t//\t\tThe progress update. Passed to progbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently no progress can be emitted.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tsignalWaiting(waiting, PROGRESS, update, null, deferred);\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.resolve = function(value, strict){\n\t\t\t// summary:\n\t\t\t//\t\tResolve the deferred.\n\t\t\t// description:\n\t\t\t//\t\tResolve the deferred, putting it in a success state.\n\t\t\t// value: any\n\t\t\t//\t\tThe result of the deferred. Passed to callbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be resolved.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Set fulfilled, store value. After signaling waiting listeners unset\n\t\t\t\t// waiting.\n\t\t\t\tsignalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tvar reject = this.reject = function(error, strict){\n\t\t\t// summary:\n\t\t\t//\t\tReject the deferred.\n\t\t\t// description:\n\t\t\t//\t\tReject the deferred, putting it in an error state.\n\t\t\t// error: any\n\t\t\t//\t\tThe error result of the deferred. Passed to errbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be rejected.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\t\t\tError.captureStackTrace(rejection = {}, reject);\n\t\t\t\t}\n\t\t\t\tsignalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.then = promise.then = function(callback, errback, progback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new callbacks to the deferred.\n\t\t\t// description:\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\n\t\t\t//\t\tReceives the resolution value.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t//\t\tReceives the rejection error.\n\t\t\t// progback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\n\t\t\t//\t\tupdate. Receives the progress update.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\n\n\t\t\tvar listener = [progback, callback, errback];\n\t\t\t// Ensure we cancel the promise we're waiting for, or if callback/errback\n\t\t\t// have returned a promise, cancel that one.\n\t\t\tlistener.cancel = promise.cancel;\n\t\t\tlistener.deferred = new Deferred(function(reason){\n\t\t\t\t// Check whether cancel is really available, returned promises are not\n\t\t\t\t// required to expose `cancel`\n\t\t\t\treturn listener.cancel && listener.cancel(reason);\n\t\t\t});\n\t\t\tif(fulfilled && !waiting){\n\t\t\t\tsignalListener(listener, fulfilled, result, rejection);\n\t\t\t}else{\n\t\t\t\twaiting.push(listener);\n\t\t\t}\n\t\t\treturn listener.deferred.promise;\n\t\t};\n\n\t\tthis.cancel = promise.cancel = function(reason, strict){\n\t\t\t// summary:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t// description:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\n\t\t\t//\t\tpromises that originate with the same deferred.\n\t\t\t// reason: any\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\n\t\t\t//\t\texplaining why it's being canceled.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\n\t\t\t// returns: any\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\n\t\t\t//\t\tnormally.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Cancel can be called even after the deferred is fulfilled\n\t\t\t\tif(canceler){\n\t\t\t\t\tvar returnedReason = canceler(reason);\n\t\t\t\t\treason = typeof returnedReason === \"undefined\" ? reason : returnedReason;\n\t\t\t\t}\n\t\t\t\tcanceled = true;\n\t\t\t\tif(!fulfilled){\n\t\t\t\t\t// Allow canceler to provide its own reason, but fall back to a CancelError\n\t\t\t\t\tif(typeof reason === \"undefined\"){\n\t\t\t\t\t\treason = new CancelError();\n\t\t\t\t\t}\n\t\t\t\t\treject(reason);\n\t\t\t\t\treturn reason;\n\t\t\t\t}else if(fulfilled === REJECTED && result === reason){\n\t\t\t\t\treturn reason;\n\t\t\t\t}\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}\n\t\t};\n\n\t\tfreezeObject(promise);\n\t};\n\n\tDeferred.prototype.toString = function(){\n\t\t// returns: String\n\t\t//\t\tReturns `[object Deferred]`.\n\n\t\treturn \"[object Deferred]\";\n\t};\n\n\tif(instrumentation){\n\t\tinstrumentation(Deferred);\n\t}\n\n\treturn Deferred;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/DeferredList.js":"define([\"./_base/kernel\", \"./_base/Deferred\", \"./_base/array\"], function(dojo, Deferred, darray){\n\t// module:\n\t//\t\tdojo/DeferredList\n\n\ndojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){\n\t// summary:\n\t//\t\tDeprecated, use dojo/promise/all instead.\n\t//\t\tProvides event handling for a group of Deferred objects.\n\t// description:\n\t//\t\tDeferredList takes an array of existing deferreds and returns a new deferred of its own\n\t//\t\tthis new deferred will typically have its callback fired when all of the deferreds in\n\t//\t\tthe given list have fired their own deferreds.  The parameters `fireOnOneCallback` and\n\t//\t\tfireOnOneErrback, will fire before all the deferreds as appropriate\n\t// list:\n\t//\t\tThe list of deferreds to be synchronizied with this DeferredList\n\t// fireOnOneCallback:\n\t//\t\tWill cause the DeferredLists callback to be fired as soon as any\n\t//\t\tof the deferreds in its list have been fired instead of waiting until\n\t//\t\tthe entire list has finished\n\t// fireonOneErrback:\n\t//\t\tWill cause the errback to fire upon any of the deferreds errback\n\t// canceller:\n\t//\t\tA deferred canceller function, see dojo.Deferred\n\tvar resultList = [];\n\tDeferred.call(this);\n\tvar self = this;\n\tif(list.length === 0 && !fireOnOneCallback){\n\t\tthis.resolve([0, []]);\n\t}\n\tvar finished = 0;\n\tdarray.forEach(list, function(item, i){\n\t\titem.then(function(result){\n\t\t\tif(fireOnOneCallback){\n\t\t\t\tself.resolve([i, result]);\n\t\t\t}else{\n\t\t\t\taddResult(true, result);\n\t\t\t}\n\t\t},function(error){\n\t\t\tif(fireOnOneErrback){\n\t\t\t\tself.reject(error);\n\t\t\t}else{\n\t\t\t\taddResult(false, error);\n\t\t\t}\n\t\t\tif(consumeErrors){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow error;\n\t\t});\n\t\tfunction addResult(succeeded, result){\n\t\t\tresultList[i] = [succeeded, result];\n\t\t\tfinished++;\n\t\t\tif(finished === list.length){\n\t\t\t\tself.resolve(resultList);\n\t\t\t}\n\n\t\t}\n\t});\n};\ndojo.DeferredList.prototype = new Deferred();\n\ndojo.DeferredList.prototype.gatherResults = function(deferredList){\n\t// summary:\n\t//\t\tGathers the results of the deferreds for packaging\n\t//\t\tas the parameters to the Deferred Lists' callback\n\t// deferredList: dojo/DeferredList\n\t//\t\tThe deferred list from which this function gathers results.\n\t// returns: dojo/DeferredList\n\t//\t\tThe newly created deferred list which packs results as\n\t//\t\tparameters to its callback.\n\n\tvar d = new dojo.DeferredList(deferredList, false, true, false);\n\td.addCallback(function(results){\n\t\tvar ret = [];\n\t\tdarray.forEach(results, function(result){\n\t\t\tret.push(result[1]);\n\t\t});\n\t\treturn ret;\n\t});\n\treturn d;\n};\n\nreturn dojo.DeferredList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dojo.js":"(function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\n\t// define a minimal library to help build the loader\n\tvar\tnoop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = this,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\thas.add(\"host-node\", userConfig.has && \"host-node\" in userConfig.has ?\n\t\tuserConfig.has[\"host-node\"] :\n\t\t(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\tif(has(\"host-node\")){\n\t\t// fixup the default config for node.js environment\n\t\trequire(\"./_base/configNode.js\").config(defaultConfig);\n\t\t// remember node's require (with respect to baseUrl==dojo's root)\n\t\tdefaultConfig.loaderPatch.nodeRequire = require;\n\t}\n\n\thas.add(\"host-rhino\", userConfig.has && \"host-rhino\" in userConfig.has ?\n\t\tuserConfig.has[\"host-rhino\"] :\n\t\t(typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\tif(has(\"host-rhino\")){\n\t\t// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...\n\t\tfor(var baseUrl = userConfig.baseUrl || \".\", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){\n\t\t\targ = (rhinoArgs[i++] + \"\").split(\"=\");\n\t\t\tif(arg[0] == \"baseUrl\"){\n\t\t\t\tbaseUrl = arg[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tload(baseUrl + \"/_base/configRhino.js\");\n\t\trhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);\n\t}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar\trequested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif(has(\"dojo-trace-api\")){\n\t\t// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code\n\t\trequested = \"requested\";\n\t\tarrived = \"arrived\";\n\t\tnonmodule = \"not-a-module\";\n\t\texecuting = \"executing\";\n\t\texecuted = \"executed\";\n\t}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif(has(\"dojo-sync-loader\")){\n\t\treq.isXdUrl = noop;\n\n\t\treq.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){\n\t\t\t// the first dojo/_base/loader loaded gets to define these variables; they are designed to work\n\t\t\t// in the presence of zero to many mapped dojo/_base/loaders\n\t\t\tif(!dojoRequirePlugin){\n\t\t\t\tdojoRequirePlugin = dojoRequirePlugin_;\n\t\t\t\tcheckDojoRequirePlugin = checkDojoRequirePlugin_;\n\t\t\t\ttransformToAmd = transformToAmd_;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsync:sync,\n\t\t\t\trequested:requested,\n\t\t\t\tarrived:arrived,\n\t\t\t\tnonmodule:nonmodule,\n\t\t\t\texecuting:executing,\n\t\t\t\texecuted:executed,\n\t\t\t\tsyncExecStack:syncExecStack,\n\t\t\t\tmodules:modules,\n\t\t\t\texecQ:execQ,\n\t\t\t\tgetModule:getModule,\n\t\t\t\tinjectModule:injectModule,\n\t\t\t\tsetArrived:setArrived,\n\t\t\t\tsignal:signal,\n\t\t\t\tfinishExec:finishExec,\n\t\t\t\texecModule:execModule,\n\t\t\t\tdojoRequirePlugin:dojoRequirePlugin,\n\t\t\t\tgetLegacyMode:function(){return legacyMode;},\n\t\t\t\tguardCheckComplete:guardCheckComplete\n\t\t\t};\n\t\t};\n\n\t\tif(has(\"dom\")){\n\t\t\t// in legacy sync mode, the loader needs a minimal XHR library\n\n\t\t\tvar locationProtocol = location.protocol,\n\t\t\t\tlocationHost = location.host;\n\t\t\treq.isXdUrl = function(url){\n\t\t\t\tif(/^\\./.test(url)){\n\t\t\t\t\t// begins with a dot is always relative to page URL; therefore not xdomain\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(/^\\/\\//.test(url)){\n\t\t\t\t\t// for v1.6- backcompat, url starting with // indicates xdomain\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// get protocol and host\n\t\t\t\t// \\/+ takes care of the typical file protocol that looks like file:///drive/path/to/file\n\t\t\t\t// locationHost is falsy if file protocol => if locationProtocol matches and is \"file:\", || will return false\n\t\t\t\tvar match = url.match(/^([^\\/\\:]+\\:)\\/+([^\\/]+)/);\n\t\t\t\treturn match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));\n\t\t\t};\n\n\n\t\t\t// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config\n\t\t\thas.add(\"dojo-xhr-factory\", 1);\n\t\t\thas.add(\"dojo-force-activex-xhr\", has(\"host-browser\") && !doc.addEventListener && window.location.protocol == \"file:\");\n\t\t\thas.add(\"native-xhr\", typeof XMLHttpRequest != \"undefined\");\n\t\t\tif(has(\"native-xhr\") && !has(\"dojo-force-activex-xhr\")){\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new XMLHttpRequest();\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// if in the browser an old IE; find an xhr\n\t\t\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\t\t\tif(new ActiveXObject(progid)){\n\t\t\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch; we're just trying to find a good ActiveX progid\n\t\t\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t};\n\t\t\t}\n\t\t\treq.getXhr = getXhr;\n\n\t\t\thas.add(\"dojo-gettext-api\", 1);\n\t\t\treq.getText = function(url, async, onLoad){\n\t\t\t\tvar xhr = getXhr();\n\t\t\t\txhr.open('GET', fixupUrl(url), false);\n\t\t\t\txhr.send(null);\n\t\t\t\tif(xhr.status == 200 || (!location.host && !xhr.status)){\n\t\t\t\t\tif(onLoad){\n\t\t\t\t\t\tonLoad(xhr.responseText, async);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthrow makeError(\"xhrFailed\", xhr.status);\n\t\t\t\t}\n\t\t\t\treturn xhr.responseText;\n\t\t\t};\n\t\t}\n\t}else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tnew Function('return eval(arguments[0]);');\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n////@ sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif(has(\"dojo-config-api\")){\n\t\tvar consumePendingCacheInsert = function(referenceModule){\n\t\t\t\tvar p, item, match, now, m;\n\t\t\t\tfor(p in pendingCacheInsert){\n\t\t\t\t\titem = pendingCacheInsert[p];\n\t\t\t\t\tmatch = p.match(/^url\\:(.+)/);\n\t\t\t\t\tif(match){\n\t\t\t\t\t\tcache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;\n\t\t\t\t\t}else if(p==\"*now\"){\n\t\t\t\t\t\tnow = item;\n\t\t\t\t\t}else if(p!=\"*noref\"){\n\t\t\t\t\t\tm = getModuleInfo(p, referenceModule, true);\n\t\t\t\t\t\tcache[m.mid] = cache[urlKeyPrefix + m.url] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(now){\n\t\t\t\t\tnow(createRequire(referenceModule));\n\t\t\t\t}\n\t\t\t\tpendingCacheInsert = {};\n\t\t\t},\n\n\t\t\tescapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevant to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tcomputeAliases = function(config, dest){\n\t\t\t\tforEach(config, function(pair){\n\t\t\t\t\t// take a fixed-up copy...\n\t\t\t\t\tdest.push([isString(pair[0]) ? new RegExp(\"^\" + escapeString(pair[0]) + \"$\") : pair[0], pair[1]]);\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is deprecated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consumed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif(has(\"dojo-sync-loader\") && p==\"async\"){\n\t\t\t\t\t\t// falsy or \"sync\" => legacy sync loader\n\t\t\t\t\t\t// \"xd\" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)\n\t\t\t\t\t\t// \"legacyAsync\" => permanently in \"xd\" by choice\n\t\t\t\t\t\t// \"debugAtAllCosts\" => trying to load everything via script injection (not implemented)\n\t\t\t\t\t\t// otherwise, must be truthy => AMD\n\t\t\t\t\t\t// legacyMode: sync | legacyAsync | xd | false\n\t\t\t\t\t\tvar mode = config[p];\n\t\t\t\t\t\treq.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));\n\t\t\t\t\t\treq.async = !legacyMode;\n\t\t\t\t\t}\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is deprecated; remove in 2.0\n\t\t\t\tfor(baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tcomputeAliases(config.aliases, aliases);\n\n\t\t\t\tif(booting){\n\t\t\t\t\tdelayedModuleConfig.push({config:config.config});\n\t\t\t\t}else{\n\t\t\t\t\tfor(p in config.config){\n\t\t\t\t\t\tvar module = getModule(p, referenceModule);\n\t\t\t\t\t\tmodule.config = mix(module.config || {}, config.config[p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// push in any new cache values\n\t\t\t\tif(config.cache){\n\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\tpendingCacheInsert = config.cache;\n\t\t\t\t\tif(config.cache[\"*noref\"]){\n\t\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif(has(\"dojo-cdn\") || has(\"dojo-sniff\")){\n\t\t\t// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.\n\t\t\t// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the\n\t\t\t// dojo location on CDN deployments and baseUrl when either/both of these are not provided\n\t\t\t// explicitly in the config data; this is the 1.6- behavior.\n\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript, dojoDir, src, match;\n\t\t\twhile(i < scripts.length){\n\t\t\t\tscript = scripts[i++];\n\t\t\t\tif((src = script.getAttribute(\"src\")) && (match = src.match(/(((.*)\\/)|^)dojo\\.js(\\W|$)/i))){\n\t\t\t\t\t// sniff dojoDir and baseUrl\n\t\t\t\t\tdojoDir = match[3] || \"\";\n\t\t\t\t\tdefaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff configuration on attribute in script element\n\t\t\t\tif((src = (script.getAttribute(\"data-dojo-config\") || script.getAttribute(\"djConfig\")))){\n\t\t\t\t\tdojoSniffConfig = req.eval(\"({ \" + src + \" })\", \"data-dojo-config\");\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff requirejs attribute\n\t\t\t\tif(has(\"dojo-requirejs-api\")){\n\t\t\t\t\tif((src = script.getAttribute(\"data-main\"))){\n\t\t\t\t\t\tdojoSniffConfig.deps = dojoSniffConfig.deps || [src];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(has(\"dojo-test-sniff\")){\n\t\t\t// pass down doh.testConfig from parent as if it were a data-dojo-config\n\t\t\ttry{\n\t\t\t\tif(window.parent != window && window.parent.require){\n\t\t\t\t\tvar doh = window.parent.require(\"doh\");\n\t\t\t\t\tdoh && mix(dojoSniffConfig, doh.testConfig);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif(has(\"dojo-cdn\")){\n\t\t\tpacks.dojo.location = dojoDir;\n\t\t\tif(dojoDir){\n\t\t\t\tdojoDir += \"/\";\n\t\t\t}\n\t\t\tpacks.dijit.location = dojoDir + \"../dijit/\";\n\t\t\tpacks.dojox.location = dojoDir + \"../dojox/\";\n\t\t}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tmapProgs = defaultConfig.mapProgs;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif(has(\"dojo-combo-api\")){\n\t\treq.combo = req.combo || {add:noop};\n\t\tvar\tcomboPending = 0,\n\t\t\tcombosPending = [],\n\t\t\tcomboPendingTimer = null;\n\t}\n\n\n\t// build the loader machinery iaw configuration, including has feature tests\n\tvar\tinjectDependencies = function(module){\n\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tforEach(module.deps, injectModule);\n\t\t\t\tif(has(\"dojo-combo-api\") && comboPending && !comboPendingTimer){\n\t\t\t\t\tcomboPendingTimer = setTimeout(function() {\n\t\t\t\t\t\tcomboPending = 0;\n\t\t\t\t\t\tcomboPendingTimer = null;\n\t\t\t\t\t\treq.combo.done(function(mids, url) {\n\t\t\t\t\t\t\tvar onLoadCallback= function(){\n\t\t\t\t\t\t\t\t// defQ is a vector of module definitions 1-to-1, onto mids\n\t\t\t\t\t\t\t\trunDefQ(0, mids);\n\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombosPending.push(mids);\n\t\t\t\t\t\t\tinjectingModule = mids;\n\t\t\t\t\t\t\treq.injectUrl(url, onLoadCallback, mids);\n\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t}, req);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\tvar module, syntheticMid;\n\t\t\tif(isString(a1)){\n\t\t\t\t// signature is (moduleId)\n\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\tif(module && module.executed){\n\t\t\t\t\treturn module.result;\n\t\t\t\t}\n\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t}\n\t\t\tif(!isArray(a1)){\n\t\t\t\t// a1 is a configuration\n\t\t\t\tconfig(a1, 0, referenceModule);\n\n\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\ta1 = a2;\n\t\t\t\ta2 = a3;\n\t\t\t}\n\t\t\tif(isArray(a1)){\n\t\t\t\t// signature is (requestList [,callback])\n\t\t\t\tif(!a1.length){\n\t\t\t\t\ta2 && a2();\n\t\t\t\t}else{\n\t\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t\t}\n\n\t\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\t\tinjected: arrived,\n\t\t\t\t\t\tdeps: deps,\n\t\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\t\trequire: referenceModule ? referenceModule.require : req,\n\t\t\t\t\t\tgc: 1 //garbage collect\n\t\t\t\t\t});\n\t\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t\t// try to immediately execute\n\t\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\t\tvar strict = checkCompleteGuard && legacyMode!=sync;\n\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\texecModule(module, strict);\n\t\t\t\t\t});\n\t\t\t\t\tif(!module.executed){\n\t\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\t\texecQ.push(module);\n\t\t\t\t\t}\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contextRequire;\n\t\t},\n\n\t\tcreateRequire = function(module){\n\t\t\tif(!module){\n\t\t\t\treturn req;\n\t\t\t}\n\t\t\tvar result = module.require;\n\t\t\tif(!result){\n\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t};\n\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\tresult.module = module;\n\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t};\n\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t};\n\t\t\t\tif(has(\"dojo-undef-api\")){\n\t\t\t\t\tresult.undef = function(mid){\n\t\t\t\t\t\treq.undef(mid, module);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-sync-loader\")){\n\t\t\t\t\tresult.syncLoadNls = function(mid){\n\t\t\t\t\t\tvar nlsModuleInfo = getModuleInfo(mid, module),\n\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\tif(!nlsModule || !nlsModule.executed){\n\t\t\t\t\t\t\tcached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];\n\t\t\t\t\t\t\tif(cached){\n\t\t\t\t\t\t\t\tevalModuleText(cached);\n\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nlsModule && nlsModule.executed && nlsModule.result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\texecQ =\n\t\t\t// The list of modules that need to be evaluated.\n\t\t\t[],\n\n\t\tdefQ =\n\t\t\t// The queue of define arguments sent to loader.\n\t\t\t[],\n\n\t\twaiting =\n\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t{},\n\n\t\tsetRequested = function(module){\n\t\t\tmodule.injected = requested;\n\t\t\twaiting[module.mid] = 1;\n\t\t\tif(module.url){\n\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t}\n\t\t\tstartTimer();\n\t\t},\n\n\t\tsetArrived = function(module){\n\t\t\tmodule.injected = arrived;\n\t\t\tdelete waiting[module.mid];\n\t\t\tif(module.url){\n\t\t\t\tdelete waiting[module.url];\n\t\t\t}\n\t\t\tif(isEmpty(waiting)){\n\t\t\t\tclearTimer();\n\t\t\t\thas(\"dojo-sync-loader\") && legacyMode==xd && (legacyMode = sync);\n\t\t\t}\n\t\t},\n\n\t\texecComplete = req.idle =\n\t\t\t// says the loader has completed (or not) its work\n\t\t\tfunction(){\n\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t},\n\n\t\trunMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif(has(\"dojo-sync-loader\")){\n\t\t\t\tvar xd= req.isXdUrl(url);\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};\n\t\t\t}else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t}\n\t\t\t\tmapItem = mapItem || mapProgs.star;\n\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = pack.location + \"/\" + midInPackage;\n\t\t\t}else if(has(\"config-tlmSiblingOfDojo\")){\n\t\t\t\turl = \"../\" + mid;\n\t\t\t}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, fromPendingCache ? [] : mapProgs, fromPendingCache ? [] : pathsMapProg, fromPendingCache ? [] : aliases);\n\t\t},\n\n\t\tresolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t},\n\n\t\tdynamicPluginUidGenerator = 0,\n\n\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\tvar match, plugin, prid, result;\n\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\tif(match){\n\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode == sync && !plugin.executed){\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t\tif(plugin.injected===arrived && !plugin.executed){\n\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\texecModule(plugin);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(plugin.executed){\n\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// we are in xdomain mode for some reason\n\t\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t}else{\n\t\t\t\t\tprid = match[2];\n\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t}\n\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t}else{\n\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t}\n\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t},\n\n\t\ttoAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t},\n\n\t\tnonModuleProps = {\n\t\t\tinjected: arrived,\n\t\t\texecuted: executed,\n\t\t\tdef: nonmodule,\n\t\t\tresult: nonmodule\n\t\t},\n\n\t\tmakeCjs = function(mid){\n\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t},\n\n\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\trunFactory = function(module, args){\n\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\tvar factory = module.def,\n\t\t\t\tresult;\n\t\t\thas(\"dojo-sync-loader\") && syncExecStack.unshift(module);\n\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\ttry{\n\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t}catch(e){\n\t\t\t\t\tsignal(error, module.result = makeError(\"factoryThrew\", [module, e]));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t}\n\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\thas(\"dojo-sync-loader\") && syncExecStack.shift(module);\n\t\t},\n\n\t\tabortExec = {},\n\n\t\tdefOrder = 0,\n\n\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\tvar plugin = pluginModule.result;\n\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\tpluginModule.load = plugin.load;\n\t\t\treturn pluginModule;\n\t\t},\n\n\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\tvar map = {};\n\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\tvar prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\tif(!modules[mid]){\n\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t});\n\t\t\tplugin.loadQ = 0;\n\n\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\tvar substituteModules = function(module){\n\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\tif(replacement){\n\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(var p in modules){\n\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t}\n\t\t\tforEach(execQ, substituteModules);\n\t\t},\n\n\t\tfinishExec = function(module){\n\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\tmodule.executed = executed;\n\t\t\tmodule.defOrder = defOrder++;\n\t\t\thas(\"dojo-sync-loader\") && forEach(module.provides, function(cb){ cb(); });\n\t\t\tif(module.loadQ){\n\t\t\t\t// the module was a plugin\n\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t}\n\t\t\t// remove all occurrences of this module from the execQ\n\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t}else{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// delete references to synthetic modules\n\t\t\tif (/^require\\*/.test(module.mid)) {\n\t\t\t\tdelete modules[module.mid];\n\t\t\t}\n\t\t},\n\n\t\tcircleTrace = [],\n\n\t\texecModule = function(module, strict){\n\t\t\t// run the dependency vector, then run the factory for module\n\t\t\tif(module.executed === executing){\n\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(module.mid).join(\"->\")]);\n\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t}\n\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\tif(!module.executed){\n\t\t\t\tif(!module.def){\n\t\t\t\t\treturn abortExec;\n\t\t\t\t}\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\targ, argResult,\n\t\t\t\t\targs = [],\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif(has(\"dojo-trace-api\")){\n\t\t\t\t\tcircleTrace.push(mid);\n\t\t\t\t\treq.trace(\"loader-exec-module\", [\"exec\", circleTrace.length, mid]);\n\t\t\t\t}\n\n\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t// the pre-made cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\tmodule.executed = executing;\n\t\t\t\twhile((arg = deps[i++])){\n\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\thas(\"dojo-trace-api\") && circleTrace.pop();\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\targs.push(argResult);\n\t\t\t\t}\n\t\t\t\trunFactory(module, args);\n\t\t\t\tfinishExec(module);\n\t\t\t\thas(\"dojo-trace-api\") && circleTrace.pop();\n\t\t\t}\n\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\treturn module.result;\n\t\t},\n\n\n\t\tcheckCompleteGuard = 0,\n\n\t\tguardCheckComplete = function(proc){\n\t\t\ttry{\n\t\t\t\tcheckCompleteGuard++;\n\t\t\t\tproc();\n\t\t\t}finally{\n\t\t\t\tcheckCompleteGuard--;\n\t\t\t}\n\t\t\tif(execComplete()){\n\t\t\t\tsignal(\"idle\", []);\n\t\t\t}\n\t\t},\n\n\t\tcheckComplete = function(){\n\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\tif(checkCompleteGuard){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\t\tmodule = execQ[i];\n\t\t\t\t\texecModule(module);\n\t\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\n\tif(has(\"dojo-undef-api\")){\n\t\treq.undef = function(moduleId, referenceModule){\n\t\t\t// In order to reload a module, it must be undefined (this routine) and then re-requested.\n\t\t\t// This is useful for testing frameworks (at least).\n\t\t\tvar module = getModule(moduleId, referenceModule);\n\t\t\tsetArrived(module);\n\t\t\tmix(module, {def:0, executed:0, injected:0, node:0});\n\t\t};\n\t}\n\n\tif(has(\"dojo-inject-api\")){\n\t\tif(has(\"dojo-loader-eval-hint-url\")===undefined){\n\t\t\thas.add(\"dojo-loader-eval-hint-url\", 1);\n\t\t}\n\n\t\tvar fixupUrl= function(url){\n\t\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t\t},\n\n\t\t\tinjectPlugin = function(\n\t\t\t\tmodule\n\t\t\t){\n\t\t\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\t\t\tvar plugin = module.plugin;\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\tvar onLoad = function(def){\n\t\t\t\t\t\tmodule.result = def;\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t}else if(plugin.loadQ){\n\t\t\t\t\tplugin.loadQ.push(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\t\t\tplugin.loadQ = [module];\n\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for IE, injecting a module may result in a recursive execution if the module is in the cache\n\n\t\t\tcached = 0,\n\n\t\t\tinjectingModule = 0,\n\n\t\t\tinjectingCachedModule = 0,\n\n\t\t\tevalModuleText = function(text, module){\n\t\t\t\t// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit\n\t\t\t\tif(has(\"config-stripStrict\")){\n\t\t\t\t\ttext = text.replace(/\"use strict\"/g, '');\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 1;\n\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.eval(text, has(\"dojo-loader-eval-hint-url\") ? module.url : module.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, makeError(\"evalModuleThrew\", module));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treq.eval(text, has(\"dojo-loader-eval-hint-url\") ? module.url : module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 0;\n\t\t\t},\n\n\t\t\tinjectModule = function(module){\n\t\t\t\t// Inject the module. In the browser environment, this means appending a script element into\n\t\t\t\t// the document; in other environments, it means loading a file.\n\t\t\t\t//\n\t\t\t\t// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.\n\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\turl = module.url;\n\t\t\t\tif(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetRequested(module);\n\n\t\t\t\tif(has(\"dojo-combo-api\")){\n\t\t\t\t\tvar viaCombo = 0;\n\t\t\t\t\tif(module.plugin && module.plugin.isCombo){\n\t\t\t\t\t\t// a combo plugin; therefore, must be handled by combo service\n\t\t\t\t\t\t// the prid should have already been converted to a URL (if required by the plugin) during\n\t\t\t\t\t\t// the normalize process; in any event, there is no way for the loader to know how to\n\t\t\t\t\t\t// to the conversion; therefore the third argument is zero\n\t\t\t\t\t\treq.combo.add(module.plugin.mid, module.prid, 0, req);\n\t\t\t\t\t\tviaCombo = 1;\n\t\t\t\t\t}else if(!module.plugin){\n\t\t\t\t\t\tviaCombo = req.combo.add(0, module.mid, module.url, req);\n\t\t\t\t\t}\n\t\t\t\t\tif(viaCombo){\n\t\t\t\t\t\tcomboPending= 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(module.plugin){\n\t\t\t\t\tinjectPlugin(module);\n\t\t\t\t\treturn;\n\t\t\t\t} // else a normal module (not a plugin)\n\n\n\t\t\t\tvar onLoadCallback = function(){\n\t\t\t\t\trunDefQ(module);\n\t\t\t\t\tif(module.injected !== arrived){\n\t\t\t\t\t\t// the script that contained the module arrived and has been executed yet\n\t\t\t\t\t\t// nothing was added to the defQ (so it wasn't an AMD module) and the module\n\t\t\t\t\t\t// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);\n\t\t\t\t\t\t// therefore, it must not have been a module; adjust state accordingly\n\t\t\t\t\t\tif(has(\"dojo-enforceDefine\")){\n\t\t\t\t\t\t\tsignal(error, makeError(\"noDefine\", module));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tmix(module, nonModuleProps);\n\t\t\t\t\t\treq.trace(\"loader-define-nonmodule\", [module.url]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode){\n\t\t\t\t\t\t// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;\n\t\t\t\t\t\t// but, if xd loading, then don't call checkComplete until out of the current sync traversal\n\t\t\t\t\t\t// in order to preserve order of execution of the dojo.required modules\n\t\t\t\t\t\t!syncExecStack.length && checkComplete();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcached = cache[mid] || cache[urlKeyPrefix + module.url];\n\t\t\t\tif(cached){\n\t\t\t\t\treq.trace(\"loader-inject\", [\"cache\", module.mid, url]);\n\t\t\t\t\tevalModuleText(cached, module);\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode){\n\t\t\t\t\tif(module.isXd){\n\t\t\t\t\t\t// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}\n\t\t\t\t\t\tlegacyMode==sync && (legacyMode = xd);\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else if(module.isAmd && legacyMode!=sync){\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain\n\t\t\t\t\t\tvar xhrCallback = function(text){\n\t\t\t\t\t\t\tif(legacyMode==sync){\n\t\t\t\t\t\t\t\t// the top of syncExecStack gives the current synchronously executing module; the loader needs\n\t\t\t\t\t\t\t\t// to know this if it has to switch to async loading in the middle of evaluating a legacy module\n\t\t\t\t\t\t\t\t// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain\n\t\t\t\t\t\t\t\t// (using unshift/shift because there is no back() methods for Javascript arrays)\n\t\t\t\t\t\t\t\tsyncExecStack.unshift(module);\n\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\tsyncExecStack.shift();\n\n\t\t\t\t\t\t\t\t// maybe the module was an AMD module\n\t\t\t\t\t\t\t\trunDefQ(module);\n\n\t\t\t\t\t\t\t\t// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing\n\t\t\t\t\t\t\t\tif(!module.cjs){\n\t\t\t\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(module.finish){\n\t\t\t\t\t\t\t\t\t// while synchronously evaluating this module, dojo.require was applied referencing a module\n\t\t\t\t\t\t\t\t\t// that had to be loaded async; therefore, the loader stopped answering all dojo.require\n\t\t\t\t\t\t\t\t\t// requests so they could be answered completely in the correct sequence; module.finish gives\n\t\t\t\t\t\t\t\t\t// the list of dojo.requires that must be re-applied once all target modules are available;\n\t\t\t\t\t\t\t\t\t// make a synthetic module to execute the dojo.require's in the correct order\n\n\t\t\t\t\t\t\t\t\t// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module\n\t\t\t\t\t\t\t\t\t// TODO: can we just leave the module.finish...what's it hurting?\n\t\t\t\t\t\t\t\t\tvar finishMid = mid + \"*finish\",\n\t\t\t\t\t\t\t\t\t\tfinish = module.finish;\n\t\t\t\t\t\t\t\t\tdelete module.finish;\n\n\t\t\t\t\t\t\t\t\tdef(finishMid, [\"dojo\", (\"dojo/require!\" + finish.join(\",\")).replace(/\\./g, \"/\")], function(dojo){\n\t\t\t\t\t\t\t\t\t\tforEach(finish, function(mid){ dojo.require(mid); });\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t// unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\t\t\t\t\texecQ.unshift(getModule(finishMid));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttext = transformToAmd(module, text);\n\t\t\t\t\t\t\t\tif(text){\n\t\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected\n\t\t\t\t\t\t\t\t\t// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)\n\t\t\t\t\t\t\t\t\tinjectingModule = module;\n\t\t\t\t\t\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treq.trace(\"loader-inject\", [\"xhr\", module.mid, url, legacyMode!=sync]);\n\t\t\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tsignal(error, makeError(\"xhrInjectFailed\", [module, e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} // else async mode or fell through in xdomain loading mode; either way, load by script injection\n\t\t\t\treq.trace(\"loader-inject\", [\"script\", module.mid, url]);\n\t\t\t\tinjectingModule = module;\n\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\tinjectingModule = 0;\n\t\t\t},\n\n\t\t\tdefineModule = function(module, deps, def){\n\t\t\t\treq.trace(\"loader-define-module\", [module.mid, deps]);\n\n\t\t\t\tif(has(\"dojo-combo-api\") && module.plugin && module.plugin.isCombo){\n\t\t\t\t\t// the module is a plugin resource loaded by the combo service\n\t\t\t\t\t// note: check for module.plugin should be enough since normal plugin resources should\n\t\t\t\t\t// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders\n\t\t\t\t\tmodule.result = isFunction(def) ? def() : def;\n\t\t\t\t\tsetArrived(module);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\n\t\t\t\tvar mid = module.mid;\n\t\t\t\tif(module.injected === arrived){\n\t\t\t\t\tsignal(error, makeError(\"multipleDefine\", module));\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t\tmix(module, {\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: def,\n\t\t\t\t\tcjs: {\n\t\t\t\t\t\tid: module.mid,\n\t\t\t\t\t\turi: module.url,\n\t\t\t\t\t\texports: (module.result = {}),\n\t\t\t\t\t\tsetExports: function(exports){\n\t\t\t\t\t\t\tmodule.cjs.exports = exports;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfig:function(){\n\t\t\t\t\t\t\treturn module.config;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// resolve deps with respect to this module\n\t\t\t\tfor(var i = 0; deps[i]; i++){\n\t\t\t\t\tdeps[i] = getModule(deps[i], module);\n\t\t\t\t}\n\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode && !waiting[mid]){\n\t\t\t\t\t// the module showed up without being asked for; it was probably in a <script> element\n\t\t\t\t\tinjectDependencies(module);\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t\tsetArrived(module);\n\n\t\t\t\tif(!isFunction(def) && !deps.length){\n\t\t\t\t\tmodule.result = def;\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t},\n\n\t\t\trunDefQ = function(referenceModule, mids){\n\t\t\t\t// defQ is an array of [id, dependencies, factory]\n\t\t\t\t// mids (if any) is a vector of mids given by a combo service\n\t\t\t\tvar definedModules = [],\n\t\t\t\t\tmodule, args;\n\t\t\t\twhile(defQ.length){\n\t\t\t\t\targs = defQ.shift();\n\t\t\t\t\tmids && (args[0]= mids.shift());\n\t\t\t\t\t// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully\n\t\t\t\t\t// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue\n\t\t\t\t\t// TODO: what if no args[0] and no referenceModule\n\t\t\t\t\tmodule = (args[0] && getModule(args[0])) || referenceModule;\n\t\t\t\t\tdefinedModules.push([module, args[1], args[2]]);\n\t\t\t\t}\n\t\t\t\tconsumePendingCacheInsert(referenceModule);\n\t\t\t\tforEach(definedModules, function(args){\n\t\t\t\t\tinjectDependencies(defineModule.apply(null, args));\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif(has(\"dojo-timeout-api\")){\n\t\t// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.\n\t\tclearTimer = function(){\n\t\t\ttimerId && clearTimeout(timerId);\n\t\t\ttimerId = 0;\n\t\t};\n\n\t\tstartTimer = function(){\n\t\t\tclearTimer();\n\t\t\tif(req.waitms){\n\t\t\t\ttimerId = window.setTimeout(function(){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\tsignal(error, makeError(\"timeout\", waiting));\n\t\t\t\t}, req.waitms);\n\t\t\t}\n\t\t};\n\t}\n\n\tif (has(\"dom\")) {\n\t\t// Test for IE's different way of signaling when scripts finish loading.  Note that according to\n\t\t// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the\n\t\t// IE specific code path even though it has an addEventListener() method.\n\t\t// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.\n\t\t// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()\n\t\t//  is defined in both those environments.\n\t\thas.add(\"ie-event-behavior\", doc.attachEvent && typeof Windows === \"undefined\" &&\n\t\t\t(typeof opera === \"undefined\" || opera.toString() != \"[object Opera]\"));\n\t}\n\n\tif(has(\"dom\") && (has(\"dojo-inject-api\") || has(\"dojo-dom-ready-api\"))){\n\t\tvar domOn = function(node, eventName, ieEventName, handler){\n\t\t\t\t// Add an event listener to a DOM node using the API appropriate for the current browser;\n\t\t\t\t// return a function that will disconnect the listener.\n\t\t\t\tif(!has(\"ie-event-behavior\")){\n\t\t\t\t\tnode.addEventListener(eventName, handler, false);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.removeEventListener(eventName, handler, false);\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tnode.attachEvent(ieEventName, handler);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.detachEvent(ieEventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\twindowOnLoadListener = domOn(window, \"load\", \"onload\", function(){\n\t\t\t\treq.pageLoaded = 1;\n\t\t\t\tdoc.readyState!=\"complete\" && (doc.readyState = \"complete\");\n\t\t\t\twindowOnLoadListener();\n\t\t\t});\n\n\t\tif(has(\"dojo-inject-api\")){\n\t\t\t// if the loader is on the page, there must be at least one script element\n\t\t\t// getting its parent and then doing insertBefore solves the \"Operation Aborted\"\n\t\t\t// error in IE from appending to a node that isn't properly closed; see\n\t\t\t// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example\n\t\t\t// don't use scripts with type dojo/... since these may be removed; see #15809\n\t\t\t// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript;\n\t\t\twhile(!insertPointSibling){\n\t\t\t\tif(!/^dojo/.test((script = scripts[i++]) && script.type)){\n\t\t\t\t\tinsertPointSibling= script;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.injectUrl = function(url, callback, owner){\n\t\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t\t// apply callback upon detecting the script has loaded.\n\n\t\t\t\tvar node = owner.node = doc.createElement(\"script\"),\n\t\t\t\t\tonLoad = function(e){\n\t\t\t\t\t\te = e || window.event;\n\t\t\t\t\t\tvar node = e.target || e.srcElement;\n\t\t\t\t\t\tif(e.type === \"load\" || /complete|loaded/.test(node.readyState)){\n\t\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tloadDisconnector = domOn(node, \"load\", \"onreadystatechange\", onLoad),\n\t\t\t\t\terrorDisconnector = domOn(node, \"error\", \"onerror\", function(e){\n\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\tsignal(error, makeError(\"scriptError\", [url, e]));\n\t\t\t\t\t});\n\n\t\t\t\tnode.type = \"text/javascript\";\n\t\t\t\tnode.charset = \"utf-8\";\n\t\t\t\tnode.src = url;\n\t\t\t\tinsertPointSibling.parentNode.insertBefore(node, insertPointSibling);\n\t\t\t\treturn node;\n\t\t\t};\n\t\t}\n\t}\n\n\tif(has(\"dojo-log-api\")){\n\t\treq.log = function(){\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\t\t\tconsole.log(arguments[i]);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t};\n\t}else{\n\t\treq.log = noop;\n\t}\n\n\tif(has(\"dojo-trace-api\")){\n\t\tvar trace = req.trace = function(\n\t\t\tgroup,\t// the trace group to which this application belongs\n\t\t\targs\t// the contents of the trace\n\t\t){\n\t\t\t///\n\t\t\t// Tracing interface by group.\n\t\t\t//\n\t\t\t// Sends the contents of args to the console iff (req.trace.on && req.trace[group])\n\n\t\t\tif(trace.on && trace.group[group]){\n\t\t\t\tsignal(\"trace\", [group, args]);\n\t\t\t\tfor(var arg, dump = [], text= \"trace:\" + group + (args.length ? (\":\" + args[0]) : \"\"), i= 1; i<args.length;){\n\t\t\t\t\targ = args[i++];\n\t\t\t\t\tif(isString(arg)){\n\t\t\t\t\t\ttext += \", \" + arg;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdump.push(arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.log(text);\n\t\t\t\tdump.length && dump.push(\".\");\n\t\t\t\treq.log.apply(req, dump);\n\t\t\t}\n\t\t};\n\t\tmix(trace, {\n\t\t\ton:1,\n\t\t\tgroup:{},\n\t\t\tset:function(group, value){\n\t\t\t\tif(isString(group)){\n\t\t\t\t\ttrace.group[group]= value;\n\t\t\t\t}else{\n\t\t\t\t\tmix(trace.group, group);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttrace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));\n\t\ton(\"config\", function(config){\n\t\t\tconfig.trace && trace.set(config.trace);\n\t\t});\n\t}else{\n\t\treq.trace = noop;\n\t}\n\n\tvar def = function(\n\t\tmid,\t\t  //(commonjs.moduleId, optional)\n\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\tfactory\t\t  //(any)\n\t){\n\t\t///\n\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t///\n\t\t//note\n\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\tvar arity = arguments.length,\n\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"],\n\t\t\t// the predominate signature...\n\t\t\targs = [0, mid, dependencies];\n\t\tif(arity==1){\n\t\t\targs = [0, (isFunction(mid) ? defaultDeps : []), mid];\n\t\t}else if(arity==2 && isString(mid)){\n\t\t\targs = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];\n\t\t}else if(arity==3){\n\t\t\targs = [mid, dependencies, factory];\n\t\t}\n\n\t\tif(has(\"dojo-amd-factory-scan\") && args[1]===defaultDeps){\n\t\t\targs[2].toString()\n\t\t\t\t.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\")\n\t\t\t\t.replace(/require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g, function(match, dep){\n\t\t\t\targs[1].push(dep);\n\t\t\t});\n\t\t}\n\n\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\tmodule;\n\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t}else if(!has(\"ie-event-behavior\") || !has(\"host-browser\") || injectingCachedModule){\n\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\tdefQ.push(args);\n\t\t}else{\n\t\t\t// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,\n\t\t\t// in-order exec of onLoad with script eval (since it's IE) and must manually detect here\n\t\t\ttargetModule = targetModule || injectingModule;\n\t\t\tif(!targetModule){\n\t\t\t\tfor(mid in waiting){\n\t\t\t\t\tmodule = modules[mid];\n\t\t\t\t\tif(module && module.node && module.node.readyState === 'interactive'){\n\t\t\t\t\t\ttargetModule = module;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-combo-api\") && !targetModule){\n\t\t\t\t\tfor(var i = 0; i<combosPending.length; i++){\n\t\t\t\t\t\ttargetModule = combosPending[i];\n\t\t\t\t\t\tif(targetModule.node && targetModule.node.readyState === 'interactive'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttargetModule= 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(has(\"dojo-combo-api\") && isArray(targetModule)){\n\t\t\t\tinjectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));\n\t\t\t\tif(!targetModule.length){\n\t\t\t\t\tcombosPending.splice(i, 1);\n\t\t\t\t}\n\t\t\t}else if(targetModule){\n\t\t\t\tconsumePendingCacheInsert(targetModule);\n\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t}else{\n\t\t\t\tsignal(error, makeError(\"ieDefineFailed\", args[0]));\n\t\t\t}\n\t\t\tcheckComplete();\n\t\t}\n\t};\n\tdef.amd = {\n\t\tvendor:\"dojotoolkit.org\"\n\t};\n\n\tif(has(\"dojo-requirejs-api\")){\n\t\treq.def = def;\n\t}\n\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif(has(\"dojo-publish-privates\")){\n\t\tmix(req, {\n\t\t\t// these may be interesting to look at when debugging\n\t\t\tpaths:paths,\n\t\t\taliases:aliases,\n\t\t\tmodules:modules,\n\t\t\tlegacyMode:legacyMode,\n\t\t\texecQ:execQ,\n\t\t\tdefQ:defQ,\n\t\t\twaiting:waiting,\n\n\t\t\t// these are used for testing\n\t\t\t// TODO: move testing infrastructure to a different has feature\n\t\t\tpacks:packs,\n\t\t\tmapProgs:mapProgs,\n\t\t\tpathsMapProg:pathsMapProg,\n\t\t\tlistenerQueues:listenerQueues,\n\n\t\t\t// these are used by the builder (at least)\n\t\t\tcomputeMapProg:computeMapProg,\n\t\t\tcomputeAliases:computeAliases,\n\t\t\trunMapProg:runMapProg,\n\t\t\tcompactPath:compactPath,\n\t\t\tgetModuleInfo:getModuleInfo_\n\t\t});\n\t}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif(has(\"dojo-log-api\")){\n\t\t\tsignal(error, makeError(\"defineAlreadyDefined\", 0));\n\t\t}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif(has(\"host-node\")){\n\t\t\trequire = req;\n\t\t}\n\t}\n\n\tif(has(\"dojo-combo-api\") && req.combo && req.combo.plugins){\n\t\tvar plugins = req.combo.plugins,\n\t\t\tpluginName;\n\t\tfor(pluginName in plugins){\n\t\t\tmix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:\"executed\", load:1});\n\t\t}\n\t}\n\n\tif(has(\"dojo-config-api\")){\n\t\tforEach(delayedModuleConfig, function(c){ config(c); });\n\t\tvar bootDeps = dojoSniffConfig.deps ||\tuserConfig.deps || defaultConfig.deps,\n\t\t\tbootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;\n\t\treq.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;\n\t}\n\tif(!has(\"dojo-built\")){\n\t\t!req.async && req([\"dojo\"]);\n\t\treq.boot && req.apply(null, req.boot);\n\t}\n})\n//>>excludeStart(\"replaceLoaderConfig\", kwArgs.replaceLoaderConfig);\n(\n\t// userConfig\n\t(function(){\n\t\t// make sure we're looking at global dojoConfig etc.\n\t\treturn this.dojoConfig || this.djConfig || this.require || {};\n\t})(),\n\n\t// defaultConfig\n\t{\n\t\t// the default configuration for a browser; this will be modified by other environments\n\t\thasCache:{\n\t\t\t\"host-browser\":1,\n\t\t\t\"dom\":1,\n\t\t\t\"dojo-amd-factory-scan\":1,\n\t\t\t\"dojo-loader\":1,\n\t\t\t\"dojo-has-api\":1,\n\t\t\t\"dojo-inject-api\":1,\n\t\t\t\"dojo-timeout-api\":1,\n\t\t\t\"dojo-trace-api\":1,\n\t\t\t\"dojo-log-api\":1,\n\t\t\t\"dojo-dom-ready-api\":1,\n\t\t\t\"dojo-publish-privates\":1,\n\t\t\t\"dojo-config-api\":1,\n\t\t\t\"dojo-sniff\":1,\n\t\t\t\"dojo-sync-loader\":1,\n\t\t\t\"dojo-test-sniff\":1,\n\t\t\t\"config-deferredInstrumentation\":1,\n\t\t\t\"config-useDeferredInstrumentation\":\"report-unhandled-rejections\",\n\t\t\t\"config-tlmSiblingOfDojo\":0\n\t\t},\n\t\tpackages:[{\n\t\t\t// note: like v1.6-, this bootstrap computes baseUrl to be the dojo directory\n\t\t\tname:'dojo',\n\t\t\tlocation:'.'\n\t\t},{\n\t\t\tname:'tests',\n\t\t\tlocation:'./tests'\n\t\t},{\n\t\t\tname:'dijit',\n\t\t\tlocation:'../dijit'\n\t\t},{\n\t\t\tname:'build',\n\t\t\tlocation:'../util/build'\n\t\t},{\n\t\t\tname:'doh',\n\t\t\tlocation:'../util/doh'\n\t\t},{\n\t\t\tname:'dojox',\n\t\t\tlocation:'../dojox'\n\t\t},{\n\t\t\tname:'demos',\n\t\t\tlocation:'../demos'\n\t\t}],\n\t\ttrace:{\n\t\t\t// these are listed so it's simple to turn them on/off while debugging loading\n\t\t\t\"loader-inject\":0,\n\t\t\t\"loader-define\":0,\n\t\t\t\"loader-exec-module\":0,\n\t\t\t\"loader-run-factory\":0,\n\t\t\t\"loader-finish-exec\":0,\n\t\t\t\"loader-define-module\":0,\n\t\t\t\"loader-circular-dependency\":0,\n\t\t\t\"loader-define-nonmodule\":0\n\t\t},\n\t\tasync:0,\n\t\twaitSeconds:15\n\t}\n);\n//>>excludeEnd(\"replaceLoaderConfig\")\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/_base/configNode.js":"exports.config = function(config){\n\t// summary:\n\t//\t\tThis module provides bootstrap configuration for running dojo in node.js\n\n\t// any command line arguments with the load flag are pushed into deps\n\tfor(var deps = [], args = [], i = 0; i < process.argv.length; i++){\n\t\tvar arg = (process.argv[i] + \"\").split(\"=\");\n\t\tif(arg[0] == \"load\"){\n\t\t\tdeps.push(arg[1]);\n\t\t}else{\n\t\t\targs.push(arg);\n\t\t}\n\t}\n\n\tvar fs = require(\"fs\");\n\n\t// make sure global require exists\n\t//if (typeof global.require==\"undefined\"){\n\t//\tglobal.require= {};\n\t//}\n\n\t// reset the has cache with node-appropriate values;\n\tvar hasCache = {\n\t\t\"host-node\":1,\n\t\t\"host-browser\":0,\n\t\t\"dom\":0,\n\t\t\"dojo-has-api\":1,\n\t\t\"dojo-xhr-factory\":0,\n\t\t\"dojo-inject-api\":1,\n\t\t\"dojo-timeout-api\":0,\n\t\t\"dojo-trace-api\":1,\n\t\t\"dojo-dom-ready-api\":0,\n\t\t\"dojo-publish-privates\":1,\n\t\t\"dojo-sniff\":0,\n\t\t\"dojo-loader\":1,\n\t\t\"dojo-test-xd\":0,\n\t\t\"dojo-test-sniff\":0\n\t};\n\tfor(var p in hasCache){\n\t\tconfig.hasCache[p] = hasCache[p];\n\t}\n\n\tvar vm = require('vm'),\n\t\tpath = require('path');\n\n\t// reset some configuration switches with node-appropriate values\n\tvar nodeConfig = {\n\t\tbaseUrl: path.dirname(process.argv[1]),\n\t\tcommandLineArgs:args,\n\t\tdeps:deps,\n\t\ttimeout:0,\n\n\t\t// TODO: really get the locale\n\t\tlocale:\"en-us\",\n\n\t\tloaderPatch: {\n\t\t\tlog:function(item){\n                console.dir(item.stack || item);\n\t\t\t\t// define debug for console messages during dev instead of console.log\n\t\t\t\t// (node's heavy async makes console.log confusing sometimes)\n\t\t\t\tvar util = require(\"util\");\n\t\t\t\tutil.debug(util.inspect(item));\n\t\t\t},\n\n\t\t\teval: function(__text, __urlHint){\n\t\t\t\treturn vm.runInThisContext(__text, __urlHint);\n\t\t\t},\n\n\t\t\tinjectUrl: function(url, callback){\n\t\t\t\ttry{\n\t\t\t\t\tvm.runInThisContext(fs.readFileSync(url, \"utf8\"), url);\n\t\t\t\t\tcallback();\n\t\t\t\t}catch(e){\n\t\t\t\t\tthis.log(\"failed to load resource (\" + url + \")\");\n\t\t\t\t\tthis.log(e);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetText: function(url, sync, onLoad){\n\t\t\t\t// TODO: implement async and http/https handling\n\t\t\t\tonLoad(fs.readFileSync(url, \"utf8\"));\n\t\t\t}\n\t\t}\n\t};\n\tfor(p in nodeConfig){\n\t\tconfig[p] = nodeConfig[p];\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dojo.profile.js":"var profile = (function(){\n\tvar testResourceRe = /^dojo\\/tests\\//,\n\n\t\tcopyOnly = function(filename, mid){\n\t\t\tvar list = {\n\t\t\t\t\"dojo/dojo.profile\":1,\n\t\t\t\t\"dojo/package.json\":1,\n\t\t\t\t\"dojo/OpenAjax\":1,\n\t\t\t\t\"dojo/tests\":1,\n\t\t\t\t// these are test modules that are not intended to ever be built\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/requirejs-setup\":1,\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/dataMain\":1,\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/depoverlap\":1,\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/simple-tests\":1,\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/relative/relative-tests\":1,\n\t\t\t\t\"dojo/tests/_base/loader/requirejs/exports/exports-tests\":1\n\t\t\t};\n\t\t\treturn (mid in list) ||\n\t\t\t\t/^dojo\\/_base\\/config\\w+$/.test(mid) ||\n\t\t\t\t(/^dojo\\/resources\\//.test(mid) && !/\\.css$/.test(filename)) ||\n\t\t\t\t/(png|jpg|jpeg|gif|tiff)$/.test(filename) ||\n\t\t\t\t/built\\-i18n\\-test\\/152\\-build/.test(mid);\n\t\t};\n\n\treturn {\n\t\tresourceTags:{\n\t\t\ttest: function(filename, mid){\n\t\t\t\treturn testResourceRe.test(mid) || mid==\"dojo/tests\" || mid==\"dojo/robot\" || mid==\"dojo/robotx\";\n\t\t\t},\n\n\t\t\tcopyOnly: function(filename, mid){\n\t\t\t\treturn copyOnly(filename, mid);\n\t\t\t},\n\n\t\t\tamd: function(filename, mid){\n\t\t\t\treturn !testResourceRe.test(mid) && !copyOnly(filename, mid) && /\\.js$/.test(filename);\n\t\t\t}\n\t\t}\n\t};\n})();\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-attr.js":"define([\"exports\", \"./sniff\", \"./_base/lang\", \"./dom\", \"./dom-style\", \"./dom-prop\"],\n\t\tfunction(exports, has, lang, dom, style, prop){\n\t// module:\n\t//\t\tdojo/dom-attr\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM attributes API.\n\n\t// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42\n\n\t// =============================\n\t// Element attribute Functions\n\t// =============================\n\n\t// This module will be obsolete soon. Use dojo/prop instead.\n\n\t// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/\n\n\t// attribute-related functions (to be obsolete soon)\n\n\tvar forcePropNames = {\n\t\t\tinnerHTML:\t1,\n\t\t\tclassName:\t1,\n\t\t\thtmlFor:\thas(\"ie\"),\n\t\t\tvalue:\t\t1\n\t\t},\n\t\tattrNames = {\n\t\t\t// original attribute names\n\t\t\tclassname: \"class\",\n\t\t\thtmlfor: \"for\",\n\t\t\t// for IE\n\t\t\ttabindex: \"tabIndex\",\n\t\t\treadonly: \"readOnly\"\n\t\t};\n\n\tfunction _hasAttr(node, name){\n\t\tvar attr = node.getAttributeNode && node.getAttributeNode(name);\n\t\treturn attr && attr.specified; // Boolean\n\t}\n\n\t// There is a difference in the presence of certain properties and their default values\n\t// between browsers. For example, on IE \"disabled\" is present on all elements,\n\t// but it is value is \"false\"; \"tabIndex\" of <div> returns 0 by default on IE, yet other browsers\n\t// can return -1.\n\n\texports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){\n\t\t// summary:\n\t\t//\t\tReturns true if the requested attribute is specified on the\n\t\t//\t\tgiven element, and false otherwise.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to check\n\t\t// name: String\n\t\t//\t\tthe name of the attribute\n\t\t// returns: Boolean\n\t\t//\t\ttrue if the requested attribute is specified on the\n\t\t//\t\tgiven element, and false otherwise\n\n\t\tvar lc = name.toLowerCase();\n\t\treturn forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);\t// Boolean\n\t};\n\n\texports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){\n\t\t// summary:\n\t\t//\t\tGets an attribute on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting of attributes on DOM Nodes.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to get the attribute on\n\t\t// name: String\n\t\t//\t\tthe name of the attribute to get.\n\t\t// returns:\n\t\t//\t\tthe value of the requested attribute or null if that attribute does not have a specified or\n\t\t//\t\tdefault value;\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" attribute on a node\n\t\t//\t|\trequire([\"dojo/dom-attr\", \"dojo/dom\"], function(domAttr, dom){\n\t\t//\t|\t\tdomAttr.get(dom.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t\t// or we can just pass the id:\n\t\t//\t|\t\tdomAttr.get(\"nodeId\", \"foo\");\n\t\t//\t|\t});\t\n\t\t//\t|\t\n\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(),\n\t\t\tpropName = prop.names[lc] || name,\n\t\t\tforceProp = forcePropNames[propName],\n\t\t\tvalue = node[propName];\t\t// should we access this attribute via a property or via getAttribute()?\n\n\t\tif(forceProp && typeof value != \"undefined\"){\n\t\t\t// node's property\n\t\t\treturn value;\t// Anything\n\t\t}\n\t\tif(propName != \"href\" && (typeof value == \"boolean\" || lang.isFunction(value))){\n\t\t\t// node's property\n\t\t\treturn value;\t// Anything\n\t\t}\n\t\t// node's attribute\n\t\t// we need _hasAttr() here to guard against IE returning a default value\n\t\tvar attrName = attrNames[lc] || name;\n\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything\n\t};\n\n\texports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){\n\t\t// summary:\n\t\t//\t\tSets an attribute on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized setting of attributes on DOM Nodes.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to set the attribute on\n\t\t// name: String|Object\n\t\t//\t\tthe name of the attribute to set, or a hash of key-value pairs to set.\n\t\t// value: String?\n\t\t//\t\tthe value to set for the attribute, if the name is a string.\n\t\t// returns:\n\t\t//\t\tthe DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use attr() to set the tab index\n\t\t//\t|\trequire([\"dojo/dom-attr\"], function(domAttr){\n\t\t//\t|\t\tdomAttr.set(\"nodeId\", \"tabIndex\", 3);\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\trequire([\"dojo/dom-attr\"],\n\t\t//\t|\tfunction(domAttr){\n\t\t//\t|\t\tdomAttr.set(\"formId\", {\n\t\t//\t|\t\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\t\"method\": \"POST\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\n\t\tnode = dom.byId(node);\n\t\tif(arguments.length == 2){ // inline'd type check\n\t\t\t// the object form of setter: the 2nd argument is a dictionary\n\t\t\tfor(var x in name){\n\t\t\t\texports.set(node, x, name[x]);\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tvar lc = name.toLowerCase(),\n\t\t\tpropName = prop.names[lc] || name,\n\t\t\tforceProp = forcePropNames[propName];\n\t\tif(propName == \"style\" && typeof value != \"string\"){ // inline'd type check\n\t\t\t// special case: setting a style\n\t\t\tstyle.set(node, value);\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(forceProp || typeof value == \"boolean\" || lang.isFunction(value)){\n\t\t\treturn prop.set(node, name, value);\n\t\t}\n\t\t// node's attribute\n\t\tnode.setAttribute(attrNames[lc] || name, value);\n\t\treturn node; // DomNode\n\t};\n\n\texports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){\n\t\t// summary:\n\t\t//\t\tRemoves an attribute from an HTML element.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to remove the attribute from\n\t\t// name: String\n\t\t//\t\tthe name of the attribute to remove\n\n\t\tdom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);\n\t};\n\n\texports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){\n\t\t// summary:\n\t\t//\t\tReturns an effective value of a property or an attribute.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to remove the attribute from\n\t\t// name: String\n\t\t//\t\tthe name of the attribute\n\t\t// returns:\n\t\t//\t\tthe value of the attribute\n\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(), propName = prop.names[lc] || name;\n\t\tif((propName in node) && propName != \"href\"){\n\t\t\t// node's property\n\t\t\treturn node[propName];\t// Anything\n\t\t}\n\t\t// node's attribute\n\t\tvar attrName = attrNames[lc] || name;\n\t\treturn _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-class.js":"define([\"./_base/lang\", \"./_base/array\", \"./dom\"], function(lang, array, dom){\n\t// module:\n\t//\t\tdojo/dom-class\n\n\tvar className = \"className\";\n\n\t/* Part I of classList-based implementation is preserved here for posterity\n\tvar classList = \"classList\";\n\thas.add(\"dom-classList\", function(){\n\t\treturn classList in document.createElement(\"p\");\n\t});\n\t*/\n\n\t// =============================\n\t// (CSS) Class Functions\n\t// =============================\n\n\tvar cls, // exports object\n\t\tspaces = /\\s+/, a1 = [\"\"];\n\n\tfunction str2array(s){\n\t\tif(typeof s == \"string\" || s instanceof String){\n\t\t\tif(s && !spaces.test(s)){\n\t\t\t\ta1[0] = s;\n\t\t\t\treturn a1;\n\t\t\t}\n\t\t\tvar a = s.split(spaces);\n\t\t\tif(a.length && !a[0]){\n\t\t\t\ta.shift();\n\t\t\t}\n\t\t\tif(a.length && !a[a.length - 1]){\n\t\t\t\ta.pop();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\t// assumed to be an array\n\t\tif(!s){\n\t\t\treturn [];\n\t\t}\n\t\treturn array.filter(s, function(x){ return x; });\n\t}\n\n\t/* Part II of classList-based implementation is preserved here for posterity\n\tif(has(\"dom-classList\")){\n\t\t// new classList version\n\t\tcls = {\n\t\t\tcontains: function containsClass(node, classStr){\n\t\t\t\tvar clslst = classStr && dom.byId(node)[classList];\n\t\t\t\treturn clslst && clslst.contains(classStr); // Boolean\n\t\t\t},\n\n\t\t\tadd: function addClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(classStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tremove: function removeClass(node, classStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(classStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\treplace: function replaceClass(node, addClassStr, removeClassStr){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(removeClassStr === undefined){\n\t\t\t\t\tnode[className] = \"\";\n\t\t\t\t}else{\n\t\t\t\t\tremoveClassStr = str2array(removeClassStr);\n\t\t\t\t\tfor(var i = 0, len = removeClassStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].remove(removeClassStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddClassStr = str2array(addClassStr);\n\t\t\t\tfor(i = 0, len = addClassStr.length; i < len; ++i){\n\t\t\t\t\tnode[classList].add(addClassStr[i]);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttoggle: function toggleClass(node, classStr, condition){\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tif(condition === undefined){\n\t\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\t\tnode[classList].toggle(classStr[i]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t\t}\n\t\t\t\treturn condition;   // Boolean\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t// regular DOM version\n\tvar fakeNode = {};  // for effective replacement\n\tcls = {\n\t\t// summary:\n\t\t//\t\tThis module defines the core dojo DOM class API.\n\n\t\tcontains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){\n\t\t\t// summary:\n\t\t\t//\t\tReturns whether or not the specified classes are a portion of the\n\t\t\t//\t\tclass list currently applied to the node.\n\t\t\t// node: String|DOMNode\n\t\t\t//\t\tString ID or DomNode reference to check the class for.\n\t\t\t// classStr: String\n\t\t\t//\t\tA string class name to look for.\n\t\t\t// example:\n\t\t\t//\t\tDo something if a node with id=\"someNode\" has class=\"aSillyClassName\" present\n\t\t\t//\t|\tif(dojo.hasClass(\"someNode\",\"aSillyClassName\")){ ... }\n\n\t\t\treturn ((\" \" + dom.byId(node)[className] + \" \").indexOf(\" \" + classStr + \" \") >= 0); // Boolean\n\t\t},\n\n\t\tadd: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){\n\t\t\t// summary:\n\t\t\t//\t\tAdds the specified classes to the end of the class list on the\n\t\t\t//\t\tpassed node. Will not re-apply duplicate classes.\n\t\t\t//\n\t\t\t// node: String|DOMNode\n\t\t\t//\t\tString ID or DomNode reference to add a class string too\n\t\t\t//\n\t\t\t// classStr: String|Array\n\t\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAdd a class to some node:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.add(\"someNode\", \"anewClass\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAdd two classes at once:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.add(\"someNode\", \"firstClass secondClass\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAdd two classes at once (using array):\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.add(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAvailable in `dojo/NodeList` for multiple additions\n\t\t\t//\t|\trequire([\"dojo/query\"], function(query){\n\t\t\t//\t|\t\tquery(\"ul > li\").addClass(\"firstLevel\");\n\t\t\t//\t|\t});\n\n\t\t\tnode = dom.byId(node);\n\t\t\tclassStr = str2array(classStr);\n\t\t\tvar cls = node[className], oldLen;\n\t\t\tcls = cls ? \" \" + cls + \" \" : \" \";\n\t\t\toldLen = cls.length;\n\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\tc = classStr[i];\n\t\t\t\tif(c && cls.indexOf(\" \" + c + \" \") < 0){\n\t\t\t\t\tcls += c + \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldLen < cls.length){\n\t\t\t\tnode[className] = cls.substr(1, cls.length - 2);\n\t\t\t}\n\t\t},\n\n\t\tremove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){\n\t\t\t// summary:\n\t\t\t//\t\tRemoves the specified classes from node. No `contains()`\n\t\t\t//\t\tcheck is required.\n\t\t\t//\n\t\t\t// node: String|DOMNode\n\t\t\t//\t\tString ID or DomNode reference to remove the class from.\n\t\t\t//\n\t\t\t// classStr: String|Array\n\t\t\t//\t\tAn optional String class name to remove, or several space-separated\n\t\t\t//\t\tclass names, or an array of class names. If omitted, all class names\n\t\t\t//\t\twill be deleted.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tRemove a class from some node:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.remove(\"someNode\", \"firstClass\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tRemove two classes from some node:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.remove(\"someNode\", \"firstClass secondClass\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tRemove two classes from some node (using array):\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.remove(\"someNode\", [\"firstClass\", \"secondClass\"]);\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tRemove all classes from some node:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.remove(\"someNode\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAvailable in `dojo/NodeList` for multiple removal\n\t\t\t//\t|\trequire([\"dojo/query\"], function(query){\n\t\t\t//\t|\t\tquery(\"ul > li\").removeClass(\"foo\");\n\t\t\t//\t|\t});\n\n\t\t\tnode = dom.byId(node);\n\t\t\tvar cls;\n\t\t\tif(classStr !== undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tcls = \" \" + node[className] + \" \";\n\t\t\t\tfor(var i = 0, len = classStr.length; i < len; ++i){\n\t\t\t\t\tcls = cls.replace(\" \" + classStr[i] + \" \", \" \");\n\t\t\t\t}\n\t\t\t\tcls = lang.trim(cls);\n\t\t\t}else{\n\t\t\t\tcls = \"\";\n\t\t\t}\n\t\t\tif(node[className] != cls){ node[className] = cls; }\n\t\t},\n\n\t\treplace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){\n\t\t\t// summary:\n\t\t\t//\t\tReplaces one or more classes on a node if not present.\n\t\t\t//\t\tOperates more quickly than calling dojo.removeClass and dojo.addClass\n\t\t\t//\n\t\t\t// node: String|DOMNode\n\t\t\t//\t\tString ID or DomNode reference to remove the class from.\n\t\t\t//\n\t\t\t// addClassStr: String|Array\n\t\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\t//\n\t\t\t// removeClassStr: String|Array?\n\t\t\t//\t\tA String class name to remove, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.replace(\"someNode\", \"add1 add2\", \"remove1 remove2\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tReplace all classes with addMe\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.replace(\"someNode\", \"addMe\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tAvailable in `dojo/NodeList` for multiple toggles\n\t\t\t//\t|\trequire([\"dojo/query\"], function(query){\n\t\t\t//\t|\t\tquery(\".findMe\").replaceClass(\"addMe\", \"removeMe\");\n\t\t\t//\t|\t});\n\n\t\t\tnode = dom.byId(node);\n\t\t\tfakeNode[className] = node[className];\n\t\t\tcls.remove(fakeNode, removeClassStr);\n\t\t\tcls.add(fakeNode, addClassStr);\n\t\t\tif(node[className] !== fakeNode[className]){\n\t\t\t\tnode[className] = fakeNode[className];\n\t\t\t}\n\t\t},\n\n\t\ttoggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){\n\t\t\t// summary:\n\t\t\t//\t\tAdds a class to node if not present, or removes if present.\n\t\t\t//\t\tPass a boolean condition if you want to explicitly add or remove.\n\t\t\t//\t\tReturns the condition that was specified directly or indirectly.\n\t\t\t//\n\t\t\t// node: String|DOMNode\n\t\t\t//\t\tString ID or DomNode reference to toggle a class string\n\t\t\t//\n\t\t\t// classStr: String|Array\n\t\t\t//\t\tA String class name to toggle, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\t//\n\t\t\t// condition:\n\t\t\t//\t\tIf passed, true means to add the class, false means to remove.\n\t\t\t//\t\tOtherwise dojo.hasClass(node, classStr) is used to detect the class presence.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.toggle(\"someNode\", \"hovered\");\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tForcefully add a class\n\t\t\t//\t|\trequire([\"dojo/dom-class\"], function(domClass){\n\t\t\t//\t|\t\tdomClass.toggle(\"someNode\", \"hovered\", true);\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAvailable in `dojo/NodeList` for multiple toggles\n\t\t\t//\t|\trequire([\"dojo/query\"], function(query){\n\t\t\t//\t|\t\tquery(\".toggleMe\").toggleClass(\"toggleMe\");\n\t\t\t//\t|\t});\n\n\t\t\tnode = dom.byId(node);\n\t\t\tif(condition === undefined){\n\t\t\t\tclassStr = str2array(classStr);\n\t\t\t\tfor(var i = 0, len = classStr.length, c; i < len; ++i){\n\t\t\t\t\tc = classStr[i];\n\t\t\t\t\tcls[cls.contains(node, c) ? \"remove\" : \"add\"](node, c);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcls[condition ? \"add\" : \"remove\"](node, classStr);\n\t\t\t}\n\t\t\treturn condition;   // Boolean\n\t\t}\n\t};\n\n\treturn cls;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-construct.js":"define([\"exports\", \"./_base/kernel\", \"./sniff\", \"./_base/window\", \"./dom\", \"./dom-attr\"],\n\t\tfunction(exports, dojo, has, win, dom, attr){\n\t// module:\n\t//\t\tdojo/dom-construct\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM construction API.\n\n\t// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42\n\n\t// support stuff for toDom()\n\tvar tagWrap = {\n\t\t\toption: [\"select\"],\n\t\t\ttbody: [\"table\"],\n\t\t\tthead: [\"table\"],\n\t\t\ttfoot: [\"table\"],\n\t\t\ttr: [\"table\", \"tbody\"],\n\t\t\ttd: [\"table\", \"tbody\", \"tr\"],\n\t\t\tth: [\"table\", \"thead\", \"tr\"],\n\t\t\tlegend: [\"fieldset\"],\n\t\t\tcaption: [\"table\"],\n\t\t\tcolgroup: [\"table\"],\n\t\t\tcol: [\"table\", \"colgroup\"],\n\t\t\tli: [\"ul\"]\n\t\t},\n\t\treTag = /<\\s*([\\w\\:]+)/,\n\t\tmasterNode = {}, masterNum = 0,\n\t\tmasterName = \"__\" + dojo._scopeName + \"ToDomId\";\n\n\t// generate start/end tag strings to use\n\t// for the injection for each special tag wrap case.\n\tfor(var param in tagWrap){\n\t\tif(tagWrap.hasOwnProperty(param)){\n\t\t\tvar tw = tagWrap[param];\n\t\t\ttw.pre = param == \"option\" ? '<select multiple=\"multiple\">' : \"<\" + tw.join(\"><\") + \">\";\n\t\t\ttw.post = \"</\" + tw.reverse().join(\"></\") + \">\";\n\t\t\t// the last line is destructive: it reverses the array,\n\t\t\t// but we don't care at this point\n\t\t}\n\t}\n\n\tvar html5domfix;\n\tif(has(\"ie\") <= 8){\n\t\thtml5domfix = function(doc){\n\t\t\tdoc.__dojo_html5_tested = \"yes\";\n\t\t\tvar div = create('div', {innerHTML: \"<nav>a</nav>\", style: {visibility: \"hidden\"}}, doc.body);\n\t\t\tif(div.childNodes.length !== 1){\n\t\t\t\t('abbr article aside audio canvas details figcaption figure footer header ' +\n\t\t\t\t'hgroup mark meter nav output progress section summary time video').replace(\n\t\t\t\t\t/\\b\\w+\\b/g, function(n){\n\t\t\t\t\t\tdoc.createElement(n);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tdestroy(div);\n\t\t}\n\t}\n\n\tfunction _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tparent.insertBefore(node, ref);\n\t\t}\n\t}\n\n\tfunction _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){\n\t\t// summary:\n\t\t//\t\tTry to insert node after ref\n\t\tvar parent = ref.parentNode;\n\t\tif(parent){\n\t\t\tif(parent.lastChild == ref){\n\t\t\t\tparent.appendChild(node);\n\t\t\t}else{\n\t\t\t\tparent.insertBefore(node, ref.nextSibling);\n\t\t\t}\n\t\t}\n\t}\n\n\texports.toDom = function toDom(frag, doc){\n\t\t// summary:\n\t\t//\t\tinstantiates an HTML fragment returning the corresponding DOM.\n\t\t// frag: String\n\t\t//\t\tthe HTML fragment\n\t\t// doc: DocumentNode?\n\t\t//\t\toptional document to use when creating DOM nodes, defaults to\n\t\t//\t\tdojo/_base/window.doc if not specified.\n\t\t// returns:\n\t\t//\t\tDocument fragment, unless it's a single node in which case it returns the node itself\n\t\t// example:\n\t\t//\t\tCreate a table row:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tvar tr = domConstruct.toDom(\"<tr><td>First!</td></tr>\");\n\t\t//\t|\t});\n\n\t\tdoc = doc || win.doc;\n\t\tvar masterId = doc[masterName];\n\t\tif(!masterId){\n\t\t\tdoc[masterName] = masterId = ++masterNum + \"\";\n\t\t\tmasterNode[masterId] = doc.createElement(\"div\");\n\t\t}\n\n\t\tif(has(\"ie\") <= 8){\n\t\t\tif(!doc.__dojo_html5_tested && doc.body){\n\t\t\t\thtml5domfix(doc);\n\t\t\t}\n\t\t}\n\n\t\t// make sure the frag is a string.\n\t\tfrag += \"\";\n\n\t\t// find the starting tag, and get node wrapper\n\t\tvar match = frag.match(reTag),\n\t\t\ttag = match ? match[1].toLowerCase() : \"\",\n\t\t\tmaster = masterNode[masterId],\n\t\t\twrap, i, fc, df;\n\t\tif(match && tagWrap[tag]){\n\t\t\twrap = tagWrap[tag];\n\t\t\tmaster.innerHTML = wrap.pre + frag + wrap.post;\n\t\t\tfor(i = wrap.length; i; --i){\n\t\t\t\tmaster = master.firstChild;\n\t\t\t}\n\t\t}else{\n\t\t\tmaster.innerHTML = frag;\n\t\t}\n\n\t\t// one node shortcut => return the node itself\n\t\tif(master.childNodes.length == 1){\n\t\t\treturn master.removeChild(master.firstChild); // DOMNode\n\t\t}\n\n\t\t// return multiple nodes as a document fragment\n\t\tdf = doc.createDocumentFragment();\n\t\twhile((fc = master.firstChild)){ // intentional assignment\n\t\t\tdf.appendChild(fc);\n\t\t}\n\t\treturn df; // DocumentFragment\n\t};\n\n\texports.place = function place(/*DOMNode|String*/ node, /*DOMNode|String*/ refNode, /*String|Number?*/ position){\n\t\t// summary:\n\t\t//\t\tAttempt to insert node into the DOM, choosing from various positioning options.\n\t\t//\t\tReturns the first argument resolved to a DOM node.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or node reference, or HTML fragment starting with \"<\" to place relative to refNode\n\t\t// refNode: DOMNode|String\n\t\t//\t\tid or node reference to use as basis for placement\n\t\t// position: String|Number?\n\t\t//\t\tstring noting the position of node relative to refNode or a\n\t\t//\t\tnumber indicating the location in the childNodes collection of refNode.\n\t\t//\t\tAccepted string values are:\n\t\t//\n\t\t//\t\t- before\n\t\t//\t\t- after\n\t\t//\t\t- replace\n\t\t//\t\t- only\n\t\t//\t\t- first\n\t\t//\t\t- last\n\t\t//\n\t\t//\t\t\"first\" and \"last\" indicate positions as children of refNode, \"replace\" replaces refNode,\n\t\t//\t\t\"only\" replaces all children.  position defaults to \"last\" if not specified\n\t\t// returns: DOMNode\n\t\t//\t\tReturned values is the first argument resolved to a DOM node.\n\t\t//\n\t\t//\t\t.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.\n\t\t// example:\n\t\t//\t\tPlace a node by string id as the last child of another node by string id:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.place(\"someNode\", \"anotherNode\");\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tPlace a node by string id before another node by string id\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.place(\"someNode\", \"anotherNode\", \"before\");\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tCreate a Node, and place it in the body element (last child):\n\t\t//\t|\trequire([\"dojo/dom-construct\", \"dojo/_base/window\"\n\t\t//\t|\t], function(domConstruct, win){\n\t\t//\t|\t\tdomConstruct.place(\"<div></div>\", win.body());\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tPut a new LI as the first child of a list by id:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.place(\"<li></li>\", \"someUl\", \"first\");\n\t\t//\t|\t});\n\n\t\trefNode = dom.byId(refNode);\n\t\tif(typeof node == \"string\"){ // inline'd type check\n\t\t\tnode = /^\\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);\n\t\t}\n\t\tif(typeof position == \"number\"){ // inline'd type check\n\t\t\tvar cn = refNode.childNodes;\n\t\t\tif(!cn.length || cn.length <= position){\n\t\t\t\trefNode.appendChild(node);\n\t\t\t}else{\n\t\t\t\t_insertBefore(node, cn[position < 0 ? 0 : position]);\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(position){\n\t\t\t\tcase \"before\":\n\t\t\t\t\t_insertBefore(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\":\n\t\t\t\t\t_insertAfter(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"replace\":\n\t\t\t\t\trefNode.parentNode.replaceChild(node, refNode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"only\":\n\t\t\t\t\texports.empty(refNode);\n\t\t\t\t\trefNode.appendChild(node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"first\":\n\t\t\t\t\tif(refNode.firstChild){\n\t\t\t\t\t\t_insertBefore(node, refNode.firstChild);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// else fallthrough...\n\t\t\t\tdefault: // aka: last\n\t\t\t\t\trefNode.appendChild(node);\n\t\t\t}\n\t\t}\n\t\treturn node; // DomNode\n\t};\n\n\tvar create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){\n\t\t// summary:\n\t\t//\t\tCreate an element, allowing for optional attribute decoration\n\t\t//\t\tand placement.\n\t\t// description:\n\t\t//\t\tA DOM Element creation function. A shorthand method for creating a node or\n\t\t//\t\ta fragment, and allowing for a convenient optional attribute setting step,\n\t\t//\t\tas well as an optional DOM placement reference.\n\t\t//\n\t\t//\t\tAttributes are set by passing the optional object through `dojo.setAttr`.\n\t\t//\t\tSee `dojo.setAttr` for noted caveats and nuances, and API if applicable.\n\t\t//\n\t\t//\t\tPlacement is done via `dojo.place`, assuming the new node to be the action\n\t\t//\t\tnode, passing along the optional reference node and position.\n\t\t// tag: DOMNode|String\n\t\t//\t\tA string of the element to create (eg: \"div\", \"a\", \"p\", \"li\", \"script\", \"br\"),\n\t\t//\t\tor an existing DOM node to process.\n\t\t// attrs: Object\n\t\t//\t\tAn object-hash of attributes to set on the newly created node.\n\t\t//\t\tCan be null, if you don't want to set any attributes/styles.\n\t\t//\t\tSee: `dojo.setAttr` for a description of available attributes.\n\t\t// refNode: DOMNode|String?\n\t\t//\t\tOptional reference node. Used by `dojo.place` to place the newly created\n\t\t//\t\tnode somewhere in the dom relative to refNode. Can be a DomNode reference\n\t\t//\t\tor String ID of a node.\n\t\t// pos: String?\n\t\t//\t\tOptional positional reference. Defaults to \"last\" by way of `dojo.place`,\n\t\t//\t\tthough can be set to \"first\",\"after\",\"before\",\"last\", \"replace\" or \"only\"\n\t\t//\t\tto further control the placement of the new node relative to the refNode.\n\t\t//\t\t'refNode' is required if a 'pos' is specified.\n\t\t// example:\n\t\t//\t\tCreate a DIV:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tvar n = domConstruct.create(\"div\");\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate a DIV with content:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tvar n = domConstruct.create(\"div\", { innerHTML:\"<p>hi</p>\" });\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tPlace a new DIV in the BODY, with no attributes set\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tvar n = domConstruct.create(\"div\", null, dojo.body());\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate an UL, and populate it with LI's. Place the list as the first-child of a\n\t\t//\t\tnode with id=\"someId\":\n\t\t//\t|\trequire([\"dojo/dom-construct\", \"dojo/_base/array\"],\n\t\t//\t|\tfunction(domConstruct, arrayUtil){\n\t\t//\t|\t\tvar ul = domConstruct.create(\"ul\", null, \"someId\", \"first\");\n\t\t//\t|\t\tvar items = [\"one\", \"two\", \"three\", \"four\"];\n\t\t//\t|\t\tarrayUtil.forEach(items, function(data){\n\t\t//\t|\t\t\tdomConstruct.create(\"li\", { innerHTML: data }, ul);\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tCreate an anchor, with an href. Place in BODY:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.create(\"a\", { href:\"foo.html\", title:\"Goto FOO!\" }, dojo.body());\n\t\t//\t|\t});\n\n\t\tvar doc = win.doc;\n\t\tif(refNode){\n\t\t\trefNode = dom.byId(refNode);\n\t\t\tdoc = refNode.ownerDocument;\n\t\t}\n\t\tif(typeof tag == \"string\"){ // inline'd type check\n\t\t\ttag = doc.createElement(tag);\n\t\t}\n\t\tif(attrs){ attr.set(tag, attrs); }\n\t\tif(refNode){ exports.place(tag, refNode, pos); }\n\t\treturn tag; // DomNode\n\t};\n\n\tfunction _empty(/*DomNode*/ node){\n\t\tif(node.canHaveChildren){\n\t\t\ttry{\n\t\t\t\t// fast path\n\t\t\t\tnode.innerHTML = \"\";\n\t\t\t\treturn;\n\t\t\t}catch(e){\n\t\t\t\t// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)\n\t\t\t\t// Fall through (saves bytes)\n\t\t\t}\n\t\t}\n\t\t// SVG/strict elements don't support innerHTML/canHaveChildren, and OBJECT/APPLET elements in quirks node have canHaveChildren=false\n\t\tfor(var c; c = node.lastChild;){ // intentional assignment\n\t\t\t_destroy(c, node); // destroy is better than removeChild so TABLE subelements are removed in proper order\n\t\t}\n\t}\n\n\texports.empty = function empty(/*DOMNode|String*/ node){\n\t\t// summary:\n\t\t//\t\tsafely removes all children of the node.\n\t\t// node: DOMNode|String\n\t\t//\t\ta reference to a DOM node or an id.\n\t\t// example:\n\t\t//\t\tDestroy node's children byId:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.empty(\"someId\");\n\t\t//\t|\t});\n\n\t\t_empty(dom.byId(node));\n\t};\n\n\n\tfunction _destroy(/*DomNode*/ node, /*DomNode*/ parent){\n\t\t// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)\n\t\tif(node.firstChild){\n\t\t\t_empty(node);\n\t\t}\n\t\tif(parent){\n\t\t\t// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.\n\t\t\t// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and\n\t\t\t// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.\n\t\t\t// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.\n\t\t\thas(\"ie\") && parent.canHaveChildren && \"removeNode\" in node ? node.removeNode(false) : parent.removeChild(node);\n\t\t}\n\t}\n\tvar destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){\n\t\t// summary:\n\t\t//\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t//\t\tchildren.\n\t\t//\n\t\t// description:\n\t\t//\t\tRemoves a node from its parent, clobbering it and all of its\n\t\t//\t\tchildren. Function only works with DomNodes, and returns nothing.\n\t\t//\n\t\t// node: DOMNode|String\n\t\t//\t\tA String ID or DomNode reference of the element to be destroyed\n\t\t//\n\t\t// example:\n\t\t//\t\tDestroy a node byId:\n\t\t//\t|\trequire([\"dojo/dom-construct\"], function(domConstruct){\n\t\t//\t|\t\tdomConstruct.destroy(\"someId\");\n\t\t//\t|\t});\n\n\t\tnode = dom.byId(node);\n\t\tif(!node){ return; }\n\t\t_destroy(node, node.parentNode);\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-form.js":"define([\"./_base/lang\", \"./dom\", \"./io-query\", \"./json\"], function(lang, dom, ioq, json){\n\t// module:\n\t//\t\tdojo/dom-form\n\n    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){\n        // summary:\n        //\t\tFor the named property in object, set the value. If a value\n        //\t\talready exists and it is a string, convert the value to be an\n        //\t\tarray of values.\n\n        // Skip it if there is no value\n        if(value === null){\n            return;\n        }\n\n        var val = obj[name];\n        if(typeof val == \"string\"){ // inline'd type check\n            obj[name] = [val, value];\n        }else if(lang.isArray(val)){\n            val.push(value);\n        }else{\n            obj[name] = value;\n        }\n    }\n\n\tvar exclude = \"file|submit|image|reset|button\";\n\n\tvar form = {\n\t\t// summary:\n\t\t//\t\tThis module defines form-processing functions.\n\n\t\tfieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){\n\t\t\t// summary:\n\t\t\t//\t\tSerialize a form field to a JavaScript object.\n\t\t\t// description:\n\t\t\t//\t\tReturns the value encoded in a form field as\n\t\t\t//\t\tas a string or an array of strings. Disabled form elements\n\t\t\t//\t\tand unchecked radio and checkboxes are skipped.\tMulti-select\n\t\t\t//\t\telements are returned as an array of string values.\n\t\t\t// inputNode: DOMNode|String\n\t\t\t// returns: Object\n\n\t\t\tvar ret = null;\n\t\t\tinputNode = dom.byId(inputNode);\n\t\t\tif(inputNode){\n\t\t\t\tvar _in = inputNode.name, type = (inputNode.type || \"\").toLowerCase();\n\t\t\t\tif(_in && type && !inputNode.disabled){\n\t\t\t\t\tif(type == \"radio\" || type == \"checkbox\"){\n\t\t\t\t\t\tif(inputNode.checked){\n\t\t\t\t\t\t\tret = inputNode.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(inputNode.multiple){\n\t\t\t\t\t\tret = [];\n\t\t\t\t\t\tvar nodes = [inputNode.firstChild];\n\t\t\t\t\t\twhile(nodes.length){\n\t\t\t\t\t\t\tfor(var node = nodes.pop(); node; node = node.nextSibling){\n\t\t\t\t\t\t\t\tif(node.nodeType == 1 && node.tagName.toLowerCase() == \"option\"){\n\t\t\t\t\t\t\t\t\tif(node.selected){\n\t\t\t\t\t\t\t\t\t\tret.push(node.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tif(node.nextSibling){\n\t\t\t\t\t\t\t\t\t\tnodes.push(node.nextSibling);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(node.firstChild){\n\t\t\t\t\t\t\t\t\t\tnodes.push(node.firstChild);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret = inputNode.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret; // Object\n\t\t},\n\n\t\ttoObject: function formToObject(/*DOMNode|String*/ formNode){\n\t\t\t// summary:\n\t\t\t//\t\tSerialize a form node to a JavaScript object.\n\t\t\t// description:\n\t\t\t//\t\tReturns the values encoded in an HTML form as\n\t\t\t//\t\tstring properties in an object which it then returns. Disabled form\n\t\t\t//\t\telements, buttons, and other non-value form elements are skipped.\n\t\t\t//\t\tMulti-select elements are returned as an array of string values.\n\t\t\t// formNode: DOMNode|String\n\t\t\t// example:\n\t\t\t//\t\tThis form:\n\t\t\t//\t\t|\t<form id=\"test_form\">\n\t\t\t//\t\t|\t\t<input type=\"text\" name=\"blah\" value=\"blah\">\n\t\t\t//\t\t|\t\t<input type=\"text\" name=\"no_value\" value=\"blah\" disabled>\n\t\t\t//\t\t|\t\t<input type=\"button\" name=\"no_value2\" value=\"blah\">\n\t\t\t//\t\t|\t\t<select type=\"select\" multiple name=\"multi\" size=\"5\">\n\t\t\t//\t\t|\t\t\t<option value=\"blah\">blah</option>\n\t\t\t//\t\t|\t\t\t<option value=\"thud\" selected>thud</option>\n\t\t\t//\t\t|\t\t\t<option value=\"thonk\" selected>thonk</option>\n\t\t\t//\t\t|\t\t</select>\n\t\t\t//\t\t|\t</form>\n\t\t\t//\n\t\t\t//\t\tyields this object structure as the result of a call to\n\t\t\t//\t\tformToObject():\n\t\t\t//\n\t\t\t//\t\t|\t{\n\t\t\t//\t\t|\t\tblah: \"blah\",\n\t\t\t//\t\t|\t\tmulti: [\n\t\t\t//\t\t|\t\t\t\"thud\",\n\t\t\t//\t\t|\t\t\t\"thonk\"\n\t\t\t//\t\t|\t\t]\n\t\t\t//\t\t|\t};\n\n\t\t\tvar ret = {}, elems = dom.byId(formNode).elements;\n\t\t\tfor(var i = 0, l = elems.length; i < l; ++i){\n\t\t\t\tvar item = elems[i], _in = item.name, type = (item.type || \"\").toLowerCase();\n\t\t\t\tif(_in && type && exclude.indexOf(type) < 0 && !item.disabled){\n\t\t\t\t\tsetValue(ret, _in, form.fieldToObject(item));\n\t\t\t\t\tif(type == \"image\"){\n\t\t\t\t\t\tret[_in + \".x\"] = ret[_in + \".y\"] = ret[_in].x = ret[_in].y = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret; // Object\n\t\t},\n\n\t\ttoQuery: function formToQuery(/*DOMNode|String*/ formNode){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a URL-encoded string representing the form passed as either a\n\t\t\t//\t\tnode or string ID identifying the form to serialize\n\t\t\t// formNode: DOMNode|String\n\t\t\t// returns: String\n\n\t\t\treturn ioq.objectToQuery(form.toObject(formNode)); // String\n\t\t},\n\n\t\ttoJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a serialized JSON string from a form node or string\n\t\t\t//\t\tID identifying the form to serialize\n\t\t\t// formNode: DOMNode|String\n\t\t\t// prettyPrint: Boolean?\n\t\t\t// returns: String\n\n\t\t\treturn json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String\n\t\t}\n\t};\n\n    return form;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-geometry.js":"define([\"./sniff\", \"./_base/window\",\"./dom\", \"./dom-style\"],\n\t\tfunction(has, win, dom, style){\n\t// module:\n\t//\t\tdojo/dom-geometry\n\n\t// the result object\n\tvar geom = {\n\t\t// summary:\n\t\t//\t\tThis module defines the core dojo DOM geometry API.\n\t};\n\n\t// Box functions will assume this model.\n\t// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.\n\t// Can be set to change behavior of box setters.\n\n\t// can be either:\n\t//\t\"border-box\"\n\t//\t\"content-box\" (default)\n\tgeom.boxModel = \"content-box\";\n\n\t// We punt per-node box mode testing completely.\n\t// If anybody cares, we can provide an additional (optional) unit\n\t// that overrides existing code to include per-node box sensitivity.\n\n\t// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.\n\t// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.\n\t// IIRC, earlier versions of Opera did in fact use border-box.\n\t// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.\n\n\tif(has(\"ie\") /*|| has(\"opera\")*/){\n\t\t// client code may have to adjust if compatMode varies across iframes\n\t\tgeom.boxModel = document.compatMode == \"BackCompat\" ? \"border-box\" : \"content-box\";\n\t}\n\n\tgeom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns object with special values specifically useful for node\n\t\t//\t\tfitting.\n\t\t// description:\n\t\t//\t\tReturns an object with `w`, `h`, `l`, `t` properties:\n\t\t//\t|\t\tl/t/r/b = left/top/right/bottom padding (respectively)\n\t\t//\t|\t\tw = the total of the left and right padding\n\t\t//\t|\t\th = the total of the top and bottom padding\n\t\t//\t\tIf 'node' has position, l/t forms the origin for child nodes.\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tvar none = \"none\";\n\n\tgeom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object with properties useful for noting the border\n\t\t//\t\tdimensions.\n\t\t// description:\n\t\t//\t\t- l/t/r/b = the sum of left/top/right/bottom border (respectively)\n\t\t//\t\t- w = the sum of the left and right border\n\t\t//\t\t- h = the sum of the top and bottom border\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),\n\t\t\tl = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,\n\t\t\tt = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,\n\t\t\tr = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,\n\t\t\tb = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\tgeom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns object with properties useful for box fitting with\n\t\t//\t\tregards to padding.\n\t\t// description:\n\t\t//\t\t- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)\n\t\t//\t\t- w = the sum of the left and right padding and border\n\t\t//\t\t- h = the sum of the top and bottom padding and border\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node),\n\t\t\tp = geom.getPadExtents(node, s),\n\t\t\tb = geom.getBorderExtents(node, s);\n\t\treturn {\n\t\t\tl: p.l + b.l,\n\t\t\tt: p.t + b.t,\n\t\t\tr: p.r + b.r,\n\t\t\tb: p.b + b.b,\n\t\t\tw: p.w + b.w,\n\t\t\th: p.h + b.h\n\t\t};\n\t};\n\n\tgeom.getMarginExtents = function getMarginExtents(node, computedStyle){\n\t\t// summary:\n\t\t//\t\treturns object with properties useful for box fitting with\n\t\t//\t\tregards to box margins (i.e., the outer-box).\n\t\t//\n\t\t//\t\t- l/t = marginLeft, marginTop, respectively\n\t\t//\t\t- w = total width, margin inclusive\n\t\t//\t\t- h = total height, margin inclusive\n\t\t//\n\t\t//\t\tThe w/h are used for calculating boxes.\n\t\t//\t\tNormally application code will not need to invoke this\n\t\t//\t\tdirectly, and will use the ...box... functions instead.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,\n\t\t\tl = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);\n\t\treturn {l: l, t: t, r: r, b: b, w: l + r, h: t + b};\n\t};\n\n\t// Box getters work in any box context because offsetWidth/clientWidth\n\t// are invariant wrt box context\n\t//\n\t// They do *not* work for display: inline objects that have padding styles\n\t// because the user agent ignores padding (it's bogus styling in any case)\n\t//\n\t// Be careful with IMGs because they are inline or block depending on\n\t// browser and browser mode.\n\n\t// Although it would be easier to read, there are not separate versions of\n\t// _getMarginBox for each browser because:\n\t// 1. the branching is not expensive\n\t// 2. factoring the shared code wastes cycles (function call overhead)\n\t// 3. duplicating the shared code wastes bytes\n\n\tgeom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object that encodes the width, height, left and top\n\t\t//\t\tpositions of the node's margin box.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),\n\t\t\tl = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;\n\t\tif(has(\"mozilla\")){\n\t\t\t// Mozilla:\n\t\t\t// If offsetParent has a computed overflow != visible, the offsetLeft is decreased\n\t\t\t// by the parent's border.\n\t\t\t// We don't want to compute the parent's style, so instead we examine node's\n\t\t\t// computed left/top which is more stable.\n\t\t\tvar sl = parseFloat(s.left), st = parseFloat(s.top);\n\t\t\tif(!isNaN(sl) && !isNaN(st)){\n\t\t\t\tl = sl;\n\t\t\t\tt = st;\n\t\t\t}else{\n\t\t\t\t// If child's computed left/top are not parseable as a number (e.g. \"auto\"), we\n\t\t\t\t// have no choice but to examine the parent's computed style.\n\t\t\t\tif(p && p.style){\n\t\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\t\tif(pcs.overflow != \"visible\"){\n\t\t\t\t\t\tl += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\n\t\t\t\t\t\tt += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(has(\"opera\") || (has(\"ie\") == 8 && !has(\"quirks\"))){\n\t\t\t// On Opera and IE 8, offsetLeft/Top includes the parent's border\n\t\t\tif(p){\n\t\t\t\tpcs = style.getComputedStyle(p);\n\t\t\t\tl -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;\n\t\t\t\tt -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;\n\t\t\t}\n\t\t}\n\t\treturn {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};\n\t};\n\n\tgeom.getContentBox = function getContentBox(node, computedStyle){\n\t\t// summary:\n\t\t//\t\tReturns an object that encodes the width, height, left and top\n\t\t//\t\tpositions of the node's content box, irrespective of the\n\t\t//\t\tcurrent box model.\n\t\t// node: DOMNode\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\t// clientWidth/Height are important since the automatically account for scrollbars\n\t\t// fallback to offsetWidth/Height for special cases (see #3378)\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,\n\t\t\tpe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);\n\t\tif(!w){\n\t\t\tw = node.offsetWidth;\n\t\t\th = node.offsetHeight;\n\t\t}else{\n\t\t\th = node.clientHeight;\n\t\t\tbe.w = be.h = 0;\n\t\t}\n\t\t// On Opera, offsetLeft includes the parent's border\n\t\tif(has(\"opera\")){\n\t\t\tpe.l += be.l;\n\t\t\tpe.t += be.t;\n\t\t}\n\t\treturn {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};\n\t};\n\n\t// Box setters depend on box context because interpretation of width/height styles\n\t// vary wrt box context.\n\t//\n\t// The value of boxModel is used to determine box context.\n\t// boxModel can be set directly to change behavior.\n\t//\n\t// Beware of display: inline objects that have padding styles\n\t// because the user agent ignores padding (it's a bogus setup anyway)\n\t//\n\t// Be careful with IMGs because they are inline or block depending on\n\t// browser and browser mode.\n\t//\n\t// Elements other than DIV may have special quirks, like built-in\n\t// margins or padding, or values not detectable via computedStyle.\n\t// In particular, margins on TABLE do not seems to appear\n\t// at all in computedStyle on Mozilla.\n\n\tfunction setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){\n\t\t// summary:\n\t\t//\t\tsets width/height/left/top in the current (native) box-model\n\t\t//\t\tdimensions. Uses the unit passed in u.\n\t\t// node:\n\t\t//\t\tDOM Node reference. Id string not supported for performance\n\t\t//\t\treasons.\n\t\t// l:\n\t\t//\t\tleft offset from parent.\n\t\t// t:\n\t\t//\t\ttop offset from parent.\n\t\t// w:\n\t\t//\t\twidth in current box model.\n\t\t// h:\n\t\t//\t\twidth in current box model.\n\t\t// u:\n\t\t//\t\tunit measure to use for other measures. Defaults to \"px\".\n\t\tu = u || \"px\";\n\t\tvar s = node.style;\n\t\tif(!isNaN(l)){\n\t\t\ts.left = l + u;\n\t\t}\n\t\tif(!isNaN(t)){\n\t\t\ts.top = t + u;\n\t\t}\n\t\tif(w >= 0){\n\t\t\ts.width = w + u;\n\t\t}\n\t\tif(h >= 0){\n\t\t\ts.height = h + u;\n\t\t}\n\t}\n\n\tfunction isButtonTag(/*DomNode*/ node){\n\t\t// summary:\n\t\t//\t\tTrue if the node is BUTTON or INPUT.type=\"button\".\n\t\treturn node.tagName.toLowerCase() == \"button\" ||\n\t\t\tnode.tagName.toLowerCase() == \"input\" && (node.getAttribute(\"type\") || \"\").toLowerCase() == \"button\"; // boolean\n\t}\n\n\tfunction usesBorderBox(/*DomNode*/ node){\n\t\t// summary:\n\t\t//\t\tTrue if the node uses border-box layout.\n\n\t\t// We could test the computed style of node to see if a particular box\n\t\t// has been specified, but there are details and we choose not to bother.\n\n\t\t// TABLE and BUTTON (and INPUT type=button) are always border-box by default.\n\t\t// If you have assigned a different box to either one via CSS then\n\t\t// box functions will break.\n\n\t\treturn geom.boxModel == \"border-box\" || node.tagName.toLowerCase() == \"table\" || isButtonTag(node); // boolean\n\t}\n\n\tgeom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\tSets the size of the node's contents, irrespective of margins,\n\t\t//\t\tpadding, or borders.\n\t\t// node: DOMNode\n\t\t// box: Object\n\t\t//\t\thash with optional \"w\", and \"h\" properties for \"width\", and \"height\"\n\t\t//\t\trespectively. All specified properties should have numeric values in whole pixels.\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar w = box.w, h = box.h;\n\t\tif(usesBorderBox(node)){\n\t\t\tvar pb = geom.getPadBorderExtents(node, computedStyle);\n\t\t\tif(w >= 0){\n\t\t\t\tw += pb.w;\n\t\t\t}\n\t\t\tif(h >= 0){\n\t\t\t\th += pb.h;\n\t\t\t}\n\t\t}\n\t\tsetBox(node, NaN, NaN, w, h);\n\t};\n\n\tvar nilExtents = {l: 0, t: 0, w: 0, h: 0};\n\n\tgeom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\tsets the size of the node's margin box and placement\n\t\t//\t\t(left/top), irrespective of box model. Think of it as a\n\t\t//\t\tpassthrough to setBox that handles box-model vagaries for\n\t\t//\t\tyou.\n\t\t// node: DOMNode\n\t\t// box: Object\n\t\t//\t\thash with optional \"l\", \"t\", \"w\", and \"h\" properties for \"left\", \"right\", \"width\", and \"height\"\n\t\t//\t\trespectively. All specified properties should have numeric values in whole pixels.\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,\n\t\t// Some elements have special padding, margin, and box-model settings.\n\t\t// To use box functions you may need to set padding, margin explicitly.\n\t\t// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.\n\t\t\tpb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),\n\t\t\tmb = geom.getMarginExtents(node, s);\n\t\tif(has(\"webkit\")){\n\t\t\t// on Safari (3.1.2), button nodes with no explicit size have a default margin\n\t\t\t// setting an explicit size eliminates the margin.\n\t\t\t// We have to swizzle the width to get correct margin reading.\n\t\t\tif(isButtonTag(node)){\n\t\t\t\tvar ns = node.style;\n\t\t\t\tif(w >= 0 && !ns.width){\n\t\t\t\t\tns.width = \"4px\";\n\t\t\t\t}\n\t\t\t\tif(h >= 0 && !ns.height){\n\t\t\t\t\tns.height = \"4px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(w >= 0){\n\t\t\tw = Math.max(w - pb.w - mb.w, 0);\n\t\t}\n\t\tif(h >= 0){\n\t\t\th = Math.max(h - pb.h - mb.h, 0);\n\t\t}\n\t\tsetBox(node, box.l, box.t, w, h);\n\t};\n\n\t// =============================\n\t// Positioning\n\t// =============================\n\n\tgeom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){\n\t\t// summary:\n\t\t//\t\tReturns true if the current language is left-to-right, and false otherwise.\n\t\t// doc: Document?\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\n\t\t// returns: Boolean\n\n\t\tdoc = doc || win.doc;\n\t\treturn (win.body(doc).dir || doc.documentElement.dir || \"ltr\").toLowerCase() == \"ltr\"; // Boolean\n\t};\n\n\tgeom.docScroll = function docScroll(/*Document?*/ doc){\n\t\t// summary:\n\t\t//\t\tReturns an object with {node, x, y} with corresponding offsets.\n\t\t// doc: Document?\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\n\t\t// returns: Object\n\n\t\tdoc = doc || win.doc;\n\t\tvar node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem\n\t\treturn \"pageXOffset\" in node ? {x: node.pageXOffset, y: node.pageYOffset } :\n\t\t\t(node = has(\"quirks\") ? win.body(doc) : doc.documentElement) &&\n\t\t\t\t{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };\n\t};\n\n\tif(has(\"ie\")){\n\t\tgeom.getIeDocumentElementOffset = function getIeDocumentElementOffset(/*Document?*/ doc){\n\t\t\t// summary:\n\t\t\t//\t\treturns the offset in x and y from the document body to the\n\t\t\t//\t\tvisual edge of the page for IE\n\t\t\t// doc: Document?\n\t\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\n\t\t\t// description:\n\t\t\t//\t\tThe following values in IE contain an offset:\n\t\t\t//\t|\t\tevent.clientX\n\t\t\t//\t|\t\tevent.clientY\n\t\t\t//\t|\t\tnode.getBoundingClientRect().left\n\t\t\t//\t|\t\tnode.getBoundingClientRect().top\n\t\t\t//\t\tBut other position related values do not contain this offset,\n\t\t\t//\t\tsuch as node.offsetLeft, node.offsetTop, node.style.left and\n\t\t\t//\t\tnode.style.top. The offset is always (2, 2) in LTR direction.\n\t\t\t//\t\tWhen the body is in RTL direction, the offset counts the width\n\t\t\t//\t\tof left scroll bar's width.  This function computes the actual\n\t\t\t//\t\toffset.\n\n\t\t\t//NOTE: assumes we're being called in an IE browser\n\n\t\t\tdoc = doc || win.doc;\n\t\t\tvar de = doc.documentElement; // only deal with HTML element here, position() handles body/quirks\n\n\t\t\tif(has(\"ie\") < 8){\n\t\t\t\tvar r = de.getBoundingClientRect(), // works well for IE6+\n\t\t\t\t\tl = r.left, t = r.top;\n\t\t\t\tif(has(\"ie\") < 7){\n\t\t\t\t\tl += de.clientLeft;\t// scrollbar size in strict/RTL, or,\n\t\t\t\t\tt += de.clientTop;\t// HTML border size in strict\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tx: l < 0 ? 0 : l, // FRAME element border size can lead to inaccurate negative values\n\t\t\t\t\ty: t < 0 ? 0 : t\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\treturn {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\n\tgeom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){\n\t\t// summary:\n\t\t//\t\tIn RTL direction, scrollLeft should be a negative value, but IE\n\t\t//\t\treturns a positive one. All codes using documentElement.scrollLeft\n\t\t//\t\tmust call this function to fix this error, otherwise the position\n\t\t//\t\twill offset to right when there is a horizontal scrollbar.\n\t\t// scrollLeft: Number\n\t\t// doc: Document?\n\t\t//\t\tOptional document to query.   If unspecified, use win.doc.\n\t\t// returns: Number\n\n\t\t// In RTL direction, scrollLeft should be a negative value, but IE\n\t\t// returns a positive one. All codes using documentElement.scrollLeft\n\t\t// must call this function to fix this error, otherwise the position\n\t\t// will offset to right when there is a horizontal scrollbar.\n\n\t\tdoc = doc || win.doc;\n\t\tvar ie = has(\"ie\");\n\t\tif(ie && !geom.isBodyLtr(doc)){\n\t\t\tvar qk = has(\"quirks\"),\n\t\t\t\tde = qk ? win.body(doc) : doc.documentElement,\n\t\t\t\tpwin = win.global;\t// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js\n\t\t\tif(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){\n\t\t\t\tscrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels\n\t\t\t}\n\t\t\treturn (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer\n\t\t}\n\t\treturn scrollLeft; // Integer\n\t};\n\n\tgeom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){\n\t\t// summary:\n\t\t//\t\tGets the position and size of the passed element relative to\n\t\t//\t\tthe viewport (if includeScroll==false), or relative to the\n\t\t//\t\tdocument root (if includeScroll==true).\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an object of the form:\n\t\t//\t\t`{ x: 100, y: 300, w: 20, h: 15 }`.\n\t\t//\t\tIf includeScroll==true, the x and y values will include any\n\t\t//\t\tdocument offsets that may affect the position relative to the\n\t\t//\t\tviewport.\n\t\t//\t\tUses the border-box model (inclusive of border and padding but\n\t\t//\t\tnot margin).  Does not act as a setter.\n\t\t// node: DOMNode|String\n\t\t// includeScroll: Boolean?\n\t\t// returns: Object\n\n\t\tnode = dom.byId(node);\n\t\tvar\tdb = win.body(node.ownerDocument),\n\t\t\tret = node.getBoundingClientRect();\n\t\tret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};\n\n\t\tif(has(\"ie\") < 9){\n\t\t\t// On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()\n\t\t\tvar offset = geom.getIeDocumentElementOffset(node.ownerDocument);\n\n\t\t\t// fixes the position in IE, quirks mode\n\t\t\tret.x -= offset.x + (has(\"quirks\") ? db.clientLeft + db.offsetLeft : 0);\n\t\t\tret.y -= offset.y + (has(\"quirks\") ? db.clientTop + db.offsetTop : 0);\n\t\t}\n\n\t\t// account for document scrolling\n\t\t// if offsetParent is used, ret value already includes scroll position\n\t\t// so we may have to actually remove that value if !includeScroll\n\t\tif(includeScroll){\n\t\t\tvar scroll = geom.docScroll(node.ownerDocument);\n\t\t\tret.x += scroll.x;\n\t\t\tret.y += scroll.y;\n\t\t}\n\n\t\treturn ret; // Object\n\t};\n\n\t// random \"private\" functions wildly used throughout the toolkit\n\n\tgeom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){\n\t\t// summary:\n\t\t//\t\treturns an object that encodes the width and height of\n\t\t//\t\tthe node's margin box\n\t\t// node: DOMNode|String\n\t\t// computedStyle: Object?\n\t\t//\t\tThis parameter accepts computed styles object.\n\t\t//\t\tIf this parameter is omitted, the functions will call\n\t\t//\t\tdojo/dom-style.getComputedStyle to get one. It is a better way, calling\n\t\t//\t\tdojo/dom-style.getComputedStyle once, and then pass the reference to this\n\t\t//\t\tcomputedStyle parameter. Wherever possible, reuse the returned\n\t\t//\t\tobject of dojo/dom-style.getComputedStyle().\n\n\t\tnode = dom.byId(node);\n\t\tvar me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));\n\t\tvar size = node.getBoundingClientRect();\n\t\treturn {\n\t\t\tw: (size.right - size.left) + me.w,\n\t\t\th: (size.bottom - size.top) + me.h\n\t\t};\n\t};\n\n\tgeom.normalizeEvent = function(event){\n\t\t// summary:\n\t\t//\t\tNormalizes the geometry of a DOM event, normalizing the pageX, pageY,\n\t\t//\t\toffsetX, offsetY, layerX, and layerX properties\n\t\t// event: Object\n\t\tif(!(\"layerX\" in event)){\n\t\t\tevent.layerX = event.offsetX;\n\t\t\tevent.layerY = event.offsetY;\n\t\t}\n\t\tif(!has(\"dom-addeventlistener\")){\n\t\t\t// old IE version\n\t\t\t// FIXME: scroll position query is duped from dojo/_base/html to\n\t\t\t// avoid dependency on that entire module. Now that HTML is in\n\t\t\t// Base, we should convert back to something similar there.\n\t\t\tvar se = event.target;\n\t\t\tvar doc = (se && se.ownerDocument) || document;\n\t\t\t// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used\n\t\t\t// here rather than document.body\n\t\t\tvar docBody = has(\"quirks\") ? doc.body : doc.documentElement;\n\t\t\tvar offset = geom.getIeDocumentElementOffset(doc);\n\t\t\tevent.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;\n\t\t\tevent.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;\n\t\t}\n\t};\n\n\t// TODO: evaluate separate getters/setters for position and sizes?\n\n\treturn geom;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom.js":"define([\"./sniff\", \"./_base/window\"],\n\t\tfunction(has, win){\n\t// module:\n\t//\t\tdojo/dom\n\n\t// FIXME: need to add unit tests for all the semi-public methods\n\n\tif(has(\"ie\") <= 7){\n\t\ttry{\n\t\t\tdocument.execCommand(\"BackgroundImageCache\", false, true);\n\t\t}catch(e){\n\t\t\t// sane browsers don't have cache \"issues\"\n\t\t}\n\t}\n\n\t// =============================\n\t// DOM Functions\n\t// =============================\n\n\t// the result object\n\tvar dom = {\n\t\t// summary:\n\t\t//\t\tThis module defines the core dojo DOM API.\n\t};\n\n\tif(has(\"ie\")){\n\t\tdom.byId = function(id, doc){\n\t\t\tif(typeof id != \"string\"){\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tvar _d = doc || win.doc, te = id && _d.getElementById(id);\n\t\t\t// attributes.id.value is better than just id in case the\n\t\t\t// user has a name=id inside a form\n\t\t\tif(te && (te.attributes.id.value == id || te.id == id)){\n\t\t\t\treturn te;\n\t\t\t}else{\n\t\t\t\tvar eles = _d.all[id];\n\t\t\t\tif(!eles || eles.nodeName){\n\t\t\t\t\teles = [eles];\n\t\t\t\t}\n\t\t\t\t// if more than 1, choose first with the correct id\n\t\t\t\tvar i = 0;\n\t\t\t\twhile((te = eles[i++])){\n\t\t\t\t\tif((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){\n\t\t\t\t\t\treturn te;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}else{\n\t\tdom.byId = function(id, doc){\n\t\t\t// inline'd type check.\n\t\t\t// be sure to return null per documentation, to match IE branch.\n\t\t\treturn ((typeof id == \"string\") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode\n\t\t};\n\t}\n\t/*=====\n\t dom.byId = function(id, doc){\n\t\t// summary:\n\t\t//\t\tReturns DOM node with matching `id` attribute or falsy value (ex: null or undefined)\n\t\t//\t\tif not found.  If `id` is a DomNode, this function is a no-op.\n\t\t//\n\t\t// id: String|DOMNode\n\t\t//\t\tA string to match an HTML id attribute or a reference to a DOM Node\n\t\t//\n\t\t// doc: Document?\n\t\t//\t\tDocument to work in. Defaults to the current value of\n\t\t//\t\tdojo/_base/window.doc.  Can be used to retrieve\n\t\t//\t\tnode references from other documents.\n\t\t//\n\t\t// example:\n\t\t//\t\tLook up a node by ID:\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tvar n = dom.byId(\"foo\");\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tCheck if a node exists, and use it.\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tvar n = dom.byId(\"bar\");\n\t\t//\t|\t\tif(n){ doStuff() ... }\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tAllow string or DomNode references to be passed to a custom function:\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tvar foo = function(nodeOrId){\n\t\t//\t|\t\t\tnodeOrId = dom.byId(nodeOrId);\n\t\t//\t|\t\t\t// ... more stuff\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t };\n\t =====*/\n\n\tdom.isDescendant = function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){\n\t\t// summary:\n\t\t//\t\tReturns true if node is a descendant of ancestor\n\t\t// node: DOMNode|String\n\t\t//\t\tstring id or node reference to test\n\t\t// ancestor: DOMNode|String\n\t\t//\t\tstring id or node reference of potential parent to test against\n\t\t//\n\t\t// example:\n\t\t//\t\tTest is node id=\"bar\" is a descendant of node id=\"foo\"\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tif(dom.isDescendant(\"bar\", \"foo\")){ ... }\n\t\t//\t|\t});\n\n\t\ttry{\n\t\t\tnode = dom.byId(node);\n\t\t\tancestor = dom.byId(ancestor);\n\t\t\twhile(node){\n\t\t\t\tif(node == ancestor){\n\t\t\t\t\treturn true; // Boolean\n\t\t\t\t}\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\t}catch(e){ /* squelch, return false */ }\n\t\treturn false; // Boolean\n\t};\n\n\n\t// TODO: do we need setSelectable in the base?\n\n\t// Add feature test for user-select CSS property\n\t// (currently known to work in all but IE < 10 and Opera)\n\thas.add(\"css-user-select\", function(global, doc, element){\n\t\t// Avoid exception when dom.js is loaded in non-browser environments\n\t\tif(!element){ return false; }\n\t\t\n\t\tvar style = element.style;\n\t\tvar prefixes = [\"Khtml\", \"O\", \"ms\", \"Moz\", \"Webkit\"],\n\t\t\ti = prefixes.length,\n\t\t\tname = \"userSelect\",\n\t\t\tprefix;\n\n\t\t// Iterate prefixes from most to least likely\n\t\tdo{\n\t\t\tif(typeof style[name] !== \"undefined\"){\n\t\t\t\t// Supported; return property name\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}while(i-- && (name = prefixes[i] + \"UserSelect\"));\n\n\t\t// Not supported if we didn't return before now\n\t\treturn false;\n\t});\n\n\t/*=====\n\tdom.setSelectable = function(node, selectable){\n\t\t// summary:\n\t\t//\t\tEnable or disable selection on a node\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node\n\t\t// selectable: Boolean\n\t\t//\t\tstate to put the node in. false indicates unselectable, true\n\t\t//\t\tallows selection.\n\t\t// example:\n\t\t//\t\tMake the node id=\"bar\" unselectable\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tdom.setSelectable(\"bar\");\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tMake the node id=\"bar\" selectable\n\t\t//\t|\trequire([\"dojo/dom\"], function(dom){\n\t\t//\t|\t\tdom.setSelectable(\"bar\", true);\n\t\t//\t|\t});\n\t};\n\t=====*/\n\n\tvar cssUserSelect = has(\"css-user-select\");\n\tdom.setSelectable = cssUserSelect ? function(node, selectable){\n\t\t// css-user-select returns a (possibly vendor-prefixed) CSS property name\n\t\tdom.byId(node).style[cssUserSelect] = selectable ? \"\" : \"none\";\n\t} : function(node, selectable){\n\t\tnode = dom.byId(node);\n\n\t\t// (IE < 10 / Opera) Fall back to setting/removing the\n\t\t// unselectable attribute on the element and all its children\n\t\tvar nodes = node.getElementsByTagName(\"*\"),\n\t\t\ti = nodes.length;\n\n\t\tif(selectable){\n\t\t\tnode.removeAttribute(\"unselectable\");\n\t\t\twhile(i--){\n\t\t\t\tnodes[i].removeAttribute(\"unselectable\");\n\t\t\t}\n\t\t}else{\n\t\t\tnode.setAttribute(\"unselectable\", \"on\");\n\t\t\twhile(i--){\n\t\t\t\tnodes[i].setAttribute(\"unselectable\", \"on\");\n\t\t\t}\n\t\t}\n\t};\n\n\treturn dom;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-prop.js":"define([\"exports\", \"./_base/kernel\", \"./sniff\", \"./_base/lang\", \"./dom\", \"./dom-style\", \"./dom-construct\", \"./_base/connect\"],\n\t\tfunction(exports, dojo, has, lang, dom, style, ctr, conn){\n\t// module:\n\t//\t\tdojo/dom-prop\n\t// summary:\n\t//\t\tThis module defines the core dojo DOM properties API.\n\n\t// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42\n\n\t// =============================\n\t// Element properties Functions\n\t// =============================\n\n\t// helper to connect events\n\tvar _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + \"attrid\";\n\n\texports.names = {\n\t\t// properties renamed to avoid clashes with reserved words\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\",\n\t\t// properties written as camelCase\n\t\ttabindex: \"tabIndex\",\n\t\treadonly: \"readOnly\",\n\t\tcolspan: \"colSpan\",\n\t\tframeborder: \"frameBorder\",\n\t\trowspan: \"rowSpan\",\n\t\tvaluetype: \"valueType\"\n\t};\n\n\texports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){\n\t\t// summary:\n\t\t//\t\tGets a property on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized getting of properties on DOM nodes.\n\t\t//\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to get the property on\n\t\t// name: String\n\t\t//\t\tthe name of the property to get.\n\t\t// returns:\n\t\t//\t\tthe value of the requested property or its default value\n\t\t//\n\t\t// example:\n\t\t//\t|\t// get the current value of the \"foo\" property on a node\n\t\t//\t|\trequire([\"dojo/dom-prop\", \"dojo/dom\"], function(domProp, dom){\n\t\t//\t|\t\tdomProp.get(dom.byId(\"nodeId\"), \"foo\");\n\t\t//\t|\t\t// or we can just pass the id:\n\t\t//\t|\t\tdomProp.get(\"nodeId\", \"foo\");\n\t\t//\t|\t});\n\n\t\tnode = dom.byId(node);\n\t\tvar lc = name.toLowerCase(), propName = exports.names[lc] || name;\n\t\treturn node[propName];\t// Anything\n\t};\n\n\texports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){\n\t\t// summary:\n\t\t//\t\tSets a property on an HTML element.\n\t\t// description:\n\t\t//\t\tHandles normalized setting of properties on DOM nodes.\n\t\t//\n\t\t//\t\tWhen passing functions as values, note that they will not be\n\t\t//\t\tdirectly assigned to slots on the node, but rather the default\n\t\t//\t\tbehavior will be removed and the new behavior will be added\n\t\t//\t\tusing `dojo.connect()`, meaning that event handler properties\n\t\t//\t\twill be normalized and that some caveats with regards to\n\t\t//\t\tnon-standard behaviors for onsubmit apply. Namely that you\n\t\t//\t\tshould cancel form submission using `dojo.stopEvent()` on the\n\t\t//\t\tpassed event object instead of returning a boolean value from\n\t\t//\t\tthe handler itself.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to the element to set the property on\n\t\t// name: String|Object\n\t\t//\t\tthe name of the property to set, or a hash object to set\n\t\t//\t\tmultiple properties at once.\n\t\t// value: String?\n\t\t//\t\tThe value to set for the property\n\t\t// returns:\n\t\t//\t\tthe DOM node\n\t\t//\n\t\t// example:\n\t\t//\t|\t// use prop() to set the tab index\n\t\t//\t|\trequire([\"dojo/dom-prop\"], function(domProp){\n\t\t//\t|\t\tdomProp.set(\"nodeId\", \"tabIndex\", 3);\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tSet multiple values at once, including event handlers:\n\t\t//\t|\trequire([\"dojo/dom-prop\"], function(domProp){\n\t\t//\t|\t\tdomProp.set(\"formId\", {\n\t\t//\t|\t\t\t\"foo\": \"bar\",\n\t\t//\t|\t\t\t\"tabIndex\": -1,\n\t\t//\t|\t\t\t\"method\": \"POST\",\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\n\t\tnode = dom.byId(node);\n\t\tvar l = arguments.length;\n\t\tif(l == 2 && typeof name != \"string\"){ // inline'd type check\n\t\t\t// the object form of setter: the 2nd argument is a dictionary\n\t\t\tfor(var x in name){\n\t\t\t\texports.set(node, x, name[x]);\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tvar lc = name.toLowerCase(), propName = exports.names[lc] || name;\n\t\tif(propName == \"style\" && typeof value != \"string\"){ // inline'd type check\n\t\t\t// special case: setting a style\n\t\t\tstyle.set(node, value);\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(propName == \"innerHTML\"){\n\t\t\t// special case: assigning HTML\n\t\t\t// the hash lists elements with read-only innerHTML on IE\n\t\t\tif(has(\"ie\") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,\n\t\t\t\t\t\ttable: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){\n\t\t\t\tctr.empty(node);\n\t\t\t\tnode.appendChild(ctr.toDom(value, node.ownerDocument));\n\t\t\t}else{\n\t\t\t\tnode[propName] = value;\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tif(lang.isFunction(value)){\n\t\t\t// special case: assigning an event handler\n\t\t\t// clobber if we can\n\t\t\tvar attrId = node[_attrId];\n\t\t\tif(!attrId){\n\t\t\t\tattrId = _ctr++;\n\t\t\t\tnode[_attrId] = attrId;\n\t\t\t}\n\t\t\tif(!_evtHdlrMap[attrId]){\n\t\t\t\t_evtHdlrMap[attrId] = {};\n\t\t\t}\n\t\t\tvar h = _evtHdlrMap[attrId][propName];\n\t\t\tif(h){\n\t\t\t\t//h.remove();\n\t\t\t\tconn.disconnect(h);\n\t\t\t}else{\n\t\t\t\ttry{\n\t\t\t\t\tdelete node[propName];\n\t\t\t\t}catch(e){}\n\t\t\t}\n\t\t\t// ensure that event objects are normalized, etc.\n\t\t\tif(value){\n\t\t\t\t//_evtHdlrMap[attrId][propName] = on(node, propName, value);\n\t\t\t\t_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);\n\t\t\t}else{\n\t\t\t\tnode[propName] = null;\n\t\t\t}\n\t\t\treturn node; // DomNode\n\t\t}\n\t\tnode[propName] = value;\n\t\treturn node;\t// DomNode\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/domReady.js":"define(['./has'], function(has){\n\tvar global = this,\n\t\tdoc = document,\n\t\treadyStates = { 'loaded': 1, 'complete': 1 },\n\t\tfixReadyState = typeof doc.readyState != \"string\",\n\t\tready = !!readyStates[doc.readyState],\n\t\treadyQ = [],\n\t\trecursiveGuard;\n\n\tfunction domReady(callback){\n\t\t// summary:\n\t\t//\t\tPlugin to delay require()/define() callback from firing until the DOM has finished loading.\n\t\treadyQ.push(callback);\n\t\tif(ready){ processQ(); }\n\t}\n\tdomReady.load = function(id, req, load){\n\t\tdomReady(load);\n\t};\n\n\t// Export queue so that ready() can check if it's empty or not.\n\tdomReady._Q = readyQ;\n\tdomReady._onQEmpty = function(){\n\t\t// summary:\n\t\t//\t\tPrivate method overridden by dojo/ready, to notify when everything in the\n\t\t//\t\tdomReady queue has been processed.  Do not use directly.\n\t\t//\t\tWill be removed in 2.0, along with domReady._Q.\n\t};\n\n\t// For FF <= 3.5\n\tif(fixReadyState){ doc.readyState = \"loading\"; }\n\n\tfunction processQ(){\n\t\t// Calls all functions in the queue in order, unless processQ() is already running, in which case just return\n\n\t\tif(recursiveGuard){ return; }\n\t\trecursiveGuard = true;\n\n\t\twhile(readyQ.length){\n\t\t\ttry{\n\t\t\t\t(readyQ.shift())(doc);\n\t\t\t}catch(err){\n\t\t\t\tconsole.log(\"Error on domReady callback: \" + err);\n\t\t\t}\n\t\t}\n\n\t\trecursiveGuard = false;\n\n\t\t// Notification for dojo/ready.  Remove for 2.0.\n\t\t// Note that this could add more tasks to the ready queue.\n\t\tdomReady._onQEmpty();\n\t}\n\n\tif(!ready){\n\t\tvar tests = [],\n\t\t\tdetectReady = function(evt){\n\t\t\t\tevt = evt || global.event;\n\t\t\t\tif(ready || (evt.type == \"readystatechange\" && !readyStates[doc.readyState])){ return; }\n\n\t\t\t\t// For FF <= 3.5\n\t\t\t\tif(fixReadyState){ doc.readyState = \"complete\"; }\n\n\t\t\t\tready = 1;\n\t\t\t\tprocessQ();\n\t\t\t},\n\t\t\ton = function(node, event){\n\t\t\t\tnode.addEventListener(event, detectReady, false);\n\t\t\t\treadyQ.push(function(){ node.removeEventListener(event, detectReady, false); });\n\t\t\t};\n\n\t\tif(!has(\"dom-addeventlistener\")){\n\t\t\ton = function(node, event){\n\t\t\t\tevent = \"on\" + event;\n\t\t\t\tnode.attachEvent(event, detectReady);\n\t\t\t\treadyQ.push(function(){ node.detachEvent(event, detectReady); });\n\t\t\t};\n\n\t\t\tvar div = doc.createElement(\"div\");\n\t\t\ttry{\n\t\t\t\tif(div.doScroll && global.frameElement === null){\n\t\t\t\t\t// the doScroll test is only useful if we're in the top-most frame\n\t\t\t\t\ttests.push(function(){\n\t\t\t\t\t\t// Derived with permission from Diego Perini's IEContentLoaded\n\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tdiv.doScroll(\"left\");\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\ton(doc, \"DOMContentLoaded\");\n\t\ton(global, \"load\");\n\n\t\tif(\"onreadystatechange\" in doc){\n\t\t\ton(doc, \"readystatechange\");\n\t\t}else if(!fixReadyState){\n\t\t\t// if the ready state property exists and there's\n\t\t\t// no readystatechange event, poll for the state\n\t\t\t// to change\n\t\t\ttests.push(function(){\n\t\t\t\treturn readyStates[doc.readyState];\n\t\t\t});\n\t\t}\n\n\t\tif(tests.length){\n\t\t\tvar poller = function(){\n\t\t\t\tif(ready){ return; }\n\t\t\t\tvar i = tests.length;\n\t\t\t\twhile(i--){\n\t\t\t\t\tif(tests[i]()){\n\t\t\t\t\t\tdetectReady(\"poller\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetTimeout(poller, 30);\n\t\t\t};\n\t\t\tpoller();\n\t\t}\n\t}\n\n\treturn domReady;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/dom-style.js":"define([\"./sniff\", \"./dom\"], function(has, dom){\n\t// module:\n\t//\t\tdojo/dom-style\n\n\t// =============================\n\t// Style Functions\n\t// =============================\n\n\t// getComputedStyle drives most of the style code.\n\t// Wherever possible, reuse the returned object.\n\t//\n\t// API functions below that need to access computed styles accept an\n\t// optional computedStyle parameter.\n\t// If this parameter is omitted, the functions will call getComputedStyle themselves.\n\t// This way, calling code can access computedStyle once, and then pass the reference to\n\t// multiple API functions.\n\n\t// Although we normally eschew argument validation at this\n\t// level, here we test argument 'node' for (duck)type,\n\t// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'\n\t// it is frequently sent to this function even\n\t// though it is not Element.\n\tvar getComputedStyle, style = {\n\t\t// summary:\n\t\t//\t\tThis module defines the core dojo DOM style API.\n\t};\n\tif(has(\"webkit\")){\n\t\tgetComputedStyle = function(/*DomNode*/ node){\n\t\t\tvar s;\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tvar dv = node.ownerDocument.defaultView;\n\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\tif(!s && node.style){\n\t\t\t\t\tnode.style.display = \"\";\n\t\t\t\t\ts = dv.getComputedStyle(node, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s || {};\n\t\t};\n\t}else if(has(\"ie\") && (has(\"ie\") < 9 || has(\"quirks\"))){\n\t\tgetComputedStyle = function(node){\n\t\t\t// IE (as of 7) doesn't expose Element like sane browsers\n\t\t\t// currentStyle can be null on IE8!\n\t\t\treturn node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};\n\t\t};\n\t}else{\n\t\tgetComputedStyle = function(node){\n\t\t\treturn node.nodeType == 1 /* ELEMENT_NODE*/ ?\n\t\t\t\tnode.ownerDocument.defaultView.getComputedStyle(node, null) : {};\n\t\t};\n\t}\n\tstyle.getComputedStyle = getComputedStyle;\n\t/*=====\n\tstyle.getComputedStyle = function(node){\n\t\t// summary:\n\t\t//\t\tReturns a \"computed style\" object.\n\t\t//\n\t\t// description:\n\t\t//\t\tGets a \"computed style\" object which can be used to gather\n\t\t//\t\tinformation about the current state of the rendered node.\n\t\t//\n\t\t//\t\tNote that this may behave differently on different browsers.\n\t\t//\t\tValues may have different formats and value encodings across\n\t\t//\t\tbrowsers.\n\t\t//\n\t\t//\t\tNote also that this method is expensive.  Wherever possible,\n\t\t//\t\treuse the returned object.\n\t\t//\n\t\t//\t\tUse the dojo/dom-style.get() method for more consistent (pixelized)\n\t\t//\t\treturn values.\n\t\t//\n\t\t// node: DOMNode\n\t\t//\t\tA reference to a DOM node. Does NOT support taking an\n\t\t//\t\tID string for speed reasons.\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/dom\"], function(domStyle, dom){\n\t\t//\t|\t\tdomStyle.getComputedStyle(dom.byId('foo')).borderWidth;\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tReusing the returned object, avoiding multiple lookups:\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/dom\"], function(domStyle, dom){\n\t\t//\t|\t\tvar cs = domStyle.getComputedStyle(dom.byId(\"someNode\"));\n\t\t//\t|\t\tvar w = cs.width, h = cs.height;\n\t\t//\t|\t});\n\t\treturn; // CSS2Properties\n\t};\n\t=====*/\n\n\tvar toPixel;\n\tif(!has(\"ie\")){\n\t\ttoPixel = function(element, value){\n\t\t\t// style values can be floats, client code may want\n\t\t\t// to round for integer pixels.\n\t\t\treturn parseFloat(value) || 0;\n\t\t};\n\t}else{\n\t\ttoPixel = function(element, avalue){\n\t\t\tif(!avalue){ return 0; }\n\t\t\t// on IE7, medium is usually 4 pixels\n\t\t\tif(avalue == \"medium\"){ return 4; }\n\t\t\t// style values can be floats, client code may\n\t\t\t// want to round this value for integer pixels.\n\t\t\tif(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }\n\t\t\tvar s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,\n\t\t\t\tsLeft = s.left, rsLeft = rs.left;\n\t\t\trs.left = cs.left;\n\t\t\ttry{\n\t\t\t\t// 'avalue' may be incompatible with style.left, which can cause IE to throw\n\t\t\t\t// this has been observed for border widths using \"thin\", \"medium\", \"thick\" constants\n\t\t\t\t// those particular constants could be trapped by a lookup\n\t\t\t\t// but perhaps there are more\n\t\t\t\ts.left = avalue;\n\t\t\t\tavalue = s.pixelLeft;\n\t\t\t}catch(e){\n\t\t\t\tavalue = 0;\n\t\t\t}\n\t\t\ts.left = sLeft;\n\t\t\trs.left = rsLeft;\n\t\t\treturn avalue;\n\t\t};\n\t}\n\tstyle.toPixelValue = toPixel;\n\t/*=====\n\tstyle.toPixelValue = function(node, value){\n\t\t// summary:\n\t\t//\t\tconverts style value to pixels on IE or return a numeric value.\n\t\t// node: DOMNode\n\t\t// value: String\n\t\t// returns: Number\n\t};\n\t=====*/\n\n\t// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.\n\n\tvar astr = \"DXImageTransform.Microsoft.Alpha\";\n\tvar af = function(n, f){\n\t\ttry{\n\t\t\treturn n.filters.item(astr);\n\t\t}catch(e){\n\t\t\treturn f ? {} : null;\n\t\t}\n\t};\n\n\tvar _getOpacity =\n\t\thas(\"ie\") < 9 || (has(\"ie\") < 10 && has(\"quirks\")) ? function(node){\n\t\t\ttry{\n\t\t\t\treturn af(node).Opacity / 100; // Number\n\t\t\t}catch(e){\n\t\t\t\treturn 1; // Number\n\t\t\t}\n\t\t} :\n\t\tfunction(node){\n\t\t\treturn getComputedStyle(node).opacity;\n\t\t};\n\n\tvar _setOpacity =\n\t\thas(\"ie\") < 9 || (has(\"ie\") < 10 && has(\"quirks\")) ? function(/*DomNode*/ node, /*Number*/ opacity){\n\t\t\tif(opacity === \"\"){ opacity = 1; }\n\t\t\tvar ov = opacity * 100, fullyOpaque = opacity === 1;\n\n\t\t\t// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),\n\t\t\t// but still update the opacity value so we can get a correct reading if it is read later:\n\t\t\t// af(node, 1).Enabled = !fullyOpaque;\n\n\t\t\tif(fullyOpaque){\n\t\t\t\tnode.style.zoom = \"\";\n\t\t\t\tif(af(node)){\n\t\t\t\t\tnode.style.filter = node.style.filter.replace(\n\t\t\t\t\t\tnew RegExp(\"\\\\s*progid:\" + astr + \"\\\\([^\\\\)]+?\\\\)\", \"i\"), \"\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnode.style.zoom = 1;\n\t\t\t\tif(af(node)){\n\t\t\t\t\taf(node, 1).Opacity = ov;\n\t\t\t\t}else{\n\t\t\t\t\tnode.style.filter += \" progid:\" + astr + \"(Opacity=\" + ov + \")\";\n\t\t\t\t}\n\t\t\t\taf(node, 1).Enabled = true;\n\t\t\t}\n\n\t\t\tif(node.tagName.toLowerCase() == \"tr\"){\n\t\t\t\tfor(var td = node.firstChild; td; td = td.nextSibling){\n\t\t\t\t\tif(td.tagName.toLowerCase() == \"td\"){\n\t\t\t\t\t\t_setOpacity(td, opacity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opacity;\n\t\t} :\n\t\tfunction(node, opacity){\n\t\t\treturn node.style.opacity = opacity;\n\t\t};\n\n\tvar _pixelNamesCache = {\n\t\tleft: true, top: true\n\t};\n\tvar _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border\n\tfunction _toStyleValue(node, type, value){\n\t\t//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!\n\t\ttype = type.toLowerCase();\n\t\tif(has(\"ie\")){\n\t\t\tif(value == \"auto\"){\n\t\t\t\tif(type == \"height\"){ return node.offsetHeight; }\n\t\t\t\tif(type == \"width\"){ return node.offsetWidth; }\n\t\t\t}\n\t\t\tif(type == \"fontweight\"){\n\t\t\t\tswitch(value){\n\t\t\t\t\tcase 700: return \"bold\";\n\t\t\t\t\tcase 400:\n\t\t\t\t\tdefault: return \"normal\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!(type in _pixelNamesCache)){\n\t\t\t_pixelNamesCache[type] = _pixelRegExp.test(type);\n\t\t}\n\t\treturn _pixelNamesCache[type] ? toPixel(node, value) : value;\n\t}\n\n\tvar _floatAliases = {cssFloat: 1, styleFloat: 1, \"float\": 1};\n\n\t// public API\n\n\tstyle.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){\n\t\t// summary:\n\t\t//\t\tAccesses styles on a node.\n\t\t// description:\n\t\t//\t\tGetting the style value uses the computed style for the node, so the value\n\t\t//\t\twill be a calculated value, not just the immediate node.style value.\n\t\t//\t\tAlso when getting values, use specific style names,\n\t\t//\t\tlike \"borderBottomWidth\" instead of \"border\" since compound values like\n\t\t//\t\t\"border\" are not necessarily reflected as expected.\n\t\t//\t\tIf you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,\n\t\t//\t\t`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node to get style for\n\t\t// name: String?\n\t\t//\t\tthe style property to get\n\t\t// example:\n\t\t//\t\tPassing only an ID or node returns the computed style object of\n\t\t//\t\tthe node:\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/dom\"], function(domStyle, dom){\n\t\t//\t|\t\tdomStyle.get(\"thinger\");\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tPassing a node and a style property returns the current\n\t\t//\t\tnormalized, computed value for that property:\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/dom\"], function(domStyle, dom){\n\t\t//\t|\t\tdomStyle.get(\"thinger\", \"opacity\"); // 1 by default\n\t\t//\t|\t});\n\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tif(l == 2 && op){\n\t\t\treturn _getOpacity(n);\n\t\t}\n\t\tname = _floatAliases[name] ? \"cssFloat\" in n.style ? \"cssFloat\" : \"styleFloat\" : name;\n\t\tvar s = style.getComputedStyle(n);\n\t\treturn (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */\n\t};\n\n\tstyle.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){\n\t\t// summary:\n\t\t//\t\tSets styles on a node.\n\t\t// node: DOMNode|String\n\t\t//\t\tid or reference to node to set style for\n\t\t// name: String|Object\n\t\t//\t\tthe style property to set in DOM-accessor format\n\t\t//\t\t(\"borderWidth\", not \"border-width\") or an object with key/value\n\t\t//\t\tpairs suitable for setting each property.\n\t\t// value: String?\n\t\t//\t\tIf passed, sets value on the node for style, handling\n\t\t//\t\tcross-browser concerns.  When setting a pixel value,\n\t\t//\t\tbe sure to include \"px\" in the value. For instance, top: \"200px\".\n\t\t//\t\tOtherwise, in some cases, some browsers will not apply the style.\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, a style property, and a value changes the\n\t\t//\t\tcurrent display of the node and returns the new computed value\n\t\t//\t|\trequire([\"dojo/dom-style\"], function(domStyle){\n\t\t//\t|\t\tdomStyle.set(\"thinger\", \"opacity\", 0.5); // == 0.5\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tPassing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\t\t//\t|\trequire([\"dojo/dom-style\"], function(domStyle){\n\t\t//\t|\t\tdomStyle.set(\"thinger\", {\n\t\t//\t|\t\t\t\"opacity\": 0.5,\n\t\t//\t|\t\t\t\"border\": \"3px solid black\",\n\t\t//\t|\t\t\t\"height\": \"300px\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tWhen the CSS style property is hyphenated, the JavaScript property is camelCased.\n\t\t//\t\tfont-size becomes fontSize, and so on.\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/dom\"], function(domStyle, dom){\n\t\t//\t|\t\tdomStyle.set(\"thinger\",{\n\t\t//\t|\t\t\tfontSize:\"14pt\",\n\t\t//\t|\t\t\tletterSpacing:\"1.2em\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tdojo/NodeList implements .style() using the same syntax, omitting the \"node\" parameter, calling\n\t\t//\t\tdojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`\n\t\t//\t|\trequire([\"dojo/dom-style\", \"dojo/query\", \"dojo/NodeList-dom\"],\n\t\t//\t|\tfunction(domStyle, query){\n\t\t//\t|\t\tquery(\".someClassName\").style(\"visibility\",\"hidden\");\n\t\t//\t|\t\t// or\n\t\t//\t|\t\tquery(\"#baz > div\").style({\n\t\t//\t|\t\t\topacity:0.75,\n\t\t//\t|\t\t\tfontSize:\"13pt\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\n\t\tvar n = dom.byId(node), l = arguments.length, op = (name == \"opacity\");\n\t\tname = _floatAliases[name] ? \"cssFloat\" in n.style ? \"cssFloat\" : \"styleFloat\" : name;\n\t\tif(l == 3){\n\t\t\treturn op ? _setOpacity(n, value) : n.style[name] = value; // Number\n\t\t}\n\t\tfor(var x in name){\n\t\t\tstyle.set(node, x, name[x]);\n\t\t}\n\t\treturn style.getComputedStyle(n);\n\t};\n\n\treturn style;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/Evented.js":"define([\"./aspect\", \"./on\"], function(aspect, on){\n\t// module:\n\t//\t\tdojo/Evented\n\n \t\"use strict\";\n \tvar after = aspect.after;\n\tfunction Evented(){\n\t\t// summary:\n\t\t//\t\tA class that can be used as a mixin or base class,\n\t\t//\t\tto add on() and emit() methods to a class\n\t\t//\t\tfor listening for events and emitting events:\n\t\t// example:\n\t\t//\t\t|\tdefine([\"dojo/Evented\", \"dojo/_base/declare\", \"dojo/Stateful\"\n\t\t//\t\t|\t], function(Evented, declare, Stateful){\n\t\t//\t\t|\t\tvar EventedStateful = declare([Evented, Stateful], {...});\n\t\t//\t\t|\t\tvar instance = new EventedStateful();\n\t\t//\t\t|\t\tinstance.on(\"open\", function(event){\n\t\t//\t\t|\t\t... do something with event\n\t\t//\t\t|\t });\n\t\t//\t\t|\n\t\t//\t\t|\tinstance.emit(\"open\", {name:\"some event\", ...});\n\t}\n\tEvented.prototype = {\n\t\ton: function(type, listener){\n\t\t\treturn on.parse(this, type, listener, function(target, type){\n\t\t\t\treturn after(target, 'on' + type, listener, true);\n\t\t\t});\n\t\t},\n\t\temit: function(type, event){\n\t\t\tvar args = [this];\n\t\t\targs.push.apply(args, arguments);\n\t\t\treturn on.emit.apply(on, args);\n\t\t}\n\t};\n\treturn Evented;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/fx.js":"define([\n\t\"./_base/lang\",\n\t\"./Evented\",\n\t\"./_base/kernel\",\n\t\"./_base/array\",\n\t\"./aspect\",\n\t\"./_base/fx\",\n\t\"./dom\",\n\t\"./dom-style\",\n\t\"./dom-geometry\",\n\t\"./ready\",\n\t\"require\" // for context sensitive loading of Toggler\n], function(lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require){\n\n\t// module:\n\t//\t\tdojo/fx\n\t\n\t// For back-compat, remove in 2.0.\n\tif(!dojo.isAsync){\n\t\tready(0, function(){\n\t\t\tvar requires = [\"./fx/Toggler\"];\n\t\t\trequire(requires);\t// use indirection so modules not rolled into a build\n\t\t});\n\t}\n\n\tvar coreFx = dojo.fx = {\n\t\t// summary:\n\t\t//\t\tEffects library on top of Base animations\n\t};\n\n\tvar _baseObj = {\n\t\t\t_fire: function(evt, args){\n\t\t\t\tif(this[evt]){\n\t\t\t\t\tthis[evt].apply(this, args||[]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\n\tvar _chain = function(animations){\n\t\tthis._index = -1;\n\t\tthis._animations = animations||[];\n\t\tthis._current = this._onAnimateCtx = this._onEndCtx = null;\n\n\t\tthis.duration = 0;\n\t\tarrayUtil.forEach(this._animations, function(a){\n\t\t\tthis.duration += a.duration;\n\t\t\tif(a.delay){ this.duration += a.delay; }\n\t\t}, this);\n\t};\n\t_chain.prototype = new Evented();\n\tlang.extend(_chain, {\n\t\t_onAnimate: function(){\n\t\t\tthis._fire(\"onAnimate\", arguments);\n\t\t},\n\t\t_onEnd: function(){\n\t\t\tthis._onAnimateCtx.remove();\n\t\t\tthis._onEndCtx.remove();\n\t\t\tthis._onAnimateCtx = this._onEndCtx = null;\n\t\t\tif(this._index + 1 == this._animations.length){\n\t\t\t\tthis._fire(\"onEnd\");\n\t\t\t}else{\n\t\t\t\t// switch animations\n\t\t\t\tthis._current = this._animations[++this._index];\n\t\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\n\t\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\n\t\t\t\tthis._current.play(0, true);\n\t\t\t}\n\t\t},\n\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\n\t\t\tif(!this._current){ this._current = this._animations[this._index = 0]; }\n\t\t\tif(!gotoStart && this._current.status() == \"playing\"){ return this; }\n\t\t\tvar beforeBegin = aspect.after(this._current, \"beforeBegin\", lang.hitch(this, function(){\n\t\t\t\t\tthis._fire(\"beforeBegin\");\n\t\t\t\t}), true),\n\t\t\t\tonBegin = aspect.after(this._current, \"onBegin\", lang.hitch(this, function(arg){\n\t\t\t\t\tthis._fire(\"onBegin\", arguments);\n\t\t\t\t}), true),\n\t\t\t\tonPlay = aspect.after(this._current, \"onPlay\", lang.hitch(this, function(arg){\n\t\t\t\t\tthis._fire(\"onPlay\", arguments);\n\t\t\t\t\tbeforeBegin.remove();\n\t\t\t\t\tonBegin.remove();\n\t\t\t\t\tonPlay.remove();\n\t\t\t\t}));\n\t\t\tif(this._onAnimateCtx){\n\t\t\t\tthis._onAnimateCtx.remove();\n\t\t\t}\n\t\t\tthis._onAnimateCtx = aspect.after(this._current, \"onAnimate\", lang.hitch(this, \"_onAnimate\"), true);\n\t\t\tif(this._onEndCtx){\n\t\t\t\tthis._onEndCtx.remove();\n\t\t\t}\n\t\t\tthis._onEndCtx = aspect.after(this._current, \"onEnd\", lang.hitch(this, \"_onEnd\"), true);\n\t\t\tthis._current.play.apply(this._current, arguments);\n\t\t\treturn this;\n\t\t},\n\t\tpause: function(){\n\t\t\tif(this._current){\n\t\t\t\tvar e = aspect.after(this._current, \"onPause\", lang.hitch(this, function(arg){\n\t\t\t\t\t\tthis._fire(\"onPause\", arguments);\n\t\t\t\t\t\te.remove();\n\t\t\t\t\t}), true);\n\t\t\t\tthis._current.pause();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\n\t\t\tthis.pause();\n\t\t\tvar offset = this.duration * percent;\n\t\t\tthis._current = null;\n\t\t\tarrayUtil.some(this._animations, function(a){\n\t\t\t\tif(a.duration <= offset){\n\t\t\t\t\tthis._current = a;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\toffset -= a.duration;\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tif(this._current){\n\t\t\t\tthis._current.gotoPercent(offset / this._current.duration, andPlay);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tstop: function(/*boolean?*/ gotoEnd){\n\t\t\tif(this._current){\n\t\t\t\tif(gotoEnd){\n\t\t\t\t\tfor(; this._index + 1 < this._animations.length; ++this._index){\n\t\t\t\t\t\tthis._animations[this._index].stop(true);\n\t\t\t\t\t}\n\t\t\t\t\tthis._current = this._animations[this._index];\n\t\t\t\t}\n\t\t\t\tvar e = aspect.after(this._current, \"onStop\", lang.hitch(this, function(arg){\n\t\t\t\t\t\tthis._fire(\"onStop\", arguments);\n\t\t\t\t\t\te.remove();\n\t\t\t\t\t}), true);\n\t\t\t\tthis._current.stop();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tstatus: function(){\n\t\t\treturn this._current ? this._current.status() : \"stopped\";\n\t\t},\n\t\tdestroy: function(){\n\t\t\tif(this._onAnimateCtx){ this._onAnimateCtx.remove(); }\n\t\t\tif(this._onEndCtx){ this._onEndCtx.remove(); }\n\t\t}\n\t});\n\tlang.extend(_chain, _baseObj);\n\n\tcoreFx.chain = function(/*dojo/_base/fx.Animation[]*/ animations){\n\t\t// summary:\n\t\t//\t\tChain a list of `dojo/_base/fx.Animation`s to run in sequence\n\t\t//\n\t\t// description:\n\t\t//\t\tReturn a `dojo/_base/fx.Animation` which will play all passed\n\t\t//\t\t`dojo/_base/fx.Animation` instances in sequence, firing its own\n\t\t//\t\tsynthesized events simulating a single animation. (eg:\n\t\t//\t\tonEnd of this animation means the end of the chain,\n\t\t//\t\tnot the individual animations within)\n\t\t//\n\t\t// example:\n\t\t//\tOnce `node` is faded out, fade in `otherNode`\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\n\t\t//\t|\t\tfx.chain([\n\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\n\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\n\t\t//\t|\t\t]).play();\n\t\t//\t|\t});\n\t\t//\n\t\treturn new _chain(animations); // dojo/_base/fx.Animation\n\t};\n\n\tvar _combine = function(animations){\n\t\tthis._animations = animations||[];\n\t\tthis._connects = [];\n\t\tthis._finished = 0;\n\n\t\tthis.duration = 0;\n\t\tarrayUtil.forEach(animations, function(a){\n\t\t\tvar duration = a.duration;\n\t\t\tif(a.delay){ duration += a.delay; }\n\t\t\tif(this.duration < duration){ this.duration = duration; }\n\t\t\tthis._connects.push(aspect.after(a, \"onEnd\", lang.hitch(this, \"_onEnd\"), true));\n\t\t}, this);\n\n\t\tthis._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});\n\t\tvar self = this;\n\t\tarrayUtil.forEach([\"beforeBegin\", \"onBegin\", \"onPlay\", \"onAnimate\", \"onPause\", \"onStop\", \"onEnd\"],\n\t\t\tfunction(evt){\n\t\t\t\tself._connects.push(aspect.after(self._pseudoAnimation, evt,\n\t\t\t\t\tfunction(){ self._fire(evt, arguments); },\n\t\t\t\ttrue));\n\t\t\t}\n\t\t);\n\t};\n\tlang.extend(_combine, {\n\t\t_doAction: function(action, args){\n\t\t\tarrayUtil.forEach(this._animations, function(a){\n\t\t\t\ta[action].apply(a, args);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\t_onEnd: function(){\n\t\t\tif(++this._finished > this._animations.length){\n\t\t\t\tthis._fire(\"onEnd\");\n\t\t\t}\n\t\t},\n\t\t_call: function(action, args){\n\t\t\tvar t = this._pseudoAnimation;\n\t\t\tt[action].apply(t, args);\n\t\t},\n\t\tplay: function(/*int?*/ delay, /*Boolean?*/ gotoStart){\n\t\t\tthis._finished = 0;\n\t\t\tthis._doAction(\"play\", arguments);\n\t\t\tthis._call(\"play\", arguments);\n\t\t\treturn this;\n\t\t},\n\t\tpause: function(){\n\t\t\tthis._doAction(\"pause\", arguments);\n\t\t\tthis._call(\"pause\", arguments);\n\t\t\treturn this;\n\t\t},\n\t\tgotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){\n\t\t\tvar ms = this.duration * percent;\n\t\t\tarrayUtil.forEach(this._animations, function(a){\n\t\t\t\ta.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);\n\t\t\t});\n\t\t\tthis._call(\"gotoPercent\", arguments);\n\t\t\treturn this;\n\t\t},\n\t\tstop: function(/*boolean?*/ gotoEnd){\n\t\t\tthis._doAction(\"stop\", arguments);\n\t\t\tthis._call(\"stop\", arguments);\n\t\t\treturn this;\n\t\t},\n\t\tstatus: function(){\n\t\t\treturn this._pseudoAnimation.status();\n\t\t},\n\t\tdestroy: function(){\n\t\t\tarrayUtil.forEach(this._connects, function(handle){\n\t\t\t\thandle.remove();\n\t\t\t});\n\t\t}\n\t});\n\tlang.extend(_combine, _baseObj);\n\n\tcoreFx.combine = function(/*dojo/_base/fx.Animation[]*/ animations){\n\t\t// summary:\n\t\t//\t\tCombine a list of `dojo/_base/fx.Animation`s to run in parallel\n\t\t//\n\t\t// description:\n\t\t//\t\tCombine an array of `dojo/_base/fx.Animation`s to run in parallel,\n\t\t//\t\tproviding a new `dojo/_base/fx.Animation` instance encompasing each\n\t\t//\t\tanimation, firing standard animation events.\n\t\t//\n\t\t// example:\n\t\t//\tFade out `node` while fading in `otherNode` simultaneously\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\n\t\t//\t|\t\tfx.combine([\n\t\t//\t|\t\t\tfx.fadeIn({ node:node }),\n\t\t//\t|\t\t\tfx.fadeOut({ node:otherNode })\n\t\t//\t|\t\t]).play();\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tWhen the longest animation ends, execute a function:\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\n\t\t//\t|\t\tvar anim = fx.combine([\n\t\t//\t|\t\t\tfx.fadeIn({ node: n, duration:700 }),\n\t\t//\t|\t\t\tfx.fadeOut({ node: otherNode, duration: 300 })\n\t\t//\t|\t\t]);\n\t\t//\t|\t\taspect.after(anim, \"onEnd\", function(){\n\t\t//\t|\t\t\t// overall animation is done.\n\t\t//\t|\t\t}, true);\n\t\t//\t|\t\tanim.play(); // play the animation\n\t\t//\t|\t});\n\t\t//\n\t\treturn new _combine(animations); // dojo/_base/fx.Animation\n\t};\n\n\tcoreFx.wipeIn = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tExpand a node to it's natural height.\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an animation that will expand the\n\t\t//\t\tnode defined in 'args' object from it's current height to\n\t\t//\t\tit's natural height (with no scrollbar).\n\t\t//\t\tNode must have no margin/border/padding.\n\t\t//\n\t\t// args: Object\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\n\t\t//\t\t(such as easing: node: duration: and so on)\n\t\t//\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\n\t\t//\t|\t\tfx.wipeIn({\n\t\t//\t|\t\t\tnode:\"someId\"\n\t\t//\t|\t\t}).play()\n\t\t//\t|\t});\n\n\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\n\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\n\t\t\tproperties: {\n\t\t\t\theight: {\n\t\t\t\t\t// wrapped in functions so we wait till the last second to query (in case value has changed)\n\t\t\t\t\tstart: function(){\n\t\t\t\t\t\t// start at current [computed] height, but use 1px rather than 0\n\t\t\t\t\t\t// because 0 causes IE to display the whole panel\n\t\t\t\t\t\to = s.overflow;\n\t\t\t\t\t\ts.overflow = \"hidden\";\n\t\t\t\t\t\tif(s.visibility == \"hidden\" || s.display == \"none\"){\n\t\t\t\t\t\t\ts.height = \"1px\";\n\t\t\t\t\t\t\ts.display = \"\";\n\t\t\t\t\t\t\ts.visibility = \"\";\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tvar height = domStyle.get(node, \"height\");\n\t\t\t\t\t\t\treturn Math.max(height, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tend: function(){\n\t\t\t\t\t\treturn node.scrollHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, args));\n\n\t\tvar fini = function(){\n\t\t\ts.height = \"auto\";\n\t\t\ts.overflow = o;\n\t\t};\n\t\taspect.after(anim, \"onStop\", fini, true);\n\t\taspect.after(anim, \"onEnd\", fini, true);\n\n\t\treturn anim; // dojo/_base/fx.Animation\n\t};\n\n\tcoreFx.wipeOut = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tShrink a node to nothing and hide it.\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an animation that will shrink node defined in \"args\"\n\t\t//\t\tfrom it's current height to 1px, and then hide it.\n\t\t//\n\t\t// args: Object\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\n\t\t//\t\t(such as easing: node: duration: and so on)\n\t\t//\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/fx\"], function(fx){\n\t\t//\t|\t\tfx.wipeOut({ node:\"someId\" }).play()\n\t\t//\t|\t});\n\n\t\tvar node = args.node = dom.byId(args.node), s = node.style, o;\n\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\n\t\t\tproperties: {\n\t\t\t\theight: {\n\t\t\t\t\tend: 1 // 0 causes IE to display the whole panel\n\t\t\t\t}\n\t\t\t}\n\t\t}, args));\n\n\t\taspect.after(anim, \"beforeBegin\", function(){\n\t\t\to = s.overflow;\n\t\t\ts.overflow = \"hidden\";\n\t\t\ts.display = \"\";\n\t\t}, true);\n\t\tvar fini = function(){\n\t\t\ts.overflow = o;\n\t\t\ts.height = \"auto\";\n\t\t\ts.display = \"none\";\n\t\t};\n\t\taspect.after(anim, \"onStop\", fini, true);\n\t\taspect.after(anim, \"onEnd\", fini, true);\n\n\t\treturn anim; // dojo/_base/fx.Animation\n\t};\n\n\tcoreFx.slideTo = function(/*Object*/ args){\n\t\t// summary:\n\t\t//\t\tSlide a node to a new top/left position\n\t\t//\n\t\t// description:\n\t\t//\t\tReturns an animation that will slide \"node\"\n\t\t//\t\tdefined in args Object from its current position to\n\t\t//\t\tthe position defined by (args.left, args.top).\n\t\t//\n\t\t// args: Object\n\t\t//\t\tA hash-map of standard `dojo/_base/fx.Animation` constructor properties\n\t\t//\t\t(such as easing: node: duration: and so on). Special args members\n\t\t//\t\tare `top` and `left`, which indicate the new position to slide to.\n\t\t//\n\t\t// example:\n\t\t//\t|\t.slideTo({ node: node, left:\"40\", top:\"50\", units:\"px\" }).play()\n\n\t\tvar node = args.node = dom.byId(args.node),\n\t\t\ttop = null, left = null;\n\n\t\tvar init = (function(n){\n\t\t\treturn function(){\n\t\t\t\tvar cs = domStyle.getComputedStyle(n);\n\t\t\t\tvar pos = cs.position;\n\t\t\t\ttop = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);\n\t\t\t\tleft = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);\n\t\t\t\tif(pos != 'absolute' && pos != 'relative'){\n\t\t\t\t\tvar ret = geom.position(n, true);\n\t\t\t\t\ttop = ret.y;\n\t\t\t\t\tleft = ret.x;\n\t\t\t\t\tn.style.position=\"absolute\";\n\t\t\t\t\tn.style.top=top+\"px\";\n\t\t\t\t\tn.style.left=left+\"px\";\n\t\t\t\t}\n\t\t\t};\n\t\t})(node);\n\t\tinit();\n\n\t\tvar anim = baseFx.animateProperty(lang.mixin({\n\t\t\tproperties: {\n\t\t\t\ttop: args.top || 0,\n\t\t\t\tleft: args.left || 0\n\t\t\t}\n\t\t}, args));\n\t\taspect.after(anim, \"beforeBegin\", init, true);\n\n\t\treturn anim; // dojo/_base/fx.Animation\n\t};\n\n\treturn coreFx;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/gears.js":"define([\"./_base/lang\", \"./sniff\"], function(lang, has){\n\n// module:\n//\t\tdojo/gears\n\nvar gears = {\n\t// summary:\n\t//\t\tTODOC\n};\nlang.setObject(\"dojo.gears\", gears);\n\ngears._gearsObject = function(){\n\t// summary:\n\t//\t\tfactory method to get a Google Gears plugin instance to\n\t//\t\texpose in the browser runtime environment, if present\n\tvar factory;\n\n\tvar gearsObj = lang.getObject(\"google.gears\");\n\tif(gearsObj){ return gearsObj; } // already defined elsewhere\n\n\tif(typeof GearsFactory != \"undefined\"){ // Firefox\n\t\tfactory = new GearsFactory();\n\t}else{\n\t\tif(has(\"ie\")){\n\t\t\t// IE\n\t\t\ttry{\n\t\t\t\tfactory = new ActiveXObject(\"Gears.Factory\");\n\t\t\t}catch(e){\n\t\t\t\t// ok to squelch; there's no gears factory.  move on.\n\t\t\t}\n\t\t}else if(navigator.mimeTypes[\"application/x-googlegears\"]){\n\t\t\t// Safari?\n\t\t\tfactory = document.createElement(\"object\");\n\t\t\tfactory.setAttribute(\"type\", \"application/x-googlegears\");\n\t\t\tfactory.setAttribute(\"width\", 0);\n\t\t\tfactory.setAttribute(\"height\", 0);\n\t\t\tfactory.style.display = \"none\";\n\t\t\tdocument.documentElement.appendChild(factory);\n\t\t}\n\t}\n\n\t// still nothing?\n\tif(!factory){ return null; }\n\n\t// define the global objects now; don't overwrite them though if they\n\t// were somehow set internally by the Gears plugin, which is on their\n\t// dev roadmap for the future\n\tlang.setObject(\"google.gears.factory\", factory);\n\treturn lang.getObject(\"google.gears\");\n};\n\n\n// see if we have Google Gears installed, and if\n// so, make it available in the runtime environment\n// and in the Google standard 'google.gears' global object\ngears.available = (!!gears._gearsObject())||0;\n/*=====\n gears.available = {\n // summary:\n //\t\tTrue if client is using Google Gears\n };\n =====*/\n\nreturn gears;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/hash.js":"define([\"./_base/kernel\", \"require\", \"./_base/config\", \"./aspect\", \"./_base/lang\", \"./topic\", \"./domReady\", \"./sniff\"],\n\tfunction(dojo, require, config, aspect, lang, topic, domReady, has){\n\n\t// module:\n\t//\t\tdojo/hash\n\n\tdojo.hash = function(/* String? */ hash, /* Boolean? */ replace){\n\t\t// summary:\n\t\t//\t\tGets or sets the hash string in the browser URL.\n\t\t// description:\n\t\t//\t\tHandles getting and setting of location.hash.\n\t\t//\n\t\t//\t\t - If no arguments are passed, acts as a getter.\n\t\t//\t\t - If a string is passed, acts as a setter.\n\t\t// hash:\n\t\t//\t\tthe hash is set - #string.\n\t\t// replace:\n\t\t//\t\tIf true, updates the hash value in the current history\n\t\t//\t\tstate instead of creating a new history state.\n\t\t// returns:\n\t\t//\t\twhen used as a getter, returns the current hash string.\n\t\t//\t\twhen used as a setter, returns the new hash string.\n\t\t// example:\n\t\t//\t|\ttopic.subscribe(\"/dojo/hashchange\", context, callback);\n\t\t//\t|\n\t\t//\t|\tfunction callback (hashValue){\n\t\t//\t|\t\t// do something based on the hash value.\n\t\t//\t|\t}\n\n\t\t// getter\n\t\tif(!arguments.length){\n\t\t\treturn _getHash();\n\t\t}\n\t\t// setter\n\t\tif(hash.charAt(0) == \"#\"){\n\t\t\thash = hash.substring(1);\n\t\t}\n\t\tif(replace){\n\t\t\t_replace(hash);\n\t\t}else{\n\t\t\tlocation.href = \"#\" + hash;\n\t\t}\n\t\treturn hash; // String\n\t};\n\n\t// Global vars\n\tvar _recentHash, _ieUriMonitor, _connect,\n\t\t_pollFrequency = config.hashPollFrequency || 100;\n\n\t//Internal functions\n\tfunction _getSegment(str, delimiter){\n\t\tvar i = str.indexOf(delimiter);\n\t\treturn (i >= 0) ? str.substring(i+1) : \"\";\n\t}\n\n\tfunction _getHash(){\n\t\treturn _getSegment(location.href, \"#\");\n\t}\n\n\tfunction _dispatchEvent(){\n\t\ttopic.publish(\"/dojo/hashchange\", _getHash());\n\t}\n\n\tfunction _pollLocation(){\n\t\tif(_getHash() === _recentHash){\n\t\t\treturn;\n\t\t}\n\t\t_recentHash = _getHash();\n\t\t_dispatchEvent();\n\t}\n\n\tfunction _replace(hash){\n\t\tif(_ieUriMonitor){\n\t\t\tif(_ieUriMonitor.isTransitioning()){\n\t\t\t\tsetTimeout(lang.hitch(null,_replace,hash), _pollFrequency);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar href = _ieUriMonitor.iframe.location.href;\n\t\t\tvar index = href.indexOf('?');\n\t\t\t// main frame will detect and update itself\n\t\t\t_ieUriMonitor.iframe.location.replace(href.substring(0, index) + \"?\" + hash);\n\t\t\treturn;\n\t\t}\n\t\tlocation.replace(\"#\"+hash);\n\t\t!_connect && _pollLocation();\n\t}\n\n\tfunction IEUriMonitor(){\n\t\t// summary:\n\t\t//\t\tDetermine if the browser's URI has changed or if the user has pressed the\n\t\t//\t\tback or forward button. If so, call _dispatchEvent.\n\t\t//\n\t\t// description:\n\t\t//\t\tIE doesn't add changes to the URI's hash into the history unless the hash\n\t\t//\t\tvalue corresponds to an actual named anchor in the document. To get around\n\t\t//\t\tthis IE difference, we use a background IFrame to maintain a back-forward\n\t\t//\t\thistory, by updating the IFrame's query string to correspond to the\n\t\t//\t\tvalue of the main browser location's hash value.\n\t\t//\n\t\t//\t\tE.g. if the value of the browser window's location changes to\n\t\t//\n\t\t//\t\t#action=someAction\n\t\t//\n\t\t//\t\t... then we'd update the IFrame's source to:\n\t\t//\n\t\t//\t\t?action=someAction\n\t\t//\n\t\t//\t\tThis design leads to a somewhat complex state machine, which is\n\t\t//\t\tdescribed below:\n\t\t//\n\t\t//\t\t####s1\n\t\t//\n\t\t//\t\tStable state - neither the window's location has changed nor\n\t\t//\t\thas the IFrame's location. Note that this is the 99.9% case, so\n\t\t//\t\twe optimize for it.\n\t\t//\n\t\t//\t\tTransitions: s1, s2, s3\n\t\t//\n\t\t//\t\t####s2\n\t\t//\n\t\t//\t\tWindow's location changed - when a user clicks a hyperlink or\n\t\t//\t\tcode programmatically changes the window's URI.\n\t\t//\n\t\t//\t\tTransitions: s4\n\t\t//\n\t\t//\t\t####s3\n\t\t//\n\t\t//\t\tIframe's location changed as a result of user pressing back or\n\t\t//\t\tforward - when the user presses back or forward, the location of\n\t\t//\t\tthe background's iframe changes to the previous or next value in\n\t\t//\t\tits history.\n\t\t//\n\t\t//\t\tTransitions: s1\n\t\t//\n\t\t//\t\t####s4\n\t\t//\n\t\t//\t\tIEUriMonitor has programmatically changed the location of the\n\t\t//\t\tbackground iframe, but it's location hasn't yet changed. In this\n\t\t//\t\tcase we do nothing because we need to wait for the iframe's\n\t\t//\t\tlocation to reflect its actual state.\n\t\t//\n\t\t//\t\tTransitions: s4, s5\n\t\t//\n\t\t//\t\t####s5\n\t\t//\n\t\t//\t\tIEUriMonitor has programmatically changed the location of the\n\t\t//\t\tbackground iframe, and the iframe's location has caught up with\n\t\t//\t\treality. In this case we need to transition to s1.\n\t\t//\n\t\t//\t\tTransitions: s1\n\t\t//\n\t\t//\t\tThe hashchange event is always dispatched on the transition back to s1.\n\n\n\t\t// create and append iframe\n\t\tvar ifr = document.createElement(\"iframe\"),\n\t\t\tIFRAME_ID = \"dojo-hash-iframe\",\n\t\t\tifrSrc = config.dojoBlankHtmlUrl || require.toUrl(\"./resources/blank.html\");\n\n\t\tif(config.useXDomain && !config.dojoBlankHtmlUrl){\n\t\t\tconsole.warn(\"dojo/hash: When using cross-domain Dojo builds,\"\n\t\t\t\t+ \" please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl\"\n\t\t\t\t+ \" to the path on your domain to blank.html\");\n\t\t}\n\n\t\tifr.id = IFRAME_ID;\n\t\tifr.src = ifrSrc + \"?\" + _getHash();\n\t\tifr.style.display = \"none\";\n\t\tdocument.body.appendChild(ifr);\n\n\t\tthis.iframe = dojo.global[IFRAME_ID];\n\t\tvar recentIframeQuery, transitioning, expectedIFrameQuery, docTitle, ifrOffline,\n\t\t\tiframeLoc = this.iframe.location;\n\n\t\tfunction resetState(){\n\t\t\t_recentHash = _getHash();\n\t\t\trecentIframeQuery = ifrOffline ? _recentHash : _getSegment(iframeLoc.href, \"?\");\n\t\t\ttransitioning = false;\n\t\t\texpectedIFrameQuery = null;\n\t\t}\n\n\t\tthis.isTransitioning = function(){\n\t\t\treturn transitioning;\n\t\t};\n\n\t\tthis.pollLocation = function(){\n\t\t\tif(!ifrOffline){\n\t\t\t\ttry{\n\t\t\t\t\t//see if we can access the iframe's location without a permission denied error\n\t\t\t\t\tvar iframeSearch = _getSegment(iframeLoc.href, \"?\");\n\t\t\t\t\t//good, the iframe is same origin (no thrown exception)\n\t\t\t\t\tif(document.title != docTitle){ //sync title of main window with title of iframe.\n\t\t\t\t\t\tdocTitle = this.iframe.document.title = document.title;\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\t//permission denied - server cannot be reached.\n\t\t\t\t\tifrOffline = true;\n\t\t\t\t\tconsole.error(\"dojo/hash: Error adding history entry. Server unreachable.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar hash = _getHash();\n\t\t\tif(transitioning && _recentHash === hash){\n\t\t\t\t// we're in an iframe transition (s4 or s5)\n\t\t\t\tif(ifrOffline || iframeSearch === expectedIFrameQuery){\n\t\t\t\t\t// s5 (iframe caught up to main window or iframe offline), transition back to s1\n\t\t\t\t\tresetState();\n\t\t\t\t\t_dispatchEvent();\n\t\t\t\t}else{\n\t\t\t\t\t// s4 (waiting for iframe to catch up to main window)\n\t\t\t\t\tsetTimeout(lang.hitch(this,this.pollLocation),0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else if(_recentHash === hash && (ifrOffline || recentIframeQuery === iframeSearch)){\n\t\t\t\t// we're in stable state (s1, iframe query == main window hash), do nothing\n\t\t\t}else{\n\t\t\t\t// the user has initiated a URL change somehow.\n\t\t\t\t// sync iframe query <-> main window hash\n\t\t\t\tif(_recentHash !== hash){\n\t\t\t\t\t// s2 (main window location changed), set iframe url and transition to s4\n\t\t\t\t\t_recentHash = hash;\n\t\t\t\t\ttransitioning = true;\n\t\t\t\t\texpectedIFrameQuery = hash;\n\t\t\t\t\tifr.src = ifrSrc + \"?\" + expectedIFrameQuery;\n\t\t\t\t\tifrOffline = false; //we're updating the iframe src - set offline to false so we can check again on next poll.\n\t\t\t\t\tsetTimeout(lang.hitch(this,this.pollLocation),0); //yielded transition to s4 while iframe reloads.\n\t\t\t\t\treturn;\n\t\t\t\t}else if(!ifrOffline){\n\t\t\t\t\t// s3 (iframe location changed via back/forward button), set main window url and transition to s1.\n\t\t\t\t\tlocation.href = \"#\" + iframeLoc.search.substring(1);\n\t\t\t\t\tresetState();\n\t\t\t\t\t_dispatchEvent();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetTimeout(lang.hitch(this,this.pollLocation), _pollFrequency);\n\t\t};\n\t\tresetState(); // initialize state (transition to s1)\n\t\tsetTimeout(lang.hitch(this,this.pollLocation), _pollFrequency);\n\t}\n\tdomReady(function(){\n\t\tif(\"onhashchange\" in dojo.global && (!has(\"ie\") || (has(\"ie\") >= 8 && document.compatMode != \"BackCompat\"))){\t//need this IE browser test because \"onhashchange\" exists in IE8 in IE7 mode\n\t\t\t_connect = aspect.after(dojo.global,\"onhashchange\",_dispatchEvent, true);\n\t\t}else{\n\t\t\tif(document.addEventListener){ // Non-IE\n\t\t\t\t_recentHash = _getHash();\n\t\t\t\tsetInterval(_pollLocation, _pollFrequency); //Poll the window location for changes\n\t\t\t}else if(document.attachEvent){ // IE7-\n\t\t\t\t//Use hidden iframe in versions of IE that don't have onhashchange event\n\t\t\t\t_ieUriMonitor = new IEUriMonitor();\n\t\t\t}\n\t\t\t// else non-supported browser, do nothing.\n\t\t}\n\t});\n\n\treturn dojo.hash;\n\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/has.js":"define([\"require\", \"module\"], function(require, module){\n\t// module:\n\t//\t\tdojo/has\n\t// summary:\n\t//\t\tDefines the has.js API and several feature tests used by dojo.\n\t// description:\n\t//\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t//\n\t//\t\t- the has test cache is exposed at has.cache.\n\t//\t\t- the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t//\t\t- the loader's has cache may be optionally copied into this module's has cahce.\n\t//\n\t//\t\tThis module adopted from https://github.com/phiggins42/has.js; thanks has.js team!\n\n\t// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t// if using a foreign loader, then the has cache may be initialized via the config object for this module\n\t// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!has(\"dojo-has-api\")){\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t// the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t// has API variables\n\t\t\tglobal = this,\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = (module.config && module.config()) || {};\n\n\t\thas = function(name){\n\t\t\t// summary:\n\t\t\t//\t\tReturn the current value of the named feature.\n\t\t\t//\n\t\t\t// name: String|Integer\n\t\t\t//\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t//\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn typeof cache[name] == \"function\" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = function(name, test, now, force){\n\t\t\t// summary:\n\t\t\t//\t \tRegister a new feature test for some named feature.\n\t\t\t// name: String|Integer\n\t\t\t//\t \tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t// test: Function\n\t\t\t//\t\t A test function to register. If a function, queued for testing until actually\n\t\t\t//\t\t needed. The test function should return a boolean indicating\n\t\t\t//\t \tthe presence of a feature or bug.\n\t\t\t// now: Boolean?\n\t\t\t//\t\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t//\t\t run the test and cache the result.\n\t\t\t// force: Boolean?\n\t\t\t//\t \tOptional. If the test already exists and force is truthy, then the existing\n\t\t\t//\t \ttest will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t//\t \tis, by default, the first test advice wins).\n\t\t\t// example:\n\t\t\t//\t\tA redundant test, testFn with immediate execution:\n\t\t\t//\t|\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t//\t\tnot be doing this in any internal has.js tests\n\t\t\t//\t|\thas.add(\"javascript\", true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t//\t\tfrom which to work your test should the need arise.\n\t\t\t//\t|\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t//\t|\t\t// g\t== global, typically window, yadda yadda\n\t\t\t//\t|\t\t// d\t== document object\n\t\t\t//\t|\t\t// el == the generic element. a `has` element.\n\t\t\t//\t|\t\treturn false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t//\t|\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t// can optimize these away iff desired\n\t\thas.add(\"host-browser\", isBrowser);\n\t\thas.add(\"host-node\", (typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\t\thas.add(\"host-rhino\", (typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\t\thas.add(\"dom\", isBrowser);\n\t\thas.add(\"dojo-dom-ready-api\", 1);\n\t\thas.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(has(\"host-browser\")){\n\t\t// Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\t\thas.add(\"touch\", \"ontouchstart\" in document || window.navigator.msMaxTouchPoints > 0);\n\t\t// I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\n\t\t// Tests for DOMNode.attributes[] behavior:\n\t\t//\t - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes\n\t\t//\t - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify\n\t\t//\t - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.\n\t\tvar form = document.createElement(\"form\");\n\t\thas.add(\"dom-attributes-explicit\", form.attributes.length == 0); // W3C\n\t\thas.add(\"dom-attributes-specified-flag\", form.attributes.length > 0 && form.attributes.length < 40);\t// IE8\n\t}\n\n\thas.clearElement = function(element){\n\t\t// summary:\n\t\t//\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.normalize = function(id, toAbsMid){\n\t\t// summary:\n\t\t//\t Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n\t\t//\n\t\t// toAbsMid: Function\n\t\t//\t Resolves a relative module id into an absolute module id\n\t\tvar\n\t\t\ttokens = id.match(/[\\?:]|[^:\\?]*/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t// empty string module name, resolves to 0\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// a module\n\t\t\t\t\treturn term || 0;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\treturn id && toAbsMid(id);\n\t};\n\n\thas.load = function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t\tConditional loading of AMD modules based on a has feature test value.\n\t\t// id: String\n\t\t//\t\tGives the resolved module id to load.\n\t\t// parentRequire: Function\n\t\t//\t\tThe loader require function with respect to the module that contained the plugin resource in it's\n\t\t//\t\tdependency list.\n\t\t// loaded: Function\n\t\t//\t Callback to loader that consumes result of plugin demand.\n\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/hccss.js":"define([\n\t\"require\",\t\t\t// require, require.toUrl\n\t\"./_base/config\", // config.blankGif\n\t\"./dom-class\", // domClass.add\n\t\"./dom-style\", // domStyle.getComputedStyle\n\t\"./has\",\n\t\"./domReady\",\n\t\"./_base/window\" // win.body\n], function(require, config, domClass, domStyle, has, domReady, win){\n\n\t// module:\n\t//\t\tdojo/hccss\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tTest if computer is in high contrast mode (i.e. if browser is not displaying background images).\n\t\t//\t\tDefines `has(\"highcontrast\")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.\n\t\t//\t\tReturns `has()` method;\n\t};\n\t=====*/\n\n\t// Has() test for when background images aren't displayed.  Don't call has(\"highcontrast\") before dojo/domReady!.\n\thas.add(\"highcontrast\", function(){\n\t\t// note: if multiple documents, doesn't matter which one we use\n\t\tvar div = win.doc.createElement(\"div\");\n\t\tdiv.style.cssText = \"border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;\" +\n\t\t\t\"background-image: url(\" + (config.blankGif || require.toUrl(\"./resources/blank.gif\")) + \");\";\n\t\twin.body().appendChild(div);\n\n\t\tvar cs = domStyle.getComputedStyle(div),\n\t\t\tbkImg = cs.backgroundImage,\n\t\t\thc = (cs.borderTopColor == cs.borderRightColor) ||\n\t\t\t\t(bkImg && (bkImg == \"none\" || bkImg == \"url(invalid-url:)\" ));\n\n\t\tif(has(\"ie\") <= 8){\n\t\t\tdiv.outerHTML = \"\";\t\t// prevent mixed-content warning, see http://support.microsoft.com/kb/925014\n\t\t}else{\n\t\t\twin.body().removeChild(div);\n\t\t}\n\n\t\treturn hc;\n\t});\n\n\tdomReady(function(){\n\t\tif(has(\"highcontrast\")){\n\t\t\tdomClass.add(win.body(), \"dj_a11y\");\n\t\t}\n\t});\n\n\treturn has;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/html.js":"define([\"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/declare\", \"./dom\", \"./dom-construct\", \"./parser\"],\n\tfunction(kernel, lang, darray, declare, dom, domConstruct, parser){\n\t// module:\n\t//\t\tdojo/html\n\n\t// the parser might be needed..\n\n\t// idCounter is incremented with each instantiation to allow assignment of a unique id for tracking, logging purposes\n\tvar idCounter = 0;\n\n\tvar html = {\n\t\t// summary:\n\t\t//\t\tTODOC\n\n\t\t_secureForInnerHtml: function(/*String*/ cont){\n\t\t\t// summary:\n\t\t\t//\t\tremoves !DOCTYPE and title elements from the html string.\n\t\t\t//\n\t\t\t//\t\tkhtml is picky about dom faults, you can't attach a style or `<title>` node as child of body\n\t\t\t//\t\tmust go into head, so we need to cut out those tags\n\t\t\t// cont:\n\t\t\t//\t\tAn html string for insertion into the dom\n\t\t\t//\n\t\t\treturn cont.replace(/(?:\\s*<!DOCTYPE\\s[^>]+>|<title[^>]*>[\\s\\S]*?<\\/title>)/ig, \"\"); // String\n\t\t},\n\n\t\t// Deprecated, should use dojo/dom-constuct.empty() directly, remove in 2.0.\n\t\t_emptyNode: domConstruct.empty,\n\n\t\t_setNodeContent: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont){\n\t\t\t// summary:\n\t\t\t//\t\tinserts the given content into the given node\n\t\t\t// node:\n\t\t\t//\t\tthe parent element\n\t\t\t// content:\n\t\t\t//\t\tthe content to be set on the parent element.\n\t\t\t//\t\tThis can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes\n\n\t\t\t// always empty\n\t\t\tdomConstruct.empty(node);\n\n\t\t\tif(cont){\n\t\t\t\tif(typeof cont == \"string\"){\n\t\t\t\t\tcont = domConstruct.toDom(cont, node.ownerDocument);\n\t\t\t\t}\n\t\t\t\tif(!cont.nodeType && lang.isArrayLike(cont)){\n\t\t\t\t\t// handle as enumerable, but it may shrink as we enumerate it\n\t\t\t\t\tfor(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0){\n\t\t\t\t\t\tdomConstruct.place( cont[i], node, \"last\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t// pass nodes, documentFragments and unknowns through to dojo.place\n\t\t\t\t\tdomConstruct.place(cont, node, \"last\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// return DomNode\n\t\t\treturn node;\n\t\t},\n\n\t\t// we wrap up the content-setting operation in a object\n\t\t_ContentSetter: declare(\"dojo.html._ContentSetter\", null, {\n\t\t\t// node: DomNode|String\n\t\t\t//\t\tAn node which will be the parent element that we set content into\n\t\t\tnode: \"\",\n\n\t\t\t// content: String|DomNode|DomNode[]\n\t\t\t//\t\tThe content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes\n\t\t\tcontent: \"\",\n\n\t\t\t// id: String?\n\t\t\t//\t\tUsually only used internally, and auto-generated with each instance\n\t\t\tid: \"\",\n\n\t\t\t// cleanContent: Boolean\n\t\t\t//\t\tShould the content be treated as a full html document,\n\t\t\t//\t\tand the real content stripped of <html>, <body> wrapper before injection\n\t\t\tcleanContent: false,\n\n\t\t\t// extractContent: Boolean\n\t\t\t//\t\tShould the content be treated as a full html document,\n\t\t\t//\t\tand the real content stripped of `<html> <body>` wrapper before injection\n\t\t\textractContent: false,\n\n\t\t\t// parseContent: Boolean\n\t\t\t//\t\tShould the node by passed to the parser after the new content is set\n\t\t\tparseContent: false,\n\n\t\t\t// parserScope: String\n\t\t\t//\t\tFlag passed to parser.\tRoot for attribute names to search for.\t  If scopeName is dojo,\n\t\t\t//\t\twill search for data-dojo-type (or dojoType).  For backwards compatibility\n\t\t\t//\t\treasons defaults to dojo._scopeName (which is \"dojo\" except when\n\t\t\t//\t\tmulti-version support is used, when it will be something like dojo16, dojo20, etc.)\n\t\t\tparserScope: kernel._scopeName,\n\n\t\t\t// startup: Boolean\n\t\t\t//\t\tStart the child widgets after parsing them.\t  Only obeyed if parseContent is true.\n\t\t\tstartup: true,\n\n\t\t\t// lifecycle methods\n\t\t\tconstructor: function(/*Object*/ params, /*String|DomNode*/ node){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tProvides a configurable, extensible object to wrap the setting on content on a node\n\t\t\t\t//\t\tcall the set() method to actually set the content..\n\n\t\t\t\t// the original params are mixed directly into the instance \"this\"\n\t\t\t\tlang.mixin(this, params || {});\n\n\t\t\t\t// give precedence to params.node vs. the node argument\n\t\t\t\t// and ensure its a node, not an id string\n\t\t\t\tnode = this.node = dom.byId( this.node || node );\n\n\t\t\t\tif(!this.id){\n\t\t\t\t\tthis.id = [\n\t\t\t\t\t\t\"Setter\",\n\t\t\t\t\t\t(node) ? node.id || node.tagName : \"\",\n\t\t\t\t\t\tidCounter++\n\t\t\t\t\t].join(\"_\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: function(/* String|DomNode|NodeList? */ cont, /*Object?*/ params){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tfront-end to the set-content sequence\n\t\t\t\t// cont:\n\t\t\t\t//\t\tAn html string, node or enumerable list of nodes for insertion into the dom\n\t\t\t\t//\t\tIf not provided, the object's content property will be used\n\t\t\t\tif(undefined !== cont){\n\t\t\t\t\tthis.content = cont;\n\t\t\t\t}\n\t\t\t\t// in the re-use scenario, set needs to be able to mixin new configuration\n\t\t\t\tif(params){\n\t\t\t\t\tthis._mixin(params);\n\t\t\t\t}\n\n\t\t\t\tthis.onBegin();\n\t\t\t\tthis.setContent();\n\n\t\t\t\tvar ret = this.onEnd();\n\n\t\t\t\tif(ret && ret.then){\n\t\t\t\t\t// Make dojox/html/_ContentSetter.set() return a Promise that resolves when load and parse complete.\n\t\t\t\t\treturn ret;\n\t\t\t\t}else{\n\t\t\t\t\t// Vanilla dojo/html._ContentSetter.set() returns a DOMNode for back compat.   For 2.0, switch it to\n\t\t\t\t\t// return a Deferred like above.\n\t\t\t\t\treturn this.node;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsetContent: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tsets the content on the node\n\n\t\t\t\tvar node = this.node;\n\t\t\t\tif(!node){\n\t\t\t\t\t// can't proceed\n\t\t\t\t\tthrow new Error(this.declaredClass + \": setContent given no node\");\n\t\t\t\t}\n\t\t\t\ttry{\n\t\t\t\t\tnode = html._setNodeContent(node, this.content);\n\t\t\t\t}catch(e){\n\t\t\t\t\t// check if a domfault occurs when we are appending this.errorMessage\n\t\t\t\t\t// like for instance if domNode is a UL and we try append a DIV\n\n\t\t\t\t\t// FIXME: need to allow the user to provide a content error message string\n\t\t\t\t\tvar errMess = this.onContentError(e);\n\t\t\t\t\ttry{\n\t\t\t\t\t\tnode.innerHTML = errMess;\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tconsole.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// always put back the node for the next method\n\t\t\t\tthis.node = node; // DomNode\n\t\t\t},\n\n\t\t\tempty: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tcleanly empty out existing content\n\n\t\t\t\t// If there is a parse in progress, cancel it.\n\t\t\t\tif(this.parseDeferred){\n\t\t\t\t\tif(!this.parseDeferred.isResolved()){\n\t\t\t\t\t\tthis.parseDeferred.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tdelete this.parseDeferred;\n\t\t\t\t}\n\n\t\t\t\t// destroy any widgets from a previous run\n\t\t\t\t// NOTE: if you don't want this you'll need to empty\n\t\t\t\t// the parseResults array property yourself to avoid bad things happening\n\t\t\t\tif(this.parseResults && this.parseResults.length){\n\t\t\t\t\tdarray.forEach(this.parseResults, function(w){\n\t\t\t\t\t\tif(w.destroy){\n\t\t\t\t\t\t\tw.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdelete this.parseResults;\n\t\t\t\t}\n\t\t\t\t// this is fast, but if you know its already empty or safe, you could\n\t\t\t\t// override empty to skip this step\n\t\t\t\tdomConstruct.empty(this.node);\n\t\t\t},\n\n\t\t\tonBegin: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalled after instantiation, but before set();\n\t\t\t\t//\t\tIt allows modification of any of the object properties -\n\t\t\t\t//\t\tincluding the node and content provided - before the set operation actually takes place\n\t\t\t\t//\t\tThis default implementation checks for cleanContent and extractContent flags to\n\t\t\t\t//\t\toptionally pre-process html string content\n\t\t\t\tvar cont = this.content;\n\n\t\t\t\tif(lang.isString(cont)){\n\t\t\t\t\tif(this.cleanContent){\n\t\t\t\t\t\tcont = html._secureForInnerHtml(cont);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(this.extractContent){\n\t\t\t\t\t\tvar match = cont.match(/<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im);\n\t\t\t\t\t\tif(match){ cont = match[1]; }\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// clean out the node and any cruft associated with it - like widgets\n\t\t\t\tthis.empty();\n\n\t\t\t\tthis.content = cont;\n\t\t\t\treturn this.node; // DomNode\n\t\t\t},\n\n\t\t\tonEnd: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tCalled after set(), when the new content has been pushed into the node\n\t\t\t\t//\t\tIt provides an opportunity for post-processing before handing back the node to the caller\n\t\t\t\t//\t\tThis default implementation checks a parseContent flag to optionally run the dojo parser over the new content\n\t\t\t\tif(this.parseContent){\n\t\t\t\t\t// populates this.parseResults and this.parseDeferred if you need those..\n\t\t\t\t\tthis._parse();\n\t\t\t\t}\n\t\t\t\treturn this.node; // DomNode\n\t\t\t\t// TODO: for 2.0 return a Promise indicating that the parse completed.\n\t\t\t},\n\n\t\t\ttearDown: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tmanually reset the Setter instance if its being re-used for example for another set()\n\t\t\t\t// description:\n\t\t\t\t//\t\ttearDown() is not called automatically.\n\t\t\t\t//\t\tIn normal use, the Setter instance properties are simply allowed to fall out of scope\n\t\t\t\t//\t\tbut the tearDown method can be called to explicitly reset this instance.\n\t\t\t\tdelete this.parseResults;\n\t\t\t\tdelete this.parseDeferred;\n\t\t\t\tdelete this.node;\n\t\t\t\tdelete this.content;\n\t\t\t},\n\n\t\t\tonContentError: function(err){\n\t\t\t\treturn \"Error occurred setting content: \" + err;\n\t\t\t},\n\n\t\t\tonExecError: function(err){\n\t\t\t\treturn \"Error occurred executing scripts: \" + err;\n\t\t\t},\n\n\t\t\t_mixin: function(params){\n\t\t\t\t// mix properties/methods into the instance\n\t\t\t\t// TODO: the intention with tearDown is to put the Setter's state\n\t\t\t\t// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)\n\t\t\t\t// so we could do something here to move the original properties aside for later restoration\n\t\t\t\tvar empty = {}, key;\n\t\t\t\tfor(key in params){\n\t\t\t\t\tif(key in empty){ continue; }\n\t\t\t\t\t// TODO: here's our opportunity to mask the properties we don't consider configurable/overridable\n\t\t\t\t\t// .. but history shows we'll almost always guess wrong\n\t\t\t\t\tthis[key] = params[key];\n\t\t\t\t}\n\t\t\t},\n\t\t\t_parse: function(){\n\t\t\t\t// summary:\n\t\t\t\t//\t\truns the dojo parser over the node contents, storing any results in this.parseResults\n\t\t\t\t//\t\tand the parse promise in this.parseDeferred\n\t\t\t\t//\t\tAny errors resulting from parsing are passed to _onError for handling\n\n\t\t\t\tvar rootNode = this.node;\n\t\t\t\ttry{\n\t\t\t\t\t// store the results (widgets, whatever) for potential retrieval\n\t\t\t\t\tvar inherited = {};\n\t\t\t\t\tdarray.forEach([\"dir\", \"lang\", \"textDir\"], function(name){\n\t\t\t\t\t\tif(this[name]){\n\t\t\t\t\t\t\tinherited[name] = this[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this);\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tthis.parseDeferred = parser.parse({\n\t\t\t\t\t\trootNode: rootNode,\n\t\t\t\t\t\tnoStart: !this.startup,\n\t\t\t\t\t\tinherited: inherited,\n\t\t\t\t\t\tscope: this.parserScope\n\t\t\t\t\t}).then(function(results){\n\t\t\t\t\t\t\treturn self.parseResults = results;\n\t\t\t\t\t\t}, function(e){\n\t\t\t\t\t\t\tself._onError('Content', e, \"Error parsing in _ContentSetter#\" + this.id);\n\t\t\t\t\t\t});\n\t\t\t\t}catch(e){\n\t\t\t\t\tthis._onError('Content', e, \"Error parsing in _ContentSetter#\" + this.id);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_onError: function(type, err, consoleText){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tshows user the string that is returned by on[type]Error\n\t\t\t\t//\t\toverride/implement on[type]Error and return your own string to customize\n\t\t\t\tvar errText = this['on' + type + 'Error'].call(this, err);\n\t\t\t\tif(consoleText){\n\t\t\t\t\tconsole.error(consoleText, err);\n\t\t\t\t}else if(errText){ // a empty string won't change current content\n\t\t\t\t\thtml._setNodeContent(this.node, errText, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}), // end declare()\n\n\t\tset: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont, /*Object?*/ params){\n\t\t\t// summary:\n\t\t\t//\t\tinserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, \"only\")\n\t\t\t//\t\tmay be a better choice for simple HTML insertion.\n\t\t\t// description:\n\t\t\t//\t\tUnless you need to use the params capabilities of this method, you should use\n\t\t\t//\t\tdojo/dom-construct.place(cont, node, \"only\"). dojo/dom-construct..place() has more robust support for injecting\n\t\t\t//\t\tan HTML string into the DOM, but it only handles inserting an HTML string as DOM\n\t\t\t//\t\telements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions\n\t\t\t//\t\tdojo/dom-construct.place(cont, node, \"only\"). dojo/dom-construct.place() has more robust support for injecting\n\t\t\t//\t\tan HTML string into the DOM, but it only handles inserting an HTML string as DOM\n\t\t\t//\t\telements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions\n\t\t\t//\t\tor the other capabilities as defined by the params object for this method.\n\t\t\t// node:\n\t\t\t//\t\tthe parent element that will receive the content\n\t\t\t// cont:\n\t\t\t//\t\tthe content to be set on the parent element.\n\t\t\t//\t\tThis can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes\n\t\t\t// params:\n\t\t\t//\t\tOptional flags/properties to configure the content-setting. See dojo/html/_ContentSetter\n\t\t\t// example:\n\t\t\t//\t\tA safe string/node/nodelist content replacement/injection with hooks for extension\n\t\t\t//\t\tExample Usage:\n\t\t\t//\t|\thtml.set(node, \"some string\");\n\t\t\t//\t|\thtml.set(node, contentNode, {options});\n\t\t\t//\t|\thtml.set(node, myNode.childNodes, {options});\n\t\t\tif(undefined == cont){\n\t\t\t\tconsole.warn(\"dojo.html.set: no cont argument provided, using empty string\");\n\t\t\t\tcont = \"\";\n\t\t\t}\n\t\t\tif(!params){\n\t\t\t\t// simple and fast\n\t\t\t\treturn html._setNodeContent(node, cont, true);\n\t\t\t}else{\n\t\t\t\t// more options but slower\n\t\t\t\t// note the arguments are reversed in order, to match the convention for instantiation via the parser\n\t\t\t\tvar op = new html._ContentSetter(lang.mixin(\n\t\t\t\t\tparams,\n\t\t\t\t\t{ content: cont, node: node }\n\t\t\t\t));\n\t\t\t\treturn op.set();\n\t\t\t}\n\t\t}\n\t};\n\tlang.setObject(\"dojo.html\", html);\n\n\treturn html;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/i18n.js":"define([\"./_base/kernel\", \"require\", \"./has\", \"./_base/array\", \"./_base/config\", \"./_base/lang\", \"./has!host-browser?./_base/xhr\", \"./json\", \"module\"],\n\tfunction(dojo, require, has, array, config, lang, xhr, json, module){\n\n\t// module:\n\t//\t\tdojo/i18n\n\n\thas.add(\"dojo-preload-i18n-Api\",\n\t\t// if true, define the preload localizations machinery\n\t\t1\n\t);\n\n\thas.add(\"dojo-v1x-i18n-Api\",\n\t\t// if true, define the v1.x i18n functions\n\t\t1\n\t);\n\n\tvar\n\t\tthisModule = dojo.i18n =\n\t\t\t{\n\t\t\t\t// summary:\n\t\t\t\t//\t\tThis module implements the dojo/i18n! plugin and the v1.6- i18n API\n\t\t\t\t// description:\n\t\t\t\t//\t\tWe choose to include our own plugin to leverage functionality already contained in dojo\n\t\t\t\t//\t\tand thereby reduce the size of the plugin compared to various loader implementations. Also, this\n\t\t\t\t//\t\tallows foreign AMD loaders to be used without their plugins.\n\t\t\t},\n\n\t\tnlsRe =\n\t\t\t// regexp for reconstructing the master bundle name from parts of the regexp match\n\t\t\t// nlsRe.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\n\t\t\t// [\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\n\t\t\t// nlsRe.exec(\"foo/bar/baz/nls/foo\") gives:\n\t\t\t// [\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\n\t\t\t// so, if match[5] is blank, it means this is the top bundle definition.\n\t\t\t// courtesy of http://requirejs.org\n\t\t\t/(^.*(^|\\/)nls)(\\/|$)([^\\/]*)\\/?([^\\/]*)/,\n\n\t\tgetAvailableLocales = function(\n\t\t\troot,\n\t\t\tlocale,\n\t\t\tbundlePath,\n\t\t\tbundleName\n\t\t){\n\t\t\t// summary:\n\t\t\t//\t\treturn a vector of module ids containing all available locales with respect to the target locale\n\t\t\t//\t\tFor example, assuming:\n\t\t\t//\n\t\t\t//\t\t- the root bundle indicates specific bundles for \"fr\" and \"fr-ca\",\n\t\t\t//\t\t-  bundlePath is \"myPackage/nls\"\n\t\t\t//\t\t- bundleName is \"myBundle\"\n\t\t\t//\n\t\t\t//\t\tThen a locale argument of \"fr-ca\" would return\n\t\t\t//\n\t\t\t//\t\t\t[\"myPackage/nls/myBundle\", \"myPackage/nls/fr/myBundle\", \"myPackage/nls/fr-ca/myBundle\"]\n\t\t\t//\n\t\t\t//\t\tNotice that bundles are returned least-specific to most-specific, starting with the root.\n\t\t\t//\n\t\t\t//\t\tIf root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;\n\t\t\t//\t\ttherefore, assume everything is available and get 404 errors that indicate a particular localization is not available\n\n\t\t\tfor(var result = [bundlePath + bundleName], localeParts = locale.split(\"-\"), current = \"\", i = 0; i<localeParts.length; i++){\n\t\t\t\tcurrent += (current ? \"-\" : \"\") + localeParts[i];\n\t\t\t\tif(!root || root[current]){\n\t\t\t\t\tresult.push(bundlePath + current + \"/\" + bundleName);\n\t\t\t\t\tresult.specificity = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\tcache = {},\n\n\t\tgetBundleName = function(moduleName, bundleName, locale){\n\t\t\tlocale = locale ? locale.toLowerCase() : dojo.locale;\n\t\t\tmoduleName = moduleName.replace(/\\./g, \"/\");\n\t\t\tbundleName = bundleName.replace(/\\./g, \"/\");\n\t\t\treturn (/root/i.test(locale)) ?\n\t\t\t\t(moduleName + \"/nls/\" + bundleName) :\n\t\t\t\t(moduleName + \"/nls/\" + locale + \"/\" + bundleName);\n\t\t},\n\n\t\tgetL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){\n\t\t\treturn moduleName = module.id + \"!\" + getBundleName(moduleName, bundleName, locale);\n\t\t},\n\n\t\tdoLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){\n\t\t\t// summary:\n\t\t\t//\t\tget the root bundle which instructs which other bundles are required to construct the localized bundle\n\t\t\trequire([bundlePathAndName], function(root){\n\t\t\t\tvar current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT\n\t\t\t\t\tavailableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);\n\t\t\t\trequire(availableLocales, function(){\n\t\t\t\t\tfor (var i = 1; i<availableLocales.length; i++){\n\t\t\t\t\t\tcurrent = lang.mixin(lang.clone(current), arguments[i]);\n\t\t\t\t\t}\n\t\t\t\t\t// target may not have been resolve (e.g., maybe only \"fr\" exists when \"fr-ca\" was requested)\n\t\t\t\t\tvar target = bundlePathAndName + \"/\" + locale;\n\t\t\t\t\tcache[target] = current;\n\t\t\t\t\tcurrent.$locale = availableLocales.specificity;\n\t\t\t\t\tload();\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tnormalize = function(id, toAbsMid){\n\t\t\t// summary:\n\t\t\t//\t\tid may be relative.\n\t\t\t//\t\tpreload has form `*preload*<path>/nls/<module>*<flattened locales>` and\n\t\t\t//\t\ttherefore never looks like a relative\n\t\t\treturn /^\\./.test(id) ? toAbsMid(id) : id;\n\t\t},\n\n\t\tgetLocalesToLoad = function(targetLocale){\n\t\t\tvar list = config.extraLocale || [];\n\t\t\tlist = lang.isArray(list) ? list : [list];\n\t\t\tlist.push(targetLocale);\n\t\t\treturn list;\n\t\t},\n\n\t\tload = function(id, require, load){\n\t\t\t// summary:\n\t\t\t//\t\tid is in one of the following formats\n\t\t\t//\n\t\t\t//\t\t1. <path>/nls/<bundle>\n\t\t\t//\t\t\t=> load the bundle, localized to config.locale; load all bundles localized to\n\t\t\t//\t\t\tconfig.extraLocale (if any); return the loaded bundle localized to config.locale.\n\t\t\t//\n\t\t\t//\t\t2. <path>/nls/<locale>/<bundle>\n\t\t\t//\t\t\t=> load then return the bundle localized to <locale>\n\t\t\t//\n\t\t\t//\t\t3. *preload*<path>/nls/<module>*<JSON array of available locales>\n\t\t\t//\t\t\t=> for config.locale and all config.extraLocale, load all bundles found\n\t\t\t//\t\t\tin the best-matching bundle rollup. A value of 1 is returned, which\n\t\t\t//\t\t\tis meaningless other than to say the plugin is executing the requested\n\t\t\t//\t\t\tpreloads\n\t\t\t//\n\t\t\t//\t\tIn cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see\n\t\t\t//\t\tnormalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.\n\t\t\t//\n\t\t\t//\t\tTo load a bundle means to insert the bundle into the plugin's cache and publish the bundle\n\t\t\t//\t\tvalue to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key\n\t\t\t//\n\t\t\t//\t\t\t<path>/nls/<bundle>/<locale>\n\t\t\t//\n\t\t\t//\t\twill hold the value. Similarly, then plugin will publish this value to the loader by\n\t\t\t//\n\t\t\t//\t\t\tdefine(\"<path>/nls/<bundle>/<locale>\", <bundle-value>);\n\t\t\t//\n\t\t\t//\t\tGiven this algorithm, other machinery can provide fast load paths be preplacing\n\t\t\t//\t\tvalues in the plugin's cache, which is public. When a load is demanded the\n\t\t\t//\t\tcache is inspected before starting any loading. Explicitly placing values in the plugin\n\t\t\t//\t\tcache is an advanced/experimental feature that should not be needed; use at your own risk.\n\t\t\t//\n\t\t\t//\t\tFor the normal AMD algorithm, the root bundle is loaded first, which instructs the\n\t\t\t//\t\tplugin what additional localized bundles are required for a particular locale. These\n\t\t\t//\t\tadditional locales are loaded and a mix of the root and each progressively-specific\n\t\t\t//\t\tlocale is returned. For example:\n\t\t\t//\n\t\t\t//\t\t1. The client demands \"dojo/i18n!some/path/nls/someBundle\n\t\t\t//\n\t\t\t//\t\t2. The loader demands load(some/path/nls/someBundle)\n\t\t\t//\n\t\t\t//\t\t3. This plugin require's \"some/path/nls/someBundle\", which is the root bundle.\n\t\t\t//\n\t\t\t//\t\t4. Assuming config.locale is \"ab-cd-ef\" and the root bundle indicates that localizations\n\t\t\t//\t\tare available for \"ab\" and \"ab-cd-ef\" (note the missing \"ab-cd\", then the plugin\n\t\t\t//\t\trequires \"some/path/nls/ab/someBundle\" and \"some/path/nls/ab-cd-ef/someBundle\"\n\t\t\t//\n\t\t\t//\t\t5. Upon receiving all required bundles, the plugin constructs the value of the bundle\n\t\t\t//\t\tab-cd-ef as...\n\t\t\t//\n\t\t\t//\t\t\t\tmixin(mixin(mixin({}, require(\"some/path/nls/someBundle\"),\n\t\t\t//\t\t  \t\t\trequire(\"some/path/nls/ab/someBundle\")),\n\t\t\t//\t\t\t\t\trequire(\"some/path/nls/ab-cd-ef/someBundle\"));\n\t\t\t//\n\t\t\t//\t\tThis value is inserted into the cache and published to the loader at the\n\t\t\t//\t\tkey/module-id some/path/nls/someBundle/ab-cd-ef.\n\t\t\t//\n\t\t\t//\t\tThe special preload signature (case 3) instructs the plugin to stop servicing all normal requests\n\t\t\t//\t\t(further preload requests will be serviced) until all ongoing preloading has completed.\n\t\t\t//\n\t\t\t//\t\tThe preload signature instructs the plugin that a special rollup module is available that contains\n\t\t\t//\t\tone or more flattened, localized bundles. The JSON array of available locales indicates which locales\n\t\t\t//\t\tare available. Here is an example:\n\t\t\t//\n\t\t\t//\t\t\t*preload*some/path/nls/someModule*[\"root\", \"ab\", \"ab-cd-ef\"]\n\t\t\t//\n\t\t\t//\t\tThis indicates the following rollup modules are available:\n\t\t\t//\n\t\t\t//\t\t\tsome/path/nls/someModule_ROOT\n\t\t\t//\t\t\tsome/path/nls/someModule_ab\n\t\t\t//\t\t\tsome/path/nls/someModule_ab-cd-ef\n\t\t\t//\n\t\t\t//\t\tEach of these modules is a normal AMD module that contains one or more flattened bundles in a hash.\n\t\t\t//\t\tFor example, assume someModule contained the bundles some/bundle/path/someBundle and\n\t\t\t//\t\tsome/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:\n\t\t\t//\n\t\t\t//\t\t\tdefine({\n\t\t\t//\t\t\t\tsome/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,\n\t\t\t//\t\t\t\tsome/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,\n\t\t\t//\t\t\t});\n\t\t\t//\n\t\t\t//\t\tE.g., given this design, preloading for locale==\"ab\" can execute the following algorithm:\n\t\t\t//\n\t\t\t//\t\t\trequire([\"some/path/nls/someModule_ab\"], function(rollup){\n\t\t\t//\t\t\t\tfor(var p in rollup){\n\t\t\t//\t\t\t\t\tvar id = p + \"/ab\",\n\t\t\t//\t\t\t\t\tcache[id] = rollup[p];\n\t\t\t//\t\t\t\t\tdefine(id, rollup[p]);\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t});\n\t\t\t//\n\t\t\t//\t\tSimilarly, if \"ab-cd\" is requested, the algorithm can determine that \"ab\" is the best available and\n\t\t\t//\t\tload accordingly.\n\t\t\t//\n\t\t\t//\t\tThe builder will write such rollups for every layer if a non-empty localeList  profile property is\n\t\t\t//\t\tprovided. Further, the builder will include the following cache entry in the cache associated with\n\t\t\t//\t\tany layer.\n\t\t\t//\n\t\t\t//\t\t\t\"*now\":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}\n\t\t\t//\n\t\t\t//\t\tThe *now special cache module instructs the loader to apply the provided function to context-require\n\t\t\t//\t\twith respect to the particular layer being defined. This causes the plugin to hold all normal service\n\t\t\t//\t\trequests until all preloading is complete.\n\t\t\t//\n\t\t\t//\t\tNotice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case\n\t\t\t//\t\twhere the target locale has a single segment and a layer depends on a single bundle:\n\t\t\t//\n\t\t\t//\t\tWithout Preloads:\n\t\t\t//\n\t\t\t//\t\t1. Layer loads root bundle.\n\t\t\t//\t\t2. bundle is demanded; plugin loads single localized bundle.\n\t\t\t//\n\t\t\t//\t\tWith Preloads:\n\t\t\t//\n\t\t\t//\t\t1. Layer causes preloading of target bundle.\n\t\t\t//\t\t2. bundle is demanded; service is delayed until preloading complete; bundle is returned.\n\t\t\t//\n\t\t\t//\t\tIn each case a single transaction is required to load the target bundle. In cases where multiple bundles\n\t\t\t//\t\tare required and/or the locale has multiple segments, preloads still requires a single transaction whereas\n\t\t\t//\t\tthe normal path requires an additional transaction for each additional bundle/locale-segment. However all\n\t\t\t//\t\tof these additional transactions can be done concurrently. Owing to this analysis, the entire preloading\n\t\t\t//\t\talgorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.\n\n\t\t\tif(has(\"dojo-preload-i18n-Api\")){\n\t\t\t\tvar split = id.split(\"*\"),\n\t\t\t\t\tpreloadDemand = split[1] == \"preload\";\n\t\t\t\tif(preloadDemand){\n\t\t\t\t\tif(!cache[id]){\n\t\t\t\t\t\t// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but\n\t\t\t\t\t\t// who knows what over-aggressive human optimizers may attempt\n\t\t\t\t\t\tcache[id] = 1;\n\t\t\t\t\t\tpreloadL10n(split[2], json.parse(split[3]), 1, require);\n\t\t\t\t\t}\n\t\t\t\t\t// don't stall the loader!\n\t\t\t\t\tload(1);\n\t\t\t\t}\n\t\t\t\tif(preloadDemand || waitForPreloads(id, require, load)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar match = nlsRe.exec(id),\n\t\t\t\tbundlePath = match[1] + \"/\",\n\t\t\t\tbundleName = match[5] || match[4],\n\t\t\t\tbundlePathAndName = bundlePath + bundleName,\n\t\t\t\tlocaleSpecified = (match[5] && match[4]),\n\t\t\t\ttargetLocale =\tlocaleSpecified || dojo.locale || \"\",\n\t\t\t\tloadTarget = bundlePathAndName + \"/\" + targetLocale,\n\t\t\t\tloadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),\n\t\t\t\tremaining = loadList.length,\n\t\t\t\tfinish = function(){\n\t\t\t\t\tif(!--remaining){\n\t\t\t\t\t\tload(lang.delegate(cache[loadTarget]));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\tarray.forEach(loadList, function(locale){\n\t\t\t\tvar target = bundlePathAndName + \"/\" + locale;\n\t\t\t\tif(has(\"dojo-preload-i18n-Api\")){\n\t\t\t\t\tcheckForLegacyModules(target);\n\t\t\t\t}\n\t\t\t\tif(!cache[target]){\n\t\t\t\t\tdoLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);\n\t\t\t\t}else{\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\tif(has(\"dojo-unit-tests\")){\n\t\tvar unitTests = thisModule.unitTests = [];\n\t}\n\n\tif(has(\"dojo-preload-i18n-Api\") || has(\"dojo-v1x-i18n-Api\")){\n\t\tvar normalizeLocale = thisModule.normalizeLocale = function(locale){\n\t\t\t\tvar result = locale ? locale.toLowerCase() : dojo.locale;\n\t\t\t\treturn result == \"root\" ? \"ROOT\" : result;\n\t\t\t},\n\n\t\t\tisXd = function(mid, contextRequire){\n\t\t\t\treturn (has(\"dojo-sync-loader\") && has(\"dojo-v1x-i18n-Api\")) ?\n\t\t\t\t\tcontextRequire.isXdUrl(require.toUrl(mid + \".js\")) :\n\t\t\t\t\ttrue;\n\t\t\t},\n\n\t\t\tpreloading = 0,\n\n\t\t\tpreloadWaitQueue = [],\n\n\t\t\tpreloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tLoad available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)\n\t\t\t\t// description:\n\t\t\t\t//\t\tOnly called by built layer files. The entire locale hierarchy is loaded. For example,\n\t\t\t\t//\t\tif locale==\"ab-cd\", then ROOT, \"ab\", and \"ab-cd\" are loaded. This is different than v1.6-\n\t\t\t\t//\t\tin that the v1.6- would only load ab-cd...which was *always* flattened.\n\t\t\t\t//\n\t\t\t\t//\t\tIf guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm\n\t\t\t\t//\t\tand the extra possible extra transaction.\n\n\t\t\t\t// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function\n\t\t\t\t// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which\n\t\t\t\t// itself may have been mapped.\n\t\t\t\tcontextRequire = contextRequire || require;\n\n\t\t\t\tfunction doRequire(mid, callback){\n\t\t\t\t\tif(isXd(mid, contextRequire) || guaranteedAmdFormat){\n\t\t\t\t\t\tcontextRequire([mid], callback);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsyncRequire([mid], callback, contextRequire);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction forEachLocale(locale, func){\n\t\t\t\t\t// given locale= \"ab-cd-ef\", calls func on \"ab-cd-ef\", \"ab-cd\", \"ab\", \"ROOT\"; stops calling the first time func returns truthy\n\t\t\t\t\tvar parts = locale.split(\"-\");\n\t\t\t\t\twhile(parts.length){\n\t\t\t\t\t\tif(func(parts.join(\"-\"))){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfunc(\"ROOT\");\n\t\t\t\t}\n\n\t\t\t\t\tfunction preloadingAddLock(){\n\t\t\t\t\t\tpreloading++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction preloadingRelLock(){\n\t\t\t\t\t\t--preloading;\n\t\t\t\t\t\twhile(!preloading && preloadWaitQueue.length){\n\t\t\t\t\t\t\tload.apply(null, preloadWaitQueue.shift());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction cacheId(path, name, loc, require){\n\t\t\t\t\t\t// path is assumed to have a trailing \"/\"\n\t\t\t\t\t\treturn require.toAbsMid(path + name + \"/\" + loc)\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction preload(locale){\n\t\t\t\t\t\tlocale = normalizeLocale(locale);\n\t\t\t\t\t\tforEachLocale(locale, function(loc){\n\t\t\t\t\t\t\tif(array.indexOf(localesGenerated, loc) >= 0){\n\t\t\t\t\t\t\t\tvar mid = bundlePrefix.replace(/\\./g, \"/\") + \"_\" + loc;\n\t\t\t\t\t\t\t\tpreloadingAddLock();\n\t\t\t\t\t\t\t\tdoRequire(mid, function(rollup){\n\t\t\t\t\t\t\t\t\tfor(var p in rollup){\n\t\t\t\t\t\t\t\t\t\tvar bundle = rollup[p],\n\t\t\t\t\t\t\t\t\t\t\tmatch = p.match(/(.+)\\/([^\\/]+)$/),\n\t\t\t\t\t\t\t\t\t\t\tbundleName, bundlePath;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t// If there is no match, the bundle is not a regular bundle from an AMD layer.\n\t\t\t\t\t\t\t\t\t\t\tif (!match){continue;}\n\n\t\t\t\t\t\t\t\t\t\t\tbundleName = match[2];\n\t\t\t\t\t\t\t\t\t\t\tbundlePath = match[1] + \"/\";\n\n\t\t\t\t\t\t\t\t\t\t// backcompat\n\t\t\t\t\t\t\t\t\t\tbundle._localized = bundle._localized || {};\n\n\t\t\t\t\t\t\t\t\t\tvar localized;\n\t\t\t\t\t\t\t\t\t\tif(loc === \"ROOT\"){\n\t\t\t\t\t\t\t\t\t\t\tvar root = localized = bundle._localized;\n\t\t\t\t\t\t\t\t\t\t\tdelete bundle._localized;\n\t\t\t\t\t\t\t\t\t\t\troot.root = bundle;\n\t\t\t\t\t\t\t\t\t\t\tcache[require.toAbsMid(p)] = root;\n\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\tlocalized = bundle._localized;\n\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, loc, require)] = bundle;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif(loc !== locale){\n\t\t\t\t\t\t\t\t\t\t\t// capture some locale variables\n\t\t\t\t\t\t\t\t\t\t\tfunction improveBundle(bundlePath, bundleName, bundle, localized){\n\t\t\t\t\t\t\t\t\t\t\t\t// locale was not flattened and we've fallen back to a less-specific locale that was flattened\n\t\t\t\t\t\t\t\t\t\t\t\t// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and\n\t\t\t\t\t\t\t\t\t\t\t\t// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by\n\t\t\t\t\t\t\t\t\t\t\t\t// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'\n\t\t\t\t\t\t\t\t\t\t\t\t// version of the bundle.\n\t\t\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t\t\t// Remember, different bundles may have different sets of locales available.\n\t\t\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t\t\t// we are really falling back on the regular algorithm here, but--hopefully--starting with most\n\t\t\t\t\t\t\t\t\t\t\t\t// of the required bundles already on board as given by the rollup and we need to \"manually\" load\n\t\t\t\t\t\t\t\t\t\t\t\t// only one locale from a few bundles...or even better...we won't find anything better to load.\n\t\t\t\t\t\t\t\t\t\t\t\t// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.\n\t\t\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t\t\t// note: this feature is only available in async mode\n\n\t\t\t\t\t\t\t\t\t\t\t\t// inspect the loaded bundle that came from the rollup to see if something better is available\n\t\t\t\t\t\t\t\t\t\t\t\t// for any bundle in a rollup, more-specific available locales are given at localized.\n\t\t\t\t\t\t\t\t\t\t\t\tvar requiredBundles = [],\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheIds = [];\n\t\t\t\t\t\t\t\t\t\t\t\tforEachLocale(locale, function(loc){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(localized[loc]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequiredBundles.push(require.toAbsMid(bundlePath + loc + \"/\" + bundleName));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcacheIds.push(cacheId(bundlePath, bundleName, loc, require));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(requiredBundles.length){\n\t\t\t\t\t\t\t\t\t\t\t\t\tpreloadingAddLock();\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontextRequire(requiredBundles, function(){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(var i = 0; i < requiredBundles.length; i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbundle = lang.mixin(lang.clone(bundle), arguments[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheIds[i]] = bundle;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// this is the best possible (maybe a perfect match, maybe not), accept it\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpreloadingRelLock();\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t// this is the best possible (definitely not a perfect match), accept it\n\t\t\t\t\t\t\t\t\t\t\t\t\tcache[cacheId(bundlePath, bundleName, locale, require)] = bundle;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\timproveBundle(bundlePath, bundleName, bundle, localized);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpreloadingRelLock();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\tpreload();\n\t\t\t\tarray.forEach(dojo.config.extraLocale, preload);\n\t\t\t},\n\n\t\t\twaitForPreloads = function(id, require, load){\n\t\t\t\tif(preloading){\n\t\t\t\t\tpreloadWaitQueue.push([id, require, load]);\n\t\t\t\t}\n\t\t\t\treturn preloading;\n\t\t\t},\n\n\t\t\tcheckForLegacyModules = function()\n\t\t\t\t{};\n\t}\n\n\tif(has(\"dojo-v1x-i18n-Api\")){\n\t\t// this code path assumes the dojo loader and won't work with a standard AMD loader\n\t\tvar amdValue = {},\n\t\t\tevalBundle =\n\t\t\t\t// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)\n\t\t\t\tnew Function(\n\t\t\t\t\t\"__bundle\",\t\t\t\t   // the bundle to evalutate\n\t\t\t\t\t\"__checkForLegacyModules\", // a function that checks if __bundle defined __mid in the global space\n\t\t\t\t\t\"__mid\",\t\t\t\t   // the mid that __bundle is intended to define\n\t\t\t\t\t\"__amdValue\",\n\n\t\t\t\t\t// returns one of:\n\t\t\t\t\t//\t\t1 => the bundle was an AMD bundle\n\t\t\t\t\t//\t\ta legacy bundle object that is the value of __mid\n\t\t\t\t\t//\t\tinstance of Error => could not figure out how to evaluate bundle\n\n\t\t\t\t\t  // used to detect when __bundle calls define\n\t\t\t\t\t  \"var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},\"\n\t\t\t\t\t+ \"\t   require = function(){define.called = 1;};\"\n\n\t\t\t\t\t+ \"try{\"\n\t\t\t\t\t+\t\t\"define.called = 0;\"\n\t\t\t\t\t+\t\t\"eval(__bundle);\"\n\t\t\t\t\t+\t\t\"if(define.called==1)\"\n\t\t\t\t\t\t\t\t// bundle called define; therefore signal it's an AMD bundle\n\t\t\t\t\t+\t\t\t\"return __amdValue;\"\n\n\t\t\t\t\t+\t\t\"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))\"\n\t\t\t\t\t\t\t\t// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space\n\t\t\t\t\t+\t\t\t\"return __checkForLegacyModules;\"\n\n\t\t\t\t\t+ \"}catch(e){}\"\n\t\t\t\t\t// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle\n\t\t\t\t\t// either way, re-eval *after* surrounding with parentheses\n\n\t\t\t\t\t+ \"try{\"\n\t\t\t\t\t+\t\t\"return eval('('+__bundle+')');\"\n\t\t\t\t\t+ \"}catch(e){\"\n\t\t\t\t\t+\t\t\"return e;\"\n\t\t\t\t\t+ \"}\"\n\t\t\t\t),\n\n\t\t\tsyncRequire = function(deps, callback, require){\n\t\t\t\tvar results = [];\n\t\t\t\tarray.forEach(deps, function(mid){\n\t\t\t\t\tvar url = require.toUrl(mid + \".js\");\n\n\t\t\t\t\tfunction load(text){\n\t\t\t\t\t\tvar result = evalBundle(text, checkForLegacyModules, mid, amdValue);\n\t\t\t\t\t\tif(result===amdValue){\n\t\t\t\t\t\t\t// the bundle was an AMD module; re-inject it through the normal AMD path\n\t\t\t\t\t\t\t// we gotta do this since it could be an anonymous module and simply evaluating\n\t\t\t\t\t\t\t// the text here won't provide the loader with the context to know what\n\t\t\t\t\t\t\t// module is being defined()'d. With browser caching, this should be free; further\n\t\t\t\t\t\t\t// this entire code path can be circumvented by using the AMD format to begin with\n\t\t\t\t\t\t\tresults.push(cache[url] = amdValue.result);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(result instanceof Error){\n\t\t\t\t\t\t\t\tconsole.error(\"failed to evaluate i18n bundle; url=\" + url, result);\n\t\t\t\t\t\t\t\tresult = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// nls/<locale>/<bundle-name> indicates not the root.\n\t\t\t\t\t\t\tresults.push(cache[url] = (/nls\\/[^\\/]+\\/[^\\/]+$/.test(url) ? result : {root:result, _v1x:1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cache[url]){\n\t\t\t\t\t\tresults.push(cache[url]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar bundle = require.syncLoadNls(mid);\n\t\t\t\t\t\t// don't need to check for legacy since syncLoadNls returns a module if the module\n\t\t\t\t\t\t// (1) was already loaded, or (2) was in the cache. In case 1, if syncRequire is called\n\t\t\t\t\t\t// from getLocalization --> load, then load will have called checkForLegacyModules() before\n\t\t\t\t\t\t// calling syncRequire; if syncRequire is called from preloadLocalizations, then we\n\t\t\t\t\t\t// don't care about checkForLegacyModules() because that will be done when a particular\n\t\t\t\t\t\t// bundle is actually demanded. In case 2, checkForLegacyModules() is never relevant\n\t\t\t\t\t\t// because cached modules are always v1.7+ built modules.\n\t\t\t\t\t\tif(bundle){\n\t\t\t\t\t\t\tresults.push(bundle);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(!xhr){\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\trequire.getText(url, true, load);\n\t\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\t\tresults.push(cache[url] = {});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\txhr.get({\n\t\t\t\t\t\t\t\t\turl:url,\n\t\t\t\t\t\t\t\t\tsync:true,\n\t\t\t\t\t\t\t\t\tload:load,\n\t\t\t\t\t\t\t\t\terror:function(){\n\t\t\t\t\t\t\t\t\t\tresults.push(cache[url] = {});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcallback && callback.apply(null, results);\n\t\t\t};\n\n\t\tcheckForLegacyModules = function(target){\n\t\t\t// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache\n\t\t\tfor(var result, names = target.split(\"/\"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}\n\t\t\tif(object){\n\t\t\t\tresult = object[names[i]];\n\t\t\t\tif(!result){\n\t\t\t\t\t// fallback for incorrect bundle build of 1.6\n\t\t\t\t\tresult = object[names[i].replace(/-/g,\"_\")];\n\t\t\t\t}\n\t\t\t\tif(result){\n\t\t\t\t\tcache[target] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthisModule.getLocalization = function(moduleName, bundleName, locale){\n\t\t\tvar result,\n\t\t\t\tl10nName = getBundleName(moduleName, bundleName, locale);\n\t\t\tload(\n\t\t\t\tl10nName,\n\n\t\t\t\t// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.\n\t\t\t\t// Since this legacy function does not have the concept of a reference module, resolve with respect to this\n\t\t\t\t// dojo/i18n module, which, itself may have been mapped.\n\t\t\t\t(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),\n\n\t\t\t\tfunction(result_){ result = result_; }\n\t\t\t);\n\t\t\treturn result;\n\t\t};\n\n\t\tif(has(\"dojo-unit-tests\")){\n\t\t\tunitTests.push(function(doh){\n\t\t\t\tdoh.register(\"tests.i18n.unit\", function(t){\n\t\t\t\t\tvar check;\n\n\t\t\t\t\tcheck = evalBundle(\"{prop:1}\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is({prop:1}, check); t.is(undefined, check[1]);\n\n\t\t\t\t\tcheck = evalBundle(\"({prop:1})\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is({prop:1}, check); t.is(undefined, check[1]);\n\n\t\t\t\t\tcheck = evalBundle(\"{'prop-x':1}\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is({'prop-x':1}, check); t.is(undefined, check[1]);\n\n\t\t\t\t\tcheck = evalBundle(\"({'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is({'prop-x':1}, check); t.is(undefined, check[1]);\n\n\t\t\t\t\tcheck = evalBundle(\"define({'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);\n\n\t\t\t\t\tcheck = evalBundle(\"define('some/module', {'prop-x':1})\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);\n\n\t\t\t\t\tcheck = evalBundle(\"this is total nonsense and should throw an error\", checkForLegacyModules, \"nonsense\", amdValue);\n\t\t\t\t\tt.is(check instanceof Error, true);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\treturn lang.mixin(thisModule, {\n\t\tdynamic:true,\n\t\tnormalize:normalize,\n\t\tload:load,\n\t\tcache:cache,\n\t\tgetL10nName: getL10nName\n\t});\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/io-query.js":"define([\"./_base/lang\"], function(lang){\n\n// module:\n//\t\tdojo/io-query\n\nvar backstop = {};\n\nreturn {\n// summary:\n//\t\tThis module defines query string processing functions.\n\n\tobjectToQuery: function objectToQuery(/*Object*/ map){\n\t\t// summary:\n        //\t\ttakes a name/value mapping object and returns a string representing\n        //\t\ta URL-encoded version of that object.\n        // example:\n        //\t\tthis object:\n        //\n        //\t|\t{\n        //\t|\t\tblah: \"blah\",\n        //\t|\t\tmulti: [\n        //\t|\t\t\t\"thud\",\n        //\t|\t\t\t\"thonk\"\n        //\t|\t\t]\n        //\t|\t};\n        //\n        //\t\tyields the following query string:\n        //\n        //\t|\t\"blah=blah&multi=thud&multi=thonk\"\n\n        // FIXME: need to implement encodeAscii!!\n        var enc = encodeURIComponent, pairs = [];\n        for(var name in map){\n            var value = map[name];\n            if(value != backstop[name]){\n                var assign = enc(name) + \"=\";\n                if(lang.isArray(value)){\n                    for(var i = 0, l = value.length; i < l; ++i){\n                        pairs.push(assign + enc(value[i]));\n                    }\n                }else{\n                    pairs.push(assign + enc(value));\n                }\n            }\n        }\n        return pairs.join(\"&\"); // String\n    },\n\n\tqueryToObject: function queryToObject(/*String*/ str){\n        // summary:\n        //\t\tCreate an object representing a de-serialized query section of a\n        //\t\tURL. Query keys with multiple values are returned in an array.\n        //\n        // example:\n        //\t\tThis string:\n        //\n        //\t|\t\t\"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&\"\n        //\n        //\t\tresults in this object structure:\n        //\n        //\t|\t\t{\n        //\t|\t\t\tfoo: [ \"bar\", \"baz\" ],\n        //\t|\t\t\tthinger: \" spaces =blah\",\n        //\t|\t\t\tzonk: \"blarg\"\n        //\t|\t\t}\n        //\n        //\t\tNote that spaces and other urlencoded entities are correctly\n        //\t\thandled.\n\n        // FIXME: should we grab the URL string if we're not passed one?\n        var dec = decodeURIComponent, qp = str.split(\"&\"), ret = {}, name, val;\n        for(var i = 0, l = qp.length, item; i < l; ++i){\n            item = qp[i];\n            if(item.length){\n                var s = item.indexOf(\"=\");\n                if(s < 0){\n                    name = dec(item);\n                    val = \"\";\n                }else{\n                    name = dec(item.slice(0, s));\n                    val  = dec(item.slice(s + 1));\n                }\n                if(typeof ret[name] == \"string\"){ // inline'd type check\n                    ret[name] = [ret[name]];\n                }\n\n                if(lang.isArray(ret[name])){\n                    ret[name].push(val);\n                }else{\n                    ret[name] = val;\n                }\n            }\n        }\n        return ret; // Object\n    }\n};\n});","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/json.js":"define([\"./has\"], function(has){\n\t\"use strict\";\n\tvar hasJSON = typeof JSON != \"undefined\";\n\thas.add(\"json-parse\", hasJSON); // all the parsers work fine\n\t\t// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}');\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tFunctions to parse and serialize JSON\n\n\t\tparse: function(str, strict){\n\t\t\t// summary:\n\t\t\t//\t\tParses a [JSON](http://json.org) string to return a JavaScript object.\n\t\t\t// description:\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\n\t\t\t//\t\tsupport is not available. By default this will evaluate any valid JS expression.\n\t\t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\n\t\t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\n\t\t\t//\t\tparameter, the content passed to this method must come\n\t\t\t//\t\tfrom a trusted source.\n\t\t\t// str:\n\t\t\t//\t\ta string literal of a JSON item, for instance:\n\t\t\t//\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\t\t\t// strict:\n\t\t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\n\t\t\t//\t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\n\t\t\t//\t\twithout native JSON support, setting this to true will run slower.\n\t\t},\n\t\tstringify: function(value, replacer, spacer){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t// description:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t\t\t// value:\n\t\t\t//\t\tA value to be serialized.\n\t\t\t// replacer:\n\t\t\t//\t\tA replacer function that is called for each value and can return a replacement\n\t\t\t// spacer:\n\t\t\t//\t\tA spacer string to be used for pretty printing of JSON\n\t\t\t// example:\n\t\t\t//\t\tsimple serialization of a trivial object\n\t\t\t//\t|\tdefine([\"dojo/json\"], function(JSON){\n\t\t\t// \t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\n\t\t\t//\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t\t}\n\t};\n\t=====*/\n\n\tif(has(\"json-stringify\")){\n\t\treturn JSON;\n\t}else{\n\t\tvar escapeString = function(/*String*/str){\n\t\t\t// summary:\n\t\t\t//\t\tAdds escape sequences for non-visual characters, double quote and\n\t\t\t//\t\tbackslash and surrounds with double quotes to form a valid string\n\t\t\t//\t\tliteral.\n\t\t\treturn ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').\n\t\t\t\treplace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").\n\t\t\t\treplace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\n\t\t};\n\t\treturn {\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\n\t\t\t\tif(strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])*\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)){\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\n\t\t\t\t}\n\t\t\t\treturn eval('(' + str + ')');\n\t\t\t},\n\t\t\tstringify: function(value, replacer, spacer){\n\t\t\t\tvar undef;\n\t\t\t\tif(typeof replacer == \"string\"){\n\t\t\t\t\tspacer = replacer;\n\t\t\t\t\treplacer = null;\n\t\t\t\t}\n\t\t\t\tfunction stringify(it, indent, key){\n\t\t\t\t\tif(replacer){\n\t\t\t\t\t\tit = replacer(key, it);\n\t\t\t\t\t}\n\t\t\t\t\tvar val, objtype = typeof it;\n\t\t\t\t\tif(objtype == \"number\"){\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"boolean\"){\n\t\t\t\t\t\treturn it + \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(it === null){\n\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(typeof it == \"string\"){\n\t\t\t\t\t\treturn escapeString(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\n\t\t\t\t\t\treturn undef; // undefined\n\t\t\t\t\t}\n\t\t\t\t\t// short-circuit for objects that support \"json\" serialization\n\t\t\t\t\t// if they return \"self\" then just pass-through...\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tif(it instanceof Date){\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function(t, prop, plus){\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(it.valueOf() !== it){\n\t\t\t\t\t\t// primitive wrapper, try again unwrapped:\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\n\t\t\t\t\t/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ \n\t\t\t\t\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\n\t\t\t\t\n\t\t\t\t\t// array\n\t\t\t\t\tif(it instanceof Array){\n\t\t\t\t\t\tvar itl = it.length, res = [];\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\n\t\t\t\t\t\t\tvar obj = it[key];\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\tval = \"null\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\t// generic object code path\n\t\t\t\t\tvar output = [];\n\t\t\t\t\tfor(key in it){\n\t\t\t\t\t\tvar keyStr;\n\t\t\t\t\t\tif(it.hasOwnProperty(key)){\n\t\t\t\t\t\t\tif(typeof key == \"number\"){\n\t\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\n\t\t\t\t\t\t\t}else if(typeof key == \"string\"){\n\t\t\t\t\t\t\t\tkeyStr = escapeString(key);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// skip non-string or number keys\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\t// skip non-serializable values\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// At this point, the most non-IE browsers don't get in this branch \n\t\t\t\t\t\t\t// (they have native JSON), so push is definitely the way to\n\t\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\n\t\t\t\t}\n\t\t\t\treturn stringify(value, \"\", \"\");\n\t\t\t}\n\t\t};\n\t}\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/keys.js":"define([\"./_base/kernel\", \"./sniff\"], function(dojo, has){\n\n\t// module:\n\t//\t\tdojo/keys\n\n\treturn dojo.keys = {\n\t\t// summary:\n\t\t//\t\tDefinitions for common key values.  Client code should test keyCode against these named constants,\n\t\t//\t\tas the actual codes can vary by browser.\n\n\t\tBACKSPACE: 8,\n\t\tTAB: 9,\n\t\tCLEAR: 12,\n\t\tENTER: 13,\n\t\tSHIFT: 16,\n\t\tCTRL: 17,\n\t\tALT: 18,\n\t\tMETA: has(\"webkit\") ? 91 : 224,\t\t// the apple key on macs\n\t\tPAUSE: 19,\n\t\tCAPS_LOCK: 20,\n\t\tESCAPE: 27,\n\t\tSPACE: 32,\n\t\tPAGE_UP: 33,\n\t\tPAGE_DOWN: 34,\n\t\tEND: 35,\n\t\tHOME: 36,\n\t\tLEFT_ARROW: 37,\n\t\tUP_ARROW: 38,\n\t\tRIGHT_ARROW: 39,\n\t\tDOWN_ARROW: 40,\n\t\tINSERT: 45,\n\t\tDELETE: 46,\n\t\tHELP: 47,\n\t\tLEFT_WINDOW: 91,\n\t\tRIGHT_WINDOW: 92,\n\t\tSELECT: 93,\n\t\tNUMPAD_0: 96,\n\t\tNUMPAD_1: 97,\n\t\tNUMPAD_2: 98,\n\t\tNUMPAD_3: 99,\n\t\tNUMPAD_4: 100,\n\t\tNUMPAD_5: 101,\n\t\tNUMPAD_6: 102,\n\t\tNUMPAD_7: 103,\n\t\tNUMPAD_8: 104,\n\t\tNUMPAD_9: 105,\n\t\tNUMPAD_MULTIPLY: 106,\n\t\tNUMPAD_PLUS: 107,\n\t\tNUMPAD_ENTER: 108,\n\t\tNUMPAD_MINUS: 109,\n\t\tNUMPAD_PERIOD: 110,\n\t\tNUMPAD_DIVIDE: 111,\n\t\tF1: 112,\n\t\tF2: 113,\n\t\tF3: 114,\n\t\tF4: 115,\n\t\tF5: 116,\n\t\tF6: 117,\n\t\tF7: 118,\n\t\tF8: 119,\n\t\tF9: 120,\n\t\tF10: 121,\n\t\tF11: 122,\n\t\tF12: 123,\n\t\tF13: 124,\n\t\tF14: 125,\n\t\tF15: 126,\n\t\tNUM_LOCK: 144,\n\t\tSCROLL_LOCK: 145,\n\t\tUP_DPAD: 175,\n\t\tDOWN_DPAD: 176,\n\t\tLEFT_DPAD: 177,\n\t\tRIGHT_DPAD: 178,\n\t\t// virtual key mapping\n\t\tcopyKey: has(\"mac\") && !has(\"air\") ? (has(\"safari\") ? 91 : 224 ) : 17\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/loadInit.js":"define([\"./_base/loader\"], function(loader){\n\treturn {\n\t\tdynamic:0,\n\t\tnormalize:function(id){return id;},\n\t\tload:loader.loadInit\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/main.js":"define([\n\t\"./_base/kernel\",\t// kernel.isAsync\n\t\"./has\",\n\t\"require\",\n\t\"./sniff\",\n\t\"./_base/lang\",\n\t\"./_base/array\",\n\t\"./_base/config\",\n\t\"./ready\",\n\t\"./_base/declare\",\n\t\"./_base/connect\",\n\t\"./_base/Deferred\",\n\t\"./_base/json\",\n\t\"./_base/Color\",\n\t\"./has!dojo-firebug?./_firebug/firebug\",\n\t\"./has!host-browser?./_base/browser\",\n\t\"./has!dojo-sync-loader?./_base/loader\"\n], function(kernel, has, require, sniff, lang, array, config, ready){\n\t// module:\n\t//\t\tdojo/main\n\t// summary:\n\t//\t\tThis is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.\n\n\t// the preferred way to load the dojo firebug console is by setting has(\"dojo-firebug\") true in dojoConfig\n\t// the isDebug config switch is for backcompat and will work fine in sync loading mode; it works in\n\t// async mode too, but there's no guarantee when the module is loaded; therefore, if you need a firebug\n\t// console guaranteed at a particular spot in an app, either set config.has[\"dojo-firebug\"] true before\n\t// loading dojo.js or explicitly include dojo/_firebug/firebug in a dependency list.\n\tif(config.isDebug){\n\t\trequire([\"./_firebug/firebug\"]);\n\t}\n\n\t// dojoConfig.require is deprecated; use the loader configuration property deps\n\thas.add(\"dojo-config-require\", 1);\n\tif(has(\"dojo-config-require\")){\n\t\tvar deps= config.require;\n\t\tif(deps){\n\t\t\t// config.require may be dot notation\n\t\t\tdeps= array.map(lang.isArray(deps) ? deps : [deps], function(item){ return item.replace(/\\./g, \"/\"); });\n\t\t\tif(kernel.isAsync){\n\t\t\t\trequire(deps);\n\t\t\t}else{\n\t\t\t\t// this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+\n\t\t\t\t// dojo isn't defined until returning from this module; this is only a problem in sync mode\n\t\t\t\t// since we're in sync mode, we know we've got our loader with its priority ready queue\n\t\t\t\tready(1, function(){require(deps);});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn kernel;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/mouse.js":"define([\"./_base/kernel\", \"./on\", \"./has\", \"./dom\", \"./_base/window\"], function(dojo, on, has, dom, win){\n\n\t// module:\n\t//\t\tdojo/mouse\n\n    has.add(\"dom-quirks\", win.doc && win.doc.compatMode == \"BackCompat\");\n\thas.add(\"events-mouseenter\", win.doc && \"onmouseenter\" in win.doc.createElement(\"div\"));\n\thas.add(\"events-mousewheel\", win.doc && 'onmousewheel' in win.doc);\n\n\tvar mouseButtons;\n\tif((has(\"dom-quirks\") && has(\"ie\")) || !has(\"dom-addeventlistener\")){\n\t\tmouseButtons = {\n\t\t\tLEFT:   1,\n\t\t\tMIDDLE: 4,\n\t\t\tRIGHT:  2,\n\t\t\t// helper functions\n\t\t\tisButton: function(e, button){ return e.button & button; },\n\t\t\tisLeft:   function(e){ return e.button & 1; },\n\t\t\tisMiddle: function(e){ return e.button & 4; },\n\t\t\tisRight:  function(e){ return e.button & 2; }\n\t\t};\n\t}else{\n\t\tmouseButtons = {\n\t\t\tLEFT:   0,\n\t\t\tMIDDLE: 1,\n\t\t\tRIGHT:  2,\n\t\t\t// helper functions\n\t\t\tisButton: function(e, button){ return e.button == button; },\n\t\t\tisLeft:   function(e){ return e.button == 0; },\n\t\t\tisMiddle: function(e){ return e.button == 1; },\n\t\t\tisRight:  function(e){ return e.button == 2; }\n\t\t};\n\t}\n\tdojo.mouseButtons = mouseButtons;\n\n/*=====\n\tdojo.mouseButtons = {\n\t\t// LEFT: Number\n\t\t//\t\tNumeric value of the left mouse button for the platform.\n\t\tLEFT:   0,\n\t\t// MIDDLE: Number\n\t\t//\t\tNumeric value of the middle mouse button for the platform.\n\t\tMIDDLE: 1,\n\t\t// RIGHT: Number\n\t\t//\t\tNumeric value of the right mouse button for the platform.\n\t\tRIGHT:  2,\n\n\t\tisButton: function(e, button){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for a pressed button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\t// button: Number\n\t\t\t//\t\tThe button value (example: dojo.mouseButton.LEFT)\n\t\t\treturn e.button == button; // Boolean\n\t\t},\n\t\tisLeft: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed left button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 0; // Boolean\n\t\t},\n\t\tisMiddle: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed middle button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 1; // Boolean\n\t\t},\n\t\tisRight: function(e){\n\t\t\t// summary:\n\t\t\t//\t\tChecks an event object for the pressed right button\n\t\t\t// e: Event\n\t\t\t//\t\tEvent object to examine\n\t\t\treturn e.button == 2; // Boolean\n\t\t}\n\t};\n=====*/\n\n\tfunction eventHandler(type, selectHandler){\n\t\t// emulation of mouseenter/leave with mouseover/out using descendant checking\n\t\tvar handler = function(node, listener){\n\t\t\treturn on(node, type, function(evt){\n\t\t\t\tif(selectHandler){\n\t\t\t\t\treturn selectHandler(evt, listener);\n\t\t\t\t}\n\t\t\t\tif(!dom.isDescendant(evt.relatedTarget, node)){\n\t\t\t\t\treturn listener.call(this, evt);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\thandler.bubble = function(select){\n\t\t\treturn eventHandler(type, function(evt, listener){\n\t\t\t\t// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector\n\t\t\t\tvar target = select(evt.target);\n\t\t\t\tvar relatedTarget = evt.relatedTarget;\n\t\t\t\tif(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){\n\t\t\t\t\treturn listener.call(target, evt);\n\t\t\t\t} \n\t\t\t});\n\t\t};\n\t\treturn handler;\n\t}\n\tvar wheel;\n\tif(has(\"events-mousewheel\")){\n\t\twheel = 'mousewheel';\n\t}else{ //firefox\n\t\twheel = function(node, listener){\n\t\t\treturn on(node, 'DOMMouseScroll', function(evt){\n\t\t\t\tevt.wheelDelta = -evt.detail;\n\t\t\t\tlistener.call(this, evt);\n\t\t\t});\n\t\t};\n\t}\n\treturn {\n\t\t// summary:\n\t\t//\t\tThis module provide mouse event handling utility functions and exports\n\t\t//\t\tmouseenter and mouseleave event emulation.\n\t\t// example:\n\t\t//\t\tTo use these events, you register a mouseenter like this:\n\t\t//\t\t|\tdefine([\"dojo/on\", dojo/mouse\"], function(on, mouse){\n\t\t//\t\t|\t\ton(targetNode, mouse.enter, function(event){\n\t\t//\t\t|\t\t\tdojo.addClass(targetNode, \"highlighted\");\n\t\t//\t\t|\t\t});\n\t\t//\t\t|\t\ton(targetNode, mouse.leave, function(event){\n\t\t//\t\t|\t\t\tdojo.removeClass(targetNode, \"highlighted\");\n\t\t//\t\t|\t\t});\n\n\t\t_eventHandler: eventHandler,\t\t// for dojo/touch\n\n\t\t// enter: Synthetic Event\n\t\t//\t\tThis is an extension event for the mouseenter that IE provides, emulating the\n\t\t//\t\tbehavior on other browsers.\n\t\tenter: eventHandler(\"mouseover\"),\n\n\t\t// leave: Synthetic Event\n\t\t//\t\tThis is an extension event for the mouseleave that IE provides, emulating the\n\t\t//\t\tbehavior on other browsers.\n\t\tleave: eventHandler(\"mouseout\"),\n\n\t\t// wheel: Normalized Mouse Wheel Event\n\t\t//\t\tThis is an extension event for the mousewheel that non-Mozilla browsers provide,\n\t\t//\t\temulating the behavior on Mozilla based browsers.\n\t\twheel: wheel,\n\n\t\tisLeft: mouseButtons.isLeft,\n\t\t/*=====\n\t\tisLeft: function(){\n\t\t\t// summary:\n\t\t\t//\t\tTest an event object (from a mousedown event) to see if the left button was pressed.\n\t\t},\n\t\t=====*/\n\n\t\tisMiddle: mouseButtons.isMiddle,\n\t\t/*=====\n\t\t isMiddle: function(){\n\t\t\t // summary:\n\t\t\t //\t\tTest an event object (from a mousedown event) to see if the middle button was pressed.\n\t\t },\n\t\t =====*/\n\n\t\tisRight: mouseButtons.isRight\n\t\t/*=====\n\t\t , isRight: function(){\n\t\t\t // summary:\n\t\t\t //\t\tTest an event object (from a mousedown event) to see if the right button was pressed.\n\t\t }\n\t\t =====*/\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/node.js":"define([\"./has\"], function(has){\n\tif(!has(\"host-node\")){\n\t\tthrow new Error(\"node plugin failed to load because environment is not Node.js\");\n\t}\n\n\tvar pathUtil;\n\tif(require.nodeRequire){\n\t\tpathUtil = require.nodeRequire(\"path\");\n\t}else{\n\t\tthrow new Error(\"node plugin failed to load because it cannot find the original Node.js require\");\n\t}\n\n\treturn {\n\t\t// summary:\n\t\t//\t\tThis AMD plugin module allows native Node.js modules to be loaded by AMD modules using the Dojo\n\t\t//\t\tloader. Note that this plugin will not work with AMD loaders other than the Dojo loader.\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/node!fs\"], function(fs){\n\t\t//\t|\t\tvar fileData = fs.readFileSync(\"foo.txt\", \"utf-8\");\n\t\t//\t|\t});\n\n\t\tload: function(/*string*/ id, /*Function*/ require, /*Function*/ load){\n\t\t\t// summary:\n\t\t\t//\t\tStandard AMD plugin interface. See https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins\n\t\t\t//\t\tfor information.\n\n\t\t\tif(!require.nodeRequire){\n\t\t\t\tthrow new Error(\"Cannot find native require function\");\n\t\t\t}\n\n\t\t\tload((function(id, require){\n\t\t\t\tvar oldDefine = define,\n\t\t\t\t\tresult;\n\n\t\t\t\t// Some modules may attempt to detect an AMD loader via define and define.amd.  This can cause issues\n\t\t\t\t// when other CommonJS modules attempt to load them via the standard node require().  If define is\n\t\t\t\t// temporarily moved into another variable, it will prevent modules from detecting AMD in this fashion.\n\t\t\t\tdefine = undefined;\n\n\t\t\t\ttry{\n\t\t\t\t\tresult = require(id);\n\t\t\t\t}finally{\n\t\t\t\t\tdefine = oldDefine;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t})(id, require.nodeRequire));\n\t\t},\n\n\t\tnormalize: function (/**string*/ id, /*Function*/ normalize){\n\t\t\t// summary:\n\t\t\t//\t\tProduces a normalized id to be used by node.  Relative ids are resolved relative to the requesting\n\t\t\t//\t\tmodule's location in the file system and will return an id with path separators appropriate for the\n\t\t\t//\t\tlocal file system.\n\n\t\t\tif(id.charAt(0) === \".\"){\n\t\t\t\t// dirname of the reference module - normalized to match the local file system\n\t\t\t\tvar referenceModuleDirname = require.toUrl(normalize(\".\")).replace(\"/\", pathUtil.sep),\n\t\t\t\t\tsegments = id.split(\"/\");\n\t\t\t\tsegments.unshift(referenceModuleDirname);\n\t\t\t\t// this will produce an absolute path normalized to the semantics of the underlying file system.\n\t\t\t\tid = pathUtil.join.apply(pathUtil, segments);\n\t\t\t}\n\n\t\t\treturn id;\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-data.js":"define([\n\t\"./_base/kernel\", \"./query\", \"./_base/lang\", \"./_base/array\", \"./dom-attr\"\n], function(dojo, query, lang, array, attr){\n\n\t// module:\n\t//\t\tdojo/NodeList-data\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tAdds data() and removeData() methods to NodeList, and returns NodeList constructor.\n\t};\n\t=====*/\n\n\tvar NodeList = query.NodeList;\n\n\tvar dataCache = {}, x = 0, dataattr = \"data-dojo-dataid\",\n\t\tdopid = function(node){\n\t\t\t// summary:\n\t\t\t//\t\tReturn a uniqueish ID for the passed node reference\n\t\t\tvar pid = attr.get(node, dataattr);\n\t\t\tif(!pid){\n\t\t\t\tpid = \"pid\" + (x++);\n\t\t\t\tattr.set(node, dataattr, pid);\n\t\t\t}\n\t\t\treturn pid;\n\t\t}\n\t;\n\n\t//>>excludeStart(\"debugging\", true);\n\t// An alias to the private dataCache for NodeList-data. NEVER USE THIS!\n\t// This private is only exposed for the benefit of unit testing, and is\n\t// removed during the build process.\n\tNodeList._nodeDataCache = dojo._nodeDataCache = dataCache;\n\t//>>excludeEnd(\"debugging\");\n\n\tvar dodata = dojo._nodeData = function(node, key, value){\n\t\t// summary:\n\t\t//\t\tPrivate helper for dojo/NodeList.data for single node data access. Refer to NodeList.data\n\t\t//\t\tdocumentation for more information.\n\t\t//\n\t\t// node: String|DomNode\n\t\t//\t\tThe node to associate data with\n\t\t//\n\t\t// key: Object|String?\n\t\t//\t\tIf an object, act as a setter and iterate over said object setting data items as defined.\n\t\t//\t\tIf a string, and `value` present, set the data for defined `key` to `value`\n\t\t//\t\tIf a string, and `value` absent, act as a getter, returning the data associated with said `key`\n\t\t//\n\t\t// value: Anything?\n\t\t//\t\tThe value to set for said `key`, provided `key` is a string (and not an object)\n\t\t//\n\t\tvar pid = dopid(node), r;\n\t\tif(!dataCache[pid]){ dataCache[pid] = {}; }\n\n\t\t// API discrepency: calling with only a node returns the whole object. $.data throws\n\t\tif(arguments.length == 1){ r = dataCache[pid]; }\n\t\tif(typeof key == \"string\"){\n\t\t\t// either getter or setter, based on `value` presence\n\t\t\tif(arguments.length > 2){\n\t\t\t\tdataCache[pid][key] = value;\n\t\t\t}else{\n\t\t\t\tr = dataCache[pid][key];\n\t\t\t}\n\t\t}else{\n\t\t\t// must be a setter, mix `value` into data hash\n\t\t\t// API discrepency: using object as setter works here\n\t\t\tr = lang.mixin(dataCache[pid], key);\n\t\t}\n\n\t\treturn r; // Object|Anything|Nothing\n\t};\n\n\tvar removeData = dojo._removeNodeData = function(node, key){\n\t\t// summary:\n\t\t//\t\tRemove some data from this node\n\t\t// node: String|DomNode\n\t\t//\t\tThe node reference to remove data from\n\t\t// key: String?\n\t\t//\t\tIf omitted, remove all data in this dataset.\n\t\t//\t\tIf passed, remove only the passed `key` in the associated dataset\n\t\tvar pid = dopid(node);\n\t\tif(dataCache[pid]){\n\t\t\tif(key){\n\t\t\t\tdelete dataCache[pid][key];\n\t\t\t}else{\n\t\t\t\tdelete dataCache[pid];\n\t\t\t}\n\t\t}\n\t};\n\n\tNodeList._gcNodeData = dojo._gcNodeData = function(){\n\t\t// summary:\n\t\t//\t\tsuper expensive: GC all data in the data for nodes that no longer exist in the dom.\n\t\t// description:\n\t\t//\t\tsuper expensive: GC all data in the data for nodes that no longer exist in the dom.\n\t\t//\t\tMUCH safer to do this yourself, manually, on a per-node basis (via `NodeList.removeData()`)\n\t\t//\t\tprovided as a stop-gap for exceptionally large/complex applications with constantly changing\n\t\t//\t\tcontent regions (eg: a dijit/layout/ContentPane with replacing data)\n\t\t//\t\tThere is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData\n\t\t//\t\tprior to destruction.\n\t\tvar livePids = query(\"[\" + dataattr + \"]\").map(dopid);\n\t\tfor(var i in dataCache){\n\t\t\tif(array.indexOf(livePids, i) < 0){ delete dataCache[i]; }\n\t\t}\n\t};\n\n\t// make nodeData and removeNodeData public on dojo/NodeList:\n\tlang.extend(NodeList, {\n\t\tdata: NodeList._adaptWithCondition(dodata, function(a){\n\t\t\treturn a.length === 0 || a.length == 1 && (typeof a[0] == \"string\");\n\t\t}),\n\t\tremoveData: NodeList._adaptAsForEach(removeData)\n\t});\n\n\t/*=====\n\t lang.extend(NodeList, {\n\t\t data: function(key, value){\n\t\t\t// summary:\n\t\t\t//\t\tstash or get some arbitrary data on/from these nodes.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tStash or get some arbitrary data on/from these nodes. This private _data function is\n\t\t\t//\t\texposed publicly on `dojo/NodeList`, eg: as the result of a `dojo/query` call.\n\t\t\t//\t\tDIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS\n\t\t\t//\t\treturned. EVEN WHEN THE LIST IS length == 1.\n\t\t\t//\n\t\t\t//\t\tA single-node version of this function is provided as `dojo._nodeData`, which follows\n\t\t\t//\t\tthe same signature, though expects a String ID or DomNode reference in the first\n\t\t\t//\t\tposition, before key/value arguments.\n\t\t\t//\n\t\t\t// node: String|DomNode\n\t\t\t//\t\tThe node to associate data with\n\t\t\t//\n\t\t\t// key: Object|String?\n\t\t\t//\t\tIf an object, act as a setter and iterate over said object setting data items as defined.\n\t\t\t//\t\tIf a string, and `value` present, set the data for defined `key` to `value`\n\t\t\t//\t\tIf a string, and `value` absent, act as a getter, returning the data associated with said `key`\n\t\t\t//\n\t\t\t// value: Anything?\n\t\t\t//\t\tThe value to set for said `key`, provided `key` is a string (and not an object)\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tSet a key `bar` to some data, then retrieve it.\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\n\t\t\t//\t|\t\tquery(\".foo\").data(\"bar\", \"touched\");\n\t\t\t//\t|\t\tvar touched = query(\".foo\").data(\"bar\");\n\t\t\t//\t|\t\tif(touched[0] == \"touched\"){ alert('win'); }\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tGet all the data items for a given node.\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\n\t\t\t//\t|\t\tvar list = query(\".foo\").data();\n\t\t\t//\t|\t\tvar first = list[0];\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tSet the data to a complex hash. Overwrites existing keys with new value\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-data\"], function(query){\n\t\t\t//\t|\t\tquery(\".foo\").data({ bar:\"baz\", foo:\"bar\" });\n\t\t\t//\t\tThen get some random key:\n\t\t\t//\t|\t\tquery(\".foo\").data(\"foo\"); // returns [`bar`]\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// returns: Object|Anything|Nothing\n\t\t\t//\t\tWhen used as a setter via `dojo/NodeList`, a NodeList instance is returned\n\t\t\t//\t\tfor further chaining. When used as a getter via `dojo/NodeList` an ARRAY\n\t\t\t//\t\tof items is returned. The items in the array correspond to the elements\n\t\t\t//\t\tin the original list. This is true even when the list length is 1, eg:\n\t\t\t//\t\twhen looking up a node by ID (#foo)\n\t\t },\n\n\t\t removeData: function(key){\n\t\t\t// summary:\n\t\t\t//\t\tRemove the data associated with these nodes.\n\t\t\t// key: String?\n\t\t\t//\t\tIf omitted, clean all data for this node.\n\t\t\t//\t\tIf passed, remove the data item found at `key`\n\t\t }\n\t });\n\t =====*/\n\n// TODO: this is the basic implementation of adaptWithConditionAndWhenMappedConsiderLength, for lack of a better API name\n// it conflicts with the the `dojo/NodeList` way: always always return an arrayLike thinger. Consider for 2.0:\n//\n//\tNodeList.prototype.data = function(key, value){\n//\t\tvar a = arguments, r;\n//\t\tif(a.length === 0 || a.length == 1 && (typeof a[0] == \"string\")){\n//\t\t\tr = this.map(function(node){\n//\t\t\t\treturn d._data(node, key);\n//\t\t\t});\n//\t\t\tif(r.length == 1){ r = r[0]; } // the offending line, and the diff on adaptWithCondition\n//\t\t}else{\n//\t\t\tr = this.forEach(function(node){\n//\t\t\t\td._data(node, key, value);\n//\t\t\t});\n//\t\t}\n//\t\treturn r; // NodeList|Array|SingleItem\n//\t};\n\n\treturn NodeList;\n\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-dom.js":"define([\"./_base/kernel\", \"./query\", \"./_base/array\", \"./_base/lang\", \"./dom-class\", \"./dom-construct\", \"./dom-geometry\", \"./dom-attr\", \"./dom-style\"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle){\n\n\t// module:\n\t//\t\tdojo/NodeList-dom.js\n\n\t/*=====\n\t return function(){\n\t\t // summary:\n\t\t //\t\tAdds DOM related methods to NodeList, and returns NodeList constructor.\n\t };\n\t =====*/\n\n\tvar magicGuard = function(a){\n\t\t// summary:\n\t\t//\t\tthe guard function for dojo/dom-attr() and dojo/dom-style()\n\t\treturn a.length == 1 && (typeof a[0] == \"string\"); // inline'd type check\n\t};\n\n\tvar orphan = function(node){\n\t\t// summary:\n\t\t//\t\tfunction to orphan nodes\n\t\tvar p = node.parentNode;\n\t\tif(p){\n\t\t\tp.removeChild(node);\n\t\t}\n\t};\n\t// FIXME: should we move orphan() to dojo/_base/html?\n\n\tvar NodeList = query.NodeList,\n\t\tawc = NodeList._adaptWithCondition,\n\t\taafe = NodeList._adaptAsForEach,\n\t\taam = NodeList._adaptAsMap;\n\n\tfunction getSet(module){\n\t\treturn function(node, name, value){\n\t\t\tif(arguments.length == 2){\n\t\t\t\treturn module[typeof name == \"string\" ? \"get\" : \"set\"](node, name);\n\t\t\t}\n\t\t\t// setter\n\t\t\treturn module.set(node, name, value);\n\t\t};\n\t}\n\n\tlang.extend(NodeList, {\n\t\t_normalize: function(/*String||Element||Object||NodeList*/content, /*DOMNode?*/refNode){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes data to an array of items to insert.\n\t\t\t// description:\n\t\t\t//\t\tIf content is an object, it can have special properties \"template\" and\n\t\t\t//\t\t\"parse\". If \"template\" is defined, then the template value is run through\n\t\t\t//\t\tdojo/string.substitute (if dojo/string.substitute() has been required elsewhere),\n\t\t\t//\t\tor if templateFunc is a function on the content, that function will be used to\n\t\t\t//\t\ttransform the template into a final string to be used for for passing to dojo/dom-construct.toDom().\n\t\t\t//\t\tIf content.parse is true, then it is remembered for later, for when the content\n\t\t\t//\t\tnodes are inserted into the DOM. At that point, the nodes will be parsed for widgets\n\t\t\t//\t\t(if dojo/parser has been required elsewhere).\n\n\t\t\t//Wanted to just use a DocumentFragment, but for the array/NodeList\n\t\t\t//case that meant using cloneNode, but we may not want that.\n\t\t\t//Cloning should only happen if the node operations span\n\t\t\t//multiple refNodes. Also, need a real array, not a NodeList from the\n\t\t\t//DOM since the node movements could change those NodeLists.\n\n\t\t\tvar parse = content.parse === true;\n\n\t\t\t//Do we have an object that needs to be run through a template?\n\t\t\tif(typeof content.template == \"string\"){\n\t\t\t\tvar templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);\n\t\t\t\tcontent = templateFunc ? templateFunc(content.template, content) : content;\n\t\t\t}\n\n\t\t\tvar type = (typeof content);\n\t\t\tif(type == \"string\" || type == \"number\"){\n\t\t\t\tcontent = domCtr.toDom(content, (refNode && refNode.ownerDocument));\n\t\t\t\tif(content.nodeType == 11){\n\t\t\t\t\t//DocumentFragment. It cannot handle cloneNode calls, so pull out the children.\n\t\t\t\t\tcontent = lang._toArray(content.childNodes);\n\t\t\t\t}else{\n\t\t\t\t\tcontent = [content];\n\t\t\t\t}\n\t\t\t}else if(!lang.isArrayLike(content)){\n\t\t\t\tcontent = [content];\n\t\t\t}else if(!lang.isArray(content)){\n\t\t\t\t//To get to this point, content is array-like, but\n\t\t\t\t//not an array, which likely means a DOM NodeList. Convert it now.\n\t\t\t\tcontent = lang._toArray(content);\n\t\t\t}\n\n\t\t\t//Pass around the parse info\n\t\t\tif(parse){\n\t\t\t\tcontent._runParse = true;\n\t\t\t}\n\t\t\treturn content; //Array\n\t\t},\n\n\t\t_cloneNode: function(/*DOMNode*/ node){\n\t\t\t// summary:\n\t\t\t//\t\tprivate utility to clone a node. Not very interesting in the vanilla\n\t\t\t//\t\tdojo/NodeList case, but delegates could do interesting things like\n\t\t\t//\t\tclone event handlers if that is derivable from the node.\n\t\t\treturn node.cloneNode(true);\n\t\t},\n\n\t\t_place: function(/*Array*/ary, /*DOMNode*/refNode, /*String*/position, /*Boolean*/useClone){\n\t\t\t// summary:\n\t\t\t//\t\tprivate utility to handle placing an array of nodes relative to another node.\n\t\t\t// description:\n\t\t\t//\t\tAllows for cloning the nodes in the array, and for\n\t\t\t//\t\toptionally parsing widgets, if ary._runParse is true.\n\n\t\t\t//Avoid a disallowed operation if trying to do an innerHTML on a non-element node.\n\t\t\tif(refNode.nodeType != 1 && position == \"only\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar rNode = refNode, tempNode;\n\n\t\t\t//Always cycle backwards in case the array is really a\n\t\t\t//DOM NodeList and the DOM operations take it out of the live collection.\n\t\t\tvar length = ary.length;\n\t\t\tfor(var i = length - 1; i >= 0; i--){\n\t\t\t\tvar node = (useClone ? this._cloneNode(ary[i]) : ary[i]);\n\n\t\t\t\t//If need widget parsing, use a temp node, instead of waiting after inserting into\n\t\t\t\t//real DOM because we need to start widget parsing at one node up from current node,\n\t\t\t\t//which could cause some already parsed widgets to be parsed again.\n\t\t\t\tif(ary._runParse && dojo.parser && dojo.parser.parse){\n\t\t\t\t\tif(!tempNode){\n\t\t\t\t\t\ttempNode = rNode.ownerDocument.createElement(\"div\");\n\t\t\t\t\t}\n\t\t\t\t\ttempNode.appendChild(node);\n\t\t\t\t\tdojo.parser.parse(tempNode);\n\t\t\t\t\tnode = tempNode.firstChild;\n\t\t\t\t\twhile(tempNode.firstChild){\n\t\t\t\t\t\ttempNode.removeChild(tempNode.firstChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(i == length - 1){\n\t\t\t\t\tdomCtr.place(node, rNode, position);\n\t\t\t\t}else{\n\t\t\t\t\trNode.parentNode.insertBefore(node, rNode);\n\t\t\t\t}\n\t\t\t\trNode = node;\n\t\t\t}\n\t\t},\n\n\n\t\tposition: aam(domGeom.position),\n\t\t/*=====\n\t\tposition: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns border-box objects (x/y/w/h) of all elements in a node list\n\t\t\t//\t\tas an Array (*not* a NodeList). Acts like `dojo/dom-geometry-position`, though\n\t\t\t//\t\tassumes the node passed is each node in this list.\n\n\t\t\treturn dojo.map(this, dojo.position); // Array\n\t\t},\n\t\t=====*/\n\n\t\tattr: awc(getSet(domAttr), magicGuard),\n\t\t/*=====\n\t\tattr: function(property, value){\n\t\t\t// summary:\n\t\t\t//\t\tgets or sets the DOM attribute for every element in the\n\t\t\t//\t\tNodeList. See also `dojo/dom-attr`\n\t\t\t// property: String\n\t\t\t//\t\tthe attribute to get/set\n\t\t\t// value: String?\n\t\t\t//\t\toptional. The value to set the property to\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is an array of attribute values\n\t\t\t//\t\tIf a value is passed, the return is this NodeList\n\t\t\t// example:\n\t\t\t//\t\tMake all nodes with a particular class focusable:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"], function(query){\n\t\t\t//\t|\t\tquery(\".focusable\").attr(\"tabIndex\", -1);\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tDisable a group of buttons:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"], function(query){\n\t\t\t//\t|\t\tquery(\"button.group\").attr(\"disabled\", true);\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tinnerHTML can be assigned or retrieved as well:\n\t\t\t//\t|\t// get the innerHTML (as an array) for each list item\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"], function(query){\n\t\t\t//\t|\t\tvar ih = query(\"li.replaceable\").attr(\"innerHTML\");\n\t\t\t//\t|\t});\n\t\t\treturn; // dojo/NodeList|Array\n\t\t},\n\t\t=====*/\n\n\t\tstyle: awc(getSet(domStyle), magicGuard),\n\t\t/*=====\n\t\tstyle: function(property, value){\n\t\t\t// summary:\n\t\t\t//\t\tgets or sets the CSS property for every element in the NodeList\n\t\t\t// property: String\n\t\t\t//\t\tthe CSS property to get/set, in JavaScript notation\n\t\t\t//\t\t(\"lineHieght\" instead of \"line-height\")\n\t\t\t// value: String?\n\t\t\t//\t\toptional. The value to set the property to\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is an array of strings.\n\t\t\t//\t\tIf a value is passed, the return is this NodeList\n\t\t\treturn; // dojo/NodeList\n\t\t\treturn; // Array\n\t\t},\n\t\t=====*/\n\n\t\taddClass: aafe(domCls.add),\n\t\t/*=====\n\t\taddClass: function(className){\n\t\t\t// summary:\n\t\t\t//\t\tadds the specified class to every node in the list\n\t\t\t// className: String|Array\n\t\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\treturn; // dojo/NodeList\n\t\t},\n\t\t=====*/\n\n\t\tremoveClass: aafe(domCls.remove),\n\t\t/*=====\n\t\tremoveClass: function(className){\n\t\t\t// summary:\n\t\t\t//\t\tremoves the specified class from every node in the list\n\t\t\t// className: String|Array?\n\t\t\t//\t\tAn optional String class name to remove, or several space-separated\n\t\t\t//\t\tclass names, or an array of class names. If omitted, all class names\n\t\t\t//\t\twill be deleted.\n\t\t\t// returns:\n\t\t\t//\t\tthis list\n\t\t\treturn; // dojo/NodeList\n\t\t},\n\t\t=====*/\n\n\t\ttoggleClass: aafe(domCls.toggle),\n\t\t/*=====\n\t\ttoggleClass: function(className, condition){\n\t\t\t// summary:\n\t\t\t//\t\tAdds a class to node if not present, or removes if present.\n\t\t\t//\t\tPass a boolean condition if you want to explicitly add or remove.\n\t\t\t// condition: Boolean?\n\t\t\t//\t\tIf passed, true means to add the class, false means to remove.\n\t\t\t// className: String\n\t\t\t//\t\tthe CSS class to add\n\t\t\treturn; // dojo/NodeList\n\t\t},\n\t\t=====*/\n\n\t\treplaceClass: aafe(domCls.replace),\n\t\t/*=====\n\t\treplaceClass: function(addClassStr, removeClassStr){\n\t\t\t// summary:\n\t\t\t//\t\tReplaces one or more classes on a node if not present.\n\t\t\t//\t\tOperates more quickly than calling `removeClass()` and `addClass()`\n\t\t\t// addClassStr: String|Array\n\t\t\t//\t\tA String class name to add, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\t// removeClassStr: String|Array?\n\t\t\t//\t\tA String class name to remove, or several space-separated class names,\n\t\t\t//\t\tor an array of class names.\n\t\t\treturn; // dojo/NodeList\n\t\t },\n\t\t =====*/\n\n\t\tempty: aafe(domCtr.empty),\n\t\t/*=====\n\t\tempty: function(){\n\t\t\t// summary:\n\t\t\t//\t\tclears all content from each node in the list. Effectively\n\t\t\t//\t\tequivalent to removing all child nodes from every item in\n\t\t\t//\t\tthe list.\n\t\t\treturn this.forEach(\"item.innerHTML='';\"); // dojo/NodeList\n\t\t\t// FIXME: should we be checking for and/or disposing of widgets below these nodes?\n\t\t},\n\t\t=====*/\n\n\t\tremoveAttr: aafe(domAttr.remove),\n\t\t/*=====\n\t\t removeAttr: function(name){\n\t\t\t// summary:\n\t\t\t//\t\tRemoves an attribute from each node in the list.\n\t\t\t// name: String\n\t\t\t//\t\tthe name of the attribute to remove\n\t\t\treturn;\t\t// dojo/NodeList\n\t\t},\n\t\t=====*/\n\n\t\tmarginBox: aam(domGeom.getMarginBox),\n\t\t/*=====\n\t\tmarginBox: function(){\n\t\t\t// summary:\n\t\t\t//\t\tReturns margin-box size of nodes\n\t\t \treturn; // dojo/NodeList\n\t\t },\n\t\t =====*/\n\n\t\t// FIXME: connectPublisher()? connectRunOnce()?\n\n\t\t/*\n\t\tdestroy: function(){\n\t\t\t// summary:\n\t\t\t//\t\tdestroys every item in the list.\n\t\t\tthis.forEach(d.destroy);\n\t\t\t// FIXME: should we be checking for and/or disposing of widgets below these nodes?\n\t\t},\n\t\t*/\n\n\t\tplace: function(/*String||Node*/ queryOrNode, /*String*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tplaces elements of this node list relative to the first element matched\n\t\t\t//\t\tby queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`\n\t\t\t// queryOrNode:\n\t\t\t//\t\tmay be a string representing any valid CSS3 selector or a DOM node.\n\t\t\t//\t\tIn the selector case, only the first matching element will be used\n\t\t\t//\t\tfor relative positioning.\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\n\t\t\t//\t\t-\t\"last\" (default)\n\t\t\t//\t\t-\t\"first\"\n\t\t\t//\t\t-\t\"before\"\n\t\t\t//\t\t-\t\"after\"\n\t\t\t//\t\t-\t\"only\"\n\t\t\t//\t\t-\t\"replace\"\n\t\t\t//\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\tvar item = query(queryOrNode)[0];\n\t\t\treturn this.forEach(function(node){ domCtr.place(node, item, position); }); // dojo/NodeList\n\t\t},\n\n\t\torphan: function(/*String?*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\tremoves elements in this list that match the filter\n\t\t\t//\t\tfrom their parents and returns them as a new NodeList.\n\t\t\t// filter:\n\t\t\t//\t\tCSS selector like \".foo\" or \"div > span\"\n\t\t\t// returns:\n\t\t\t//\t\tNodeList containing the orphaned elements\n\t\t\treturn (filter ? query._filterResult(this, filter) : this).forEach(orphan); // dojo/NodeList\n\t\t},\n\n\t\tadopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tplaces any/all elements in queryOrListOrNode at a\n\t\t\t//\t\tposition relative to the first element in this list.\n\t\t\t//\t\tReturns a dojo/NodeList of the adopted elements.\n\t\t\t// queryOrListOrNode:\n\t\t\t//\t\ta DOM node or a query string or a query result.\n\t\t\t//\t\tRepresents the nodes to be adopted relative to the\n\t\t\t//\t\tfirst element of this NodeList.\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\n\t\t\t//\t\t-\t\"last\" (default)\n\t\t\t//\t\t-\t\"first\"\n\t\t\t//\t\t-\t\"before\"\n\t\t\t//\t\t-\t\"after\"\n\t\t\t//\t\t-\t\"only\"\n\t\t\t//\t\t-\t\"replace\"\n\t\t\t//\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\treturn query(queryOrListOrNode).place(this[0], position)._stash(this);\t// dojo/NodeList\n\t\t},\n\n\t\t// FIXME: do we need this?\n\t\tquery: function(/*String*/ queryStr){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new list whose members match the passed query,\n\t\t\t//\t\tassuming elements of the current NodeList as the root for\n\t\t\t//\t\teach search.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\">\n\t\t\t//\t|\t\t<p>\n\t\t\t//\t|\t\t\tbacon is tasty, <span>dontcha think?</span>\n\t\t\t//\t|\t\t</p>\n\t\t\t//\t|\t</div>\n\t\t\t//\t|\t<div id=\"bar\">\n\t\t\t//\t|\t\t<p>great comedians may not be funny <span>in person</span></p>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tIf we are presented with the following definition for a NodeList:\n\t\t\t//\t|\trequire([\"dojo/dom\", \"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(dom, query){\n\t\t\t//\t|\t\tvar l = new NodeList(dom.byId(\"foo\"), dom.byId(\"bar\"));\n\t\t\t//\t\tit's possible to find all span elements under paragraphs\n\t\t\t//\t\tcontained by these elements with this sub-query:\n\t\t\t//\t|\t\tvar spans = l.query(\"p span\");\n\t\t\t//\t|\t});\n\n\t\t\t// FIXME: probably slow\n\t\t\tif(!queryStr){ return this; }\n\t\t\tvar ret = new NodeList;\n\t\t\tthis.map(function(node){\n\t\t\t\t// FIXME: why would we ever get undefined here?\n\t\t\t\tquery(queryStr, node).forEach(function(subNode){\n\t\t\t\t\tif(subNode !== undefined){\n\t\t\t\t\t\tret.push(subNode);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn ret._stash(this);\t// dojo/NodeList\n\t\t},\n\n\t\tfilter: function(/*String|Function*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\t\"masks\" the built-in javascript filter() method (supported\n\t\t\t//\t\tin Dojo via `dojo.filter`) to support passing a simple\n\t\t\t//\t\tstring filter in addition to supporting filtering function\n\t\t\t//\t\tobjects.\n\t\t\t// filter:\n\t\t\t//\t\tIf a string, a CSS rule like \".thinger\" or \"div > span\".\n\t\t\t// example:\n\t\t\t//\t\t\"regular\" JS filter syntax as exposed in dojo.filter:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"*\").filter(function(item){\n\t\t\t//\t|\t\t\t// highlight every paragraph\n\t\t\t//\t|\t\t\treturn (item.nodeName == \"p\");\n\t\t\t//\t|\t\t}).style(\"backgroundColor\", \"yellow\");\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\tthe same filtering using a CSS selector\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"*\").filter(\"p\").styles(\"backgroundColor\", \"yellow\");\n\t\t\t//\t|\t});\n\t\t\tvar a = arguments, items = this, start = 0;\n\t\t\tif(typeof filter == \"string\"){ // inline'd type check\n\t\t\t\titems = query._filterResult(this, a[0]);\n\t\t\t\tif(a.length == 1){\n\t\t\t\t\t// if we only got a string query, pass back the filtered results\n\t\t\t\t\treturn items._stash(this); // dojo/NodeList\n\t\t\t\t}\n\t\t\t\t// if we got a callback, run it over the filtered items\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t\treturn this._wrap(array.filter(items, a[start], a[start + 1]), this);\t// dojo/NodeList\n\t\t},\n\n\t\t/*\n\t\t// FIXME: should this be \"copyTo\" and include parenting info?\n\t\tclone: function(){\n\t\t\t// summary:\n\t\t\t//\t\tcreates node clones of each element of this list\n\t\t\t//\t\tand returns a new list containing the clones\n\t\t},\n\t\t*/\n\n\t\taddContent: function(/*String||DomNode||Object||dojo/NodeList*/ content, /*String||Integer?*/ position){\n\t\t\t// summary:\n\t\t\t//\t\tadd a node, NodeList or some HTML as a string to every item in the\n\t\t\t//\t\tlist.  Returns the original list.\n\t\t\t// description:\n\t\t\t//\t\ta copy of the HTML content is added to each item in the\n\t\t\t//\t\tlist, with an optional position argument. If no position\n\t\t\t//\t\targument is provided, the content is appended to the end of\n\t\t\t//\t\teach item.\n\t\t\t// content:\n\t\t\t//\t\tDOM node, HTML in string format, a NodeList or an Object. If a DOM node or\n\t\t\t//\t\tNodeList, the content will be cloned if the current NodeList has more than one\n\t\t\t//\t\telement. Only the DOM nodes are cloned, no event handlers. If it is an Object,\n\t\t\t//\t\tit should be an object with at \"template\" String property that has the HTML string\n\t\t\t//\t\tto insert. If dojo.string has already been dojo.required, then dojo.string.substitute\n\t\t\t//\t\twill be used on the \"template\" to generate the final HTML string. Other allowed\n\t\t\t//\t\tproperties on the object are: \"parse\" if the HTML\n\t\t\t//\t\tstring should be parsed for widgets (dojo.require(\"dojo.parser\") to get that\n\t\t\t//\t\toption to work), and \"templateFunc\" if a template function besides dojo.string.substitute\n\t\t\t//\t\tshould be used to transform the \"template\".\n\t\t\t// position:\n\t\t\t//\t\tcan be one of:\n\t\t\t//\n\t\t\t//\t\t-\t\"last\"||\"end\" (default)\n\t\t\t//\t\t-\t\"first||\"start\"\n\t\t\t//\t\t-\t\"before\"\n\t\t\t//\t\t-\t\"after\"\n\t\t\t//\t\t-\t\"replace\" (replaces nodes in this NodeList with new content)\n\t\t\t//\t\t-\t\"only\" (removes other children of the nodes so new content is the only child)\n\t\t\t//\n\t\t\t//\t\tor an offset in the childNodes property\n\t\t\t// example:\n\t\t\t//\t\tappends content to the end if the position is omitted\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"h3 > p\").addContent(\"hey there!\");\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tadd something to the front of each element that has a\n\t\t\t//\t\t\"thinger\" property:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"[thinger]\").addContent(\"...\", \"first\");\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tadds a header before each element of the list\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".note\").addContent(\"<h4>NOTE:</h4>\", \"before\");\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tadd a clone of a DOM node to the end of every element in\n\t\t\t//\t\tthe list, removing it from its existing parent.\n\t\t\t//\t|\trequire([\"dojo/dom\", \"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(dom, query){\n\t\t\t//\t|\t\tquery(\".note\").addContent(dom.byId(\"foo\"));\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tAppend nodes from a templatized string.\n\t\t\t//\t|\trequire([\"dojo/string\", \"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(string, query){\n\t\t\t//\t|\t\tquery(\".note\").addContent({\n\t\t\t//\t|\t\t\ttemplate: '<b>${id}: </b><span>${name}</span>',\n\t\t\t//\t|\t\t\tid: \"user332\",\n\t\t\t//\t|\t\t\tname: \"Mr. Anderson\"\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tAppend nodes from a templatized string that also has widgets parsed.\n\t\t\t//\t|\trequire([\"dojo/string\", \"dojo/parser\", \"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(string, parser, query){\n\t\t\t//\t|\t\tvar notes = query(\".note\").addContent({\n\t\t\t//\t|\t\t\ttemplate: '<button dojoType=\"dijit/form/Button\">${text}</button>',\n\t\t\t//\t|\t\t\tparse: true,\n\t\t\t//\t|\t\t\ttext: \"Send\"\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t});\n\t\t\tcontent = this._normalize(content, this[0]);\n\t\t\tfor(var i = 0, node; (node = this[i]); i++){\n\t\t\t\tif(content.length){\n\t\t\t\t\tthis._place(content, node, position, i > 0);\n\t\t\t\t}else{\n\t\t\t\t\t// if it is an empty array, we empty the target node\n\t\t\t\t\tdomCtr.empty(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t}\n\t});\n\n\treturn NodeList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-fx.js":"define([\"./query\", \"./_base/lang\", \"./aspect\", \"./_base/fx\", \"./fx\"],\nfunction(query, lang, aspect, baseFx, coreFx){\n\n// module:\n//\t\tdojo/NodeList-fx\n\n/*=====\nreturn function(){\n\t// summary:\n\t//\t\tAdds dojo.fx animation support to dojo.query() by extending the NodeList class\n\t//\t\twith additional FX functions.  NodeList is the array-like object used to hold query results.\n};\n=====*/\n\nvar NodeList = query.NodeList;\n\nlang.extend(NodeList, {\n\t_anim: function(obj, method, args){\n\t\targs = args||{};\n\t\tvar a = coreFx.combine(\n\t\t\tthis.map(function(item){\n\t\t\t\tvar tmpArgs = { node: item };\n\t\t\t\tlang.mixin(tmpArgs, args);\n\t\t\t\treturn obj[method](tmpArgs);\n\t\t\t})\n\t\t);\n\t\treturn args.auto ? a.play() && this : a; // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\twipeIn: function(args){\n\t\t// summary:\n\t\t//\t\twipe in all elements of this NodeList via `dojo/fx.wipeIn()`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t\tFade in all tables with class \"blah\":\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\"table.blah\").wipeIn().play();\n\t\t//\t\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t\tUtilizing `auto` to get the NodeList back:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\".titles\").wipeIn({ auto:true }).onclick(someFunction);\n\t\t//\t\t|\t});\n\t\t//\n\t\treturn this._anim(coreFx, \"wipeIn\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\twipeOut: function(args){\n\t\t// summary:\n\t\t//\t\twipe out all elements of this NodeList via `dojo/fx.wipeOut()`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t\tWipe out all tables with class \"blah\":\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\"table.blah\").wipeOut().play();\n\t\t//\t\t|\t});\t\t\n\t\treturn this._anim(coreFx, \"wipeOut\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\tslideTo: function(args){\n\t\t// summary:\n\t\t//\t\tslide all elements of the node list to the specified place via `dojo/fx.slideTo()`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t\t|\tMove all tables with class \"blah\" to 300/300:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\"table.blah\").slideTo({\n\t\t//\t\t|\t\t\tleft: 40,\n\t\t//\t\t|\t\t\ttop: 50\n\t\t//\t\t|\t\t}).play();\n\t\t//\t\t|\t});\n\t\treturn this._anim(coreFx, \"slideTo\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\n\tfadeIn: function(args){\n\t\t// summary:\n\t\t//\t\tfade in all elements of this NodeList via `dojo.fadeIn`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t\tFade in all tables with class \"blah\":\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\"table.blah\").fadeIn().play();\n\t\t//\t\t|\t});\n\t\treturn this._anim(baseFx, \"fadeIn\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\tfadeOut: function(args){\n\t\t// summary:\n\t\t//\t\tfade out all elements of this NodeList via `dojo.fadeOut`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t\tFade out all elements with class \"zork\":\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\".zork\").fadeOut().play();\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tFade them on a delay and do something at the end:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/aspect\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query, aspect){\n\t\t//\t\t|\t\tvar fo = query(\".zork\").fadeOut();\n\t\t//\t\t|\t\taspect.after(fo, \"onEnd\", function(){ /*...*/ }, true);\n\t\t//\t\t|\t\tfo.play();\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tUsing `auto`:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\"li\").fadeOut({ auto:true }).filter(filterFn).forEach(doit);\n\t\t//\t\t|\t});\n\t\t//\n\t\treturn this._anim(baseFx, \"fadeOut\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\tanimateProperty: function(args){\n\t\t// summary:\n\t\t//\t\tAnimate all elements of this NodeList across the properties specified.\n\t\t//\t\tsyntax identical to `dojo.animateProperty`\n\t\t//\n\t\t// args: Object?\n\t\t//\t\tAdditional dojo/_base/fx.Animation arguments to mix into this set with the addition of\n\t\t//\t\tan `auto` parameter.\n\t\t//\n\t\t// returns: dojo/_base/fx.Animation|dojo/NodeList\n\t\t//\t\tA special args member `auto` can be passed to automatically play the animation.\n\t\t//\t\tIf args.auto is present, the original dojo/NodeList will be returned for further\n\t\t//\t\tchaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed\n\t\t//\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".zork\").animateProperty({\n\t\t//\t|\t\t\tduration: 500,\n\t\t//\t|\t\t\tproperties: {\n\t\t//\t|\t\t\t\tcolor:\t\t{ start: \"black\", end: \"white\" },\n\t\t//\t|\t\t\t\tleft:\t\t{ end: 300 }\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t}).play();\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".grue\").animateProperty({\n\t\t//\t|\t\t\tauto:true,\n\t\t//\t|\t\t\tproperties: {\n\t\t//\t|\t\t\t\theight:240\n\t\t//\t|\t\t\t}\n\t\t//\t|\t\t}).onclick(handler);\n\t\t//\t|\t});\n\t\treturn this._anim(baseFx, \"animateProperty\", args); // dojo/_base/fx.Animation|dojo/NodeList\n\t},\n\n\tanim: function( /*Object*/\t\t\tproperties,\n\t\t\t\t\t/*Integer?*/\t\tduration,\n\t\t\t\t\t/*Function?*/\t\teasing,\n\t\t\t\t\t/*Function?*/\t\tonEnd,\n\t\t\t\t\t/*Integer?*/\t\tdelay){\n\t\t// summary:\n\t\t//\t\tAnimate one or more CSS properties for all nodes in this list.\n\t\t//\t\tThe returned animation object will already be playing when it\n\t\t//\t\tis returned. See the docs for `dojo.anim` for full details.\n\t\t// properties: Object\n\t\t//\t\tthe properties to animate. does NOT support the `auto` parameter like other\n\t\t//\t\tNodeList-fx methods.\n\t\t// duration: Integer?\n\t\t//\t\tOptional. The time to run the animations for\n\t\t// easing: Function?\n\t\t//\t\tOptional. The easing function to use.\n\t\t// onEnd: Function?\n\t\t//\t\tA function to be called when the animation ends\n\t\t// delay:\n\t\t//\t\thow long to delay playing the returned animation\n\t\t// example:\n\t\t//\t\tAnother way to fade out:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".thinger\").anim({ opacity: 0 });\n\t\t//\t|\t});\n\t\t// example:\n\t\t//\t\tanimate all elements with the \"thigner\" class to a width of 500\n\t\t//\t\tpixels over half a second\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-fx\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".thinger\").anim({ width: 500 }, 700);\n\t\t//\t|\t});\n\t\tvar canim = coreFx.combine(\n\t\t\tthis.map(function(item){\n\t\t\t\treturn baseFx.animateProperty({\n\t\t\t\t\tnode: item,\n\t\t\t\t\tproperties: properties,\n\t\t\t\t\tduration: duration||350,\n\t\t\t\t\teasing: easing\n\t\t\t\t});\n\t\t\t})\n\t\t);\n\t\tif(onEnd){\n\t\t\taspect.after(canim, \"onEnd\", onEnd, true);\n\t\t}\n\t\treturn canim.play(delay||0); // dojo/_base/fx.Animation\n\t}\n});\n\nreturn NodeList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-html.js":"define([\"./query\", \"./_base/lang\", \"./html\"], function(query, lang, html){\n\n// module:\n//\t\tdojo/NodeList-html\n\n/*=====\nreturn function(){\n\t// summary:\n\t//\t\tAdds a chainable html method to dojo/query() / NodeList instances for setting/replacing node content\n};\n=====*/\n\nvar NodeList = query.NodeList;\n\n\nlang.extend(NodeList, {\n\thtml: function(/* String|DomNode|NodeList? */ content, /* Object? */params){\n\t\t// summary:\n\t\t//\t\tsee `dojo/html.set()`. Set the content of all elements of this NodeList\n\t\t//\n\t\t// content:\n\t\t//\t\tAn html string, node or enumerable list of nodes for insertion into the dom\n\t\t//\n\t\t// params:\n\t\t//\t\tOptional flags/properties to configure the content-setting. See dojo/html._ContentSetter\n\t\t//\n\t\t// description:\n\t\t//\t\tBased around `dojo/html.set()`, set the content of the Elements in a\n\t\t//\t\tNodeList to the given content (string/node/nodelist), with optional arguments\n\t\t//\t\tto further tune the set content behavior.\n\t\t//\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-html\"\n\t\t//\t|\t], function(query){\n\t\t//\t| \t\tquery(\".thingList\").html(\"<li data-dojo-type='dojo/dnd/Moveable'>1</li><li data-dojo-type='dojo/dnd/Moveable'>2</li><li data-dojo-type='dojo/dnd/Moveable'>3</li>\",\n\t\t//\t| \t\t{\n\t\t//\t| \t\t\tparseContent: true,\n\t\t//\t| \t\t\tonBegin: function(){\n\t\t//\t| \t\t\t\tthis.content = this.content.replace(/([0-9])/g, this.id + \": $1\");\n\t\t//\t| \t\t\t\tthis.inherited(\"onBegin\", arguments);\n\t\t//\t| \t\t\t}\n\t\t//\t|\t\t}).removeClass(\"notdone\").addClass(\"done\");\n\t\t//\t| \t});\n\n\t\tvar dhs = new html._ContentSetter(params || {});\n\t\tthis.forEach(function(elm){\n\t\t\tdhs.node = elm;\n\t\t\tdhs.set(content);\n\t\t\tdhs.tearDown();\n\t\t});\n\t\treturn this; // dojo/NodeList\n\t}\n});\n\nreturn NodeList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList.js":"define([\"./query\"], function(query){\n\t// This class is just for documentation purposes, so NodeList shows up well in the API viewer,\n\t// and to simplify writing API doc for all the methods that take NodeList as a parameter, or return a NodeList.\n\treturn query.NodeList;\n});\n\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-manipulate.js":"define([\"./query\", \"./_base/lang\", \"./_base/array\", \"./dom-construct\", \"./NodeList-dom\"], function(dquery, lang, array, construct){\n\t// module:\n\t//\t\tdojo/NodeList-manipulate\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tAdds chainable methods to dojo.query() / NodeList instances for manipulating HTML\n\t\t//\t\tand DOM nodes and their properties.\n\t};\n\t=====*/\n\n\tvar NodeList = dquery.NodeList;\n\n\t//TODO: add a way to parse for widgets in the injected markup?\n\n\tfunction getText(/*DOMNode*/node){\n\t\t// summary:\n\t\t//\t\trecursion method for text() to use. Gets text value for a node.\n\t\t// description:\n\t\t//\t\tJuse uses nodedValue so things like <br/> tags do not end up in\n\t\t//\t\tthe text as any sort of line return.\n\t\tvar text = \"\", ch = node.childNodes;\n\t\tfor(var i = 0, n; n = ch[i]; i++){\n\t\t\t//Skip comments.\n\t\t\tif(n.nodeType != 8){\n\t\t\t\tif(n.nodeType == 1){\n\t\t\t\t\ttext += getText(n);\n\t\t\t\t}else{\n\t\t\t\t\ttext += n.nodeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn text;\n\t}\n\n\tfunction getWrapInsertion(/*DOMNode*/node){\n\t\t// summary:\n\t\t//\t\tfinds the innermost element to use for wrap insertion.\n\n\t\t//Make it easy, assume single nesting, no siblings.\n\t\twhile(node.childNodes[0] && node.childNodes[0].nodeType == 1){\n\t\t\tnode = node.childNodes[0];\n\t\t}\n\t\treturn node; //DOMNode\n\t}\n\n\tfunction makeWrapNode(/*DOMNode||String*/html, /*DOMNode*/refNode){\n\t\t// summary:\n\t\t//\t\tconvert HTML into nodes if it is not already a node.\n\t\tif(typeof html == \"string\"){\n\t\t\thtml = construct.toDom(html, (refNode && refNode.ownerDocument));\n\t\t\tif(html.nodeType == 11){\n\t\t\t\t//DocumentFragment cannot handle cloneNode, so choose first child.\n\t\t\t\thtml = html.childNodes[0];\n\t\t\t}\n\t\t}else if(html.nodeType == 1 && html.parentNode){\n\t\t\t//This element is already in the DOM clone it, but not its children.\n\t\t\thtml = html.cloneNode(false);\n\t\t}\n\t\treturn html; /*DOMNode*/\n\t}\n\n\tlang.extend(NodeList, {\n\t\t_placeMultiple: function(/*String||Node||NodeList*/query, /*String*/position){\n\t\t\t// summary:\n\t\t\t//\t\tprivate method for inserting queried nodes into all nodes in this NodeList\n\t\t\t//\t\tat different positions. Differs from NodeList.place because it will clone\n\t\t\t//\t\tthe nodes in this NodeList if the query matches more than one element.\n\t\t\tvar nl2 = typeof query == \"string\" || query.nodeType ? dquery(query) : query;\n\t\t\tvar toAdd = [];\n\t\t\tfor(var i = 0; i < nl2.length; i++){\n\t\t\t\t//Go backwards in DOM to make dom insertions easier via insertBefore\n\t\t\t\tvar refNode = nl2[i];\n\t\t\t\tvar length = this.length;\n\t\t\t\tfor(var j = length - 1, item; item = this[j]; j--){\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\t//Need to clone the item. This also means\n\t\t\t\t\t\t//it needs to be added to the current NodeList\n\t\t\t\t\t\t//so it can also be the target of other chaining operations.\n\t\t\t\t\t\titem = this._cloneNode(item);\n\t\t\t\t\t\ttoAdd.unshift(item);\n\t\t\t\t\t}\n\t\t\t\t\tif(j == length - 1){\n\t\t\t\t\t\tconstruct.place(item, refNode, position);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trefNode.parentNode.insertBefore(item, refNode);\n\t\t\t\t\t}\n\t\t\t\t\trefNode = item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(toAdd.length){\n\t\t\t\t//Add the toAdd items to the current NodeList. Build up list of args\n\t\t\t\t//to pass to splice.\n\t\t\t\ttoAdd.unshift(0);\n\t\t\t\ttoAdd.unshift(this.length - 1);\n\t\t\t\tArray.prototype.splice.apply(this, toAdd);\n\t\t\t}\n\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\tinnerHTML: function(/*String|DOMNode|NodeList?*/ value){\n\t\t\t// summary:\n\t\t\t//\t\tallows setting the innerHTML of each node in the NodeList,\n\t\t\t//\t\tif there is a value passed in, otherwise, reads the innerHTML value of the first node.\n\t\t\t// description:\n\t\t\t//\t\tThis method is simpler than the dojo/NodeList.html() method provided by\n\t\t\t//\t\t`dojo/NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,\n\t\t\t//\t\tand it allows for the innerHTML to be read for the first node in the node list.\n\t\t\t//\t\tSince dojo/NodeList-html already took the \"html\" name, this method is called\n\t\t\t//\t\t\"innerHTML\". However, if dojo/NodeList-html has not been loaded yet, this\n\t\t\t//\t\tmodule will define an \"html\" method that can be used instead. Be careful if you\n\t\t\t//\t\tare working in an environment where it is possible that dojo/NodeList-html could\n\t\t\t//\t\thave been loaded, since its definition of \"html\" will take precedence.\n\t\t\t//\t\tThe nodes represented by the value argument will be cloned if more than one\n\t\t\t//\t\tnode is in this NodeList. The nodes in this NodeList are returned in the \"set\"\n\t\t\t//\t\tusage of this method, not the HTML that was inserted.\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is String, the innerHTML of the first node.\n\t\t\t//\t\tIf a value is passed, the return is this dojo/NodeList\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"></div>\n\t\t\t//\t|\t<div id=\"bar\"></div>\n\t\t\t//\t\tThis code inserts `<p>Hello World</p>` into both divs:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").innerHTML(\"<p>Hello World</p>\");\n\t\t\t//\t| \t});\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tThis code returns `<p>Hello Mars</p>`:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tvar message = query(\"div\").innerHTML();\n\t\t\t//\t| \t});\n\t\t\tif(arguments.length){\n\t\t\t\treturn this.addContent(value, \"only\"); // dojo/NodeList\n\t\t\t}else{\n\t\t\t\treturn this[0].innerHTML; //String\n\t\t\t}\n\t\t},\n\n\t\t/*=====\n\t\thtml: function(value){\n\t\t\t// summary:\n\t\t\t//\t\tsee the information for \"innerHTML\". \"html\" is an alias for \"innerHTML\", but is\n\t\t\t//\t\tonly defined if dojo/NodeList-html has not been loaded.\n\t\t\t// description:\n\t\t\t//\t\tAn alias for the \"innerHTML\" method, but only defined if there is not an existing\n\t\t\t//\t\t\"html\" method on dojo/NodeList. Be careful if you are working in an environment\n\t\t\t//\t\twhere it is possible that dojo/NodeList-html could have been loaded, since its\n\t\t\t//\t\tdefinition of \"html\" will take precedence. If you are not sure if dojo/NodeList-html\n\t\t\t//\t\tcould be loaded, use the \"innerHTML\" method.\n\t\t\t// value: String|DOMNode|NodeList?\n\t\t\t//\t\tThe HTML fragment to use as innerHTML. If value is not passed, then the innerHTML\n\t\t\t//\t\tof the first element in this NodeList is returned.\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is String, the innerHTML of the first node.\n\t\t\t//\t\tIf a value is passed, the return is this dojo/NodeList\n\t\t\treturn; // dojo/NodeList|String\n\t\t},\n\t\t=====*/\n\n\t\ttext: function(/*String*/value){\n\t\t\t// summary:\n\t\t\t//\t\tallows setting the text value of each node in the NodeList,\n\t\t\t//\t\tif there is a value passed in, otherwise, returns the text value for all the\n\t\t\t//\t\tnodes in the NodeList in one string.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"></div>\n\t\t\t//\t|\t<div id=\"bar\"></div>\n\t\t\t//\t\tThis code inserts \"Hello World\" into both divs:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").text(\"Hello World\");\n\t\t\t//\t| \t});\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars <span>today</span></p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tThis code returns \"Hello Mars today\":\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tvar message = query(\"div\").text();\n\t\t\t//\t| \t});\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is String, the text value of the first node.\n\t\t\t//\t\tIf a value is passed, the return is this dojo/NodeList\n\t\t\tif(arguments.length){\n\t\t\t\tfor(var i = 0, node; node = this[i]; i++){\n\t\t\t\t\tif(node.nodeType == 1){\n\t\t\t\t\t\tconstruct.empty(node);\n\t\t\t\t\t\tnode.appendChild(node.ownerDocument.createTextNode(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this; // dojo/NodeList\n\t\t\t}else{\n\t\t\t\tvar result = \"\";\n\t\t\t\tfor(i = 0; node = this[i]; i++){\n\t\t\t\t\tresult += getText(node);\n\t\t\t\t}\n\t\t\t\treturn result; //String\n\t\t\t}\n\t\t},\n\n\t\tval: function(/*String||Array*/value){\n\t\t\t// summary:\n\t\t\t//\t\tIf a value is passed, allows seting the value property of form elements in this\n\t\t\t//\t\tNodeList, or properly selecting/checking the right value for radio/checkbox/select\n\t\t\t//\t\telements. If no value is passed, the value of the first node in this NodeList\n\t\t\t//\t\tis returned.\n\t\t\t// returns:\n\t\t\t//\t\tif no value is passed, the result is String or an Array, for the value of the\n\t\t\t//\t\tfirst node.\n\t\t\t//\t\tIf a value is passed, the return is this dojo/NodeList\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<input type=\"text\" value=\"foo\">\n\t\t\t//\t|\t<select multiple>\n\t\t\t//\t|\t\t<option value=\"red\" selected>Red</option>\n\t\t\t//\t|\t\t<option value=\"blue\">Blue</option>\n\t\t\t//\t|\t\t<option value=\"yellow\" selected>Yellow</option>\n\t\t\t//\t|\t</select>\n\t\t\t//\t\tThis code gets and sets the values for the form fields above:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery('[type=\"text\"]').val(); //gets value foo\n\t\t\t//\t|\t\tquery('[type=\"text\"]').val(\"bar\"); //sets the input's value to \"bar\"\n\t\t\t// \t|\t\tquery(\"select\").val() //gets array value [\"red\", \"yellow\"]\n\t\t\t// \t|\t\tquery(\"select\").val([\"blue\", \"yellow\"]) //Sets the blue and yellow options to selected.\n\t\t\t//\t| \t});\n\n\t\t\t//Special work for input elements.\n\t\t\tif(arguments.length){\n\t\t\t\tvar isArray = lang.isArray(value);\n\t\t\t\tfor(var index = 0, node; node = this[index]; index++){\n\t\t\t\t\tvar name = node.nodeName.toUpperCase();\n\t\t\t\t\tvar type = node.type;\n\t\t\t\t\tvar newValue = isArray ? value[index] : value;\n\n\t\t\t\t\tif(name == \"SELECT\"){\n\t\t\t\t\t\tvar opts = node.options;\n\t\t\t\t\t\tfor(var i = 0; i < opts.length; i++){\n\t\t\t\t\t\t\tvar opt = opts[i];\n\t\t\t\t\t\t\tif(node.multiple){\n\t\t\t\t\t\t\t\topt.selected = (array.indexOf(value, opt.value) != -1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topt.selected = (opt.value == newValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(type == \"checkbox\" || type == \"radio\"){\n\t\t\t\t\t\tnode.checked = (node.value == newValue);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnode.value = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this; // dojo/NodeList\n\t\t\t}else{\n\t\t\t\t//node already declared above.\n\t\t\t\tnode = this[0];\n\t\t\t\tif(!node || node.nodeType != 1){\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tvalue = node.value || \"\";\n\t\t\t\tif(node.nodeName.toUpperCase() == \"SELECT\" && node.multiple){\n\t\t\t\t\t//A multivalued selectbox. Do the pain.\n\t\t\t\t\tvalue = [];\n\t\t\t\t\t//opts declared above in if block.\n\t\t\t\t\topts = node.options;\n\t\t\t\t\t//i declared above in if block;\n\t\t\t\t\tfor(i = 0; i < opts.length; i++){\n\t\t\t\t\t\t//opt declared above in if block\n\t\t\t\t\t\topt = opts[i];\n\t\t\t\t\t\tif(opt.selected){\n\t\t\t\t\t\t\tvalue.push(opt.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!value.length){\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value; //String||Array\n\t\t\t}\n\t\t},\n\n\t\tappend: function(/*String||DOMNode||NodeList*/content){\n\t\t\t// summary:\n\t\t\t//\t\tappends the content to every node in the NodeList.\n\t\t\t// description:\n\t\t\t//\t\tThe content will be cloned if the length of NodeList\n\t\t\t//\t\tis greater than 1. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the appended content.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").append(\"<span>append</span>\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p><span>append</span></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p><span>append</span></div>\n\t\t\treturn this.addContent(content, \"last\"); // dojo/NodeList\n\t\t},\n\n\t\tappendTo: function(/*String*/query){\n\t\t\t// summary:\n\t\t\t//\t\tappends nodes in this NodeList to the nodes matched by\n\t\t\t//\t\tthe query passed to appendTo.\n\t\t\t// description:\n\t\t\t//\t\tThe nodes in this NodeList will be cloned if the query\n\t\t\t//\t\tmatches more than one element. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the matched nodes from the query.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<span>append</span>\n\t\t\t//\t|\t<p>Hello Mars</p>\n\t\t\t//\t|\t<p>Hello World</p>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"span\").appendTo(\"p\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<p>Hello Mars<span>append</span></p>\n\t\t\t//\t|\t<p>Hello World<span>append</span></p>\n\t\t\treturn this._placeMultiple(query, \"last\"); // dojo/NodeList\n\t\t},\n\n\t\tprepend: function(/*String||DOMNode||NodeList*/content){\n\t\t\t// summary:\n\t\t\t//\t\tprepends the content to every node in the NodeList.\n\t\t\t// description:\n\t\t\t//\t\tThe content will be cloned if the length of NodeList\n\t\t\t//\t\tis greater than 1. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the appended content.\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").prepend(\"<span>prepend</span>\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div id=\"foo\"><span>prepend</span><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><span>prepend</span><p>Hello World</p></div>\n\t\t\treturn this.addContent(content, \"first\"); // dojo/NodeList\n\t\t},\n\n\t\tprependTo: function(/*String*/query){\n\t\t\t// summary:\n\t\t\t//\t\tprepends nodes in this NodeList to the nodes matched by\n\t\t\t//\t\tthe query passed to prependTo.\n\t\t\t// description:\n\t\t\t//\t\tThe nodes in this NodeList will be cloned if the query\n\t\t\t//\t\tmatches more than one element. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the matched nodes from the query.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<span>prepend</span>\n\t\t\t//\t|\t<p>Hello Mars</p>\n\t\t\t//\t|\t<p>Hello World</p>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"span\").prependTo(\"p\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<p><span>prepend</span>Hello Mars</p>\n\t\t\t//\t|\t<p><span>prepend</span>Hello World</p>\n\t\t\treturn this._placeMultiple(query, \"first\"); // dojo/NodeList\n\t\t},\n\n\t\tafter: function(/*String||Element||NodeList*/content){\n\t\t\t// summary:\n\t\t\t//\t\tPlaces the content after every node in the NodeList.\n\t\t\t// description:\n\t\t\t//\t\tThe content will be cloned if the length of NodeList\n\t\t\t//\t\tis greater than 1. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the appended content.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").after(\"<span>after</span>\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div><span>after</span>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div><span>after</span>\n\t\t\treturn this.addContent(content, \"after\"); // dojo/NodeList\n\t\t},\n\n\t\tinsertAfter: function(/*String*/query){\n\t\t\t// summary:\n\t\t\t//\t\tThe nodes in this NodeList will be placed after the nodes\n\t\t\t//\t\tmatched by the query passed to insertAfter.\n\t\t\t// description:\n\t\t\t//\t\tThe nodes in this NodeList will be cloned if the query\n\t\t\t//\t\tmatches more than one element. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the matched nodes from the query.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<span>after</span>\n\t\t\t//\t|\t<p>Hello Mars</p>\n\t\t\t//\t|\t<p>Hello World</p>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"span\").insertAfter(\"p\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<p>Hello Mars</p><span>after</span>\n\t\t\t//\t|\t<p>Hello World</p><span>after</span>\n\t\t\treturn this._placeMultiple(query, \"after\"); // dojo/NodeList\n\t\t},\n\n\t\tbefore: function(/*String||DOMNode||NodeList*/content){\n\t\t\t// summary:\n\t\t\t//\t\tPlaces the content before every node in the NodeList.\n\t\t\t// description:\n\t\t\t//\t\tThe content will be cloned if the length of NodeList\n\t\t\t//\t\tis greater than 1. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the appended content.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<div id=\"bar\"><p>Hello World</p></div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"div\").before(\"<span>before</span>\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<span>before</span><div id=\"foo\"><p>Hello Mars</p></div>\n\t\t\t//\t|\t<span>before</span><div id=\"bar\"><p>Hello World</p></div>\n\t\t\treturn this.addContent(content, \"before\"); // dojo/NodeList\n\t\t},\n\n\t\tinsertBefore: function(/*String*/query){\n\t\t\t// summary:\n\t\t\t//\t\tThe nodes in this NodeList will be placed after the nodes\n\t\t\t//\t\tmatched by the query passed to insertAfter.\n\t\t\t// description:\n\t\t\t//\t\tThe nodes in this NodeList will be cloned if the query\n\t\t\t//\t\tmatches more than one element. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tdojo/NodeList, the nodes currently in this NodeList will be returned,\n\t\t\t//\t\tnot the matched nodes from the query.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<span>before</span>\n\t\t\t//\t|\t<p>Hello Mars</p>\n\t\t\t//\t|\t<p>Hello World</p>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"span\").insertBefore(\"p\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<span>before</span><p>Hello Mars</p>\n\t\t\t//\t|\t<span>before</span><p>Hello World</p>\n\t\t\treturn this._placeMultiple(query, \"before\"); // dojo/NodeList\n\t\t},\n\n\t\t/*=====\n\t\tremove: function(simpleFilter){\n\t\t\t// summary:\n\t\t\t//\t\talias for dojo/NodeList's orphan method. Removes elements\n\t\t\t//\t\tin this list that match the simple filter from their parents\n\t\t\t//\t\tand returns them as a new NodeList.\n\t\t\t// simpleFilter: String\n\t\t\t//\t\tsingle-expression CSS rule. For example, \".thinger\" or\n\t\t\t//\t\t\"#someId[attrName='value']\" but not \"div > span\". In short,\n\t\t\t//\t\tanything which does not invoke a descent to evaluate but\n\t\t\t//\t\tcan instead be used to test a single node is acceptable.\n\n\t\t\treturn; // dojo/NodeList\n\t\t},\n\t\t=====*/\n\t\tremove: NodeList.prototype.orphan,\n\n\t\twrap: function(/*String||DOMNode*/html){\n\t\t\t// summary:\n\t\t\t//\t\tWrap each node in the NodeList with html passed to wrap.\n\t\t\t// description:\n\t\t\t//\t\thtml will be cloned if the NodeList has more than one\n\t\t\t//\t\telement. Only DOM nodes are cloned, not any attached\n\t\t\t//\t\tevent handlers.\n\t\t\t// returns:\n\t\t\t//\t\tthe nodes in the current NodeList will be returned,\n\t\t\t//\t\tnot the nodes from html argument.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<b>one</b>\n\t\t\t//\t|\t<b>two</b>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"b\").wrap(\"<div><span></span></div>\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div><span><b>one</b></span></div>\n\t\t\t//\t|\t<div><span><b>two</b></span></div>\n\t\t\tif(this[0]){\n\t\t\t\thtml = makeWrapNode(html, this[0]);\n\n\t\t\t\t//Now cycle through the elements and do the insertion.\n\t\t\t\tfor(var i = 0, node; node = this[i]; i++){\n\t\t\t\t\t//Always clone because if html is used to hold one of\n\t\t\t\t\t//the \"this\" nodes, then on the clone of html it will contain\n\t\t\t\t\t//that \"this\" node, and that would be bad.\n\t\t\t\t\tvar clone = this._cloneNode(html);\n\t\t\t\t\tif(node.parentNode){\n\t\t\t\t\t\tnode.parentNode.replaceChild(clone, node);\n\t\t\t\t\t}\n\t\t\t\t\t//Find deepest element and insert old node in it.\n\t\t\t\t\tvar insertion = getWrapInsertion(clone);\n\t\t\t\t\tinsertion.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\twrapAll: function(/*String||DOMNode*/html){\n\t\t\t// summary:\n\t\t\t//\t\tInsert html where the first node in this NodeList lives, then place all\n\t\t\t//\t\tnodes in this NodeList as the child of the html.\n\t\t\t// returns:\n\t\t\t//\t\tthe nodes in the current NodeList will be returned,\n\t\t\t//\t\tnot the nodes from html argument.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".red\").wrapAll('<div class=\"allRed\"></div>');\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"allRed\">\n\t\t\t// \t|\t\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\tif(this[0]){\n\t\t\t\thtml = makeWrapNode(html, this[0]);\n\n\t\t\t\t//Place the wrap HTML in place of the first node.\n\t\t\t\tthis[0].parentNode.replaceChild(html, this[0]);\n\n\t\t\t\t//Now cycle through the elements and move them inside\n\t\t\t\t//the wrap.\n\t\t\t\tvar insertion = getWrapInsertion(html);\n\t\t\t\tfor(var i = 0, node; node = this[i]; i++){\n\t\t\t\t\tinsertion.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\twrapInner: function(/*String||DOMNode*/html){\n\t\t\t// summary:\n\t\t\t//\t\tFor each node in the NodeList, wrap all its children with the passed in html.\n\t\t\t// description:\n\t\t\t//\t\thtml will be cloned if the NodeList has more than one\n\t\t\t//\t\telement. Only DOM nodes are cloned, not any attached\n\t\t\t//\t\tevent handlers.\n\t\t\t// returns:\n\t\t\t//\t\tthe nodes in the current NodeList will be returned,\n\t\t\t//\t\tnot the nodes from html argument.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".red\").wrapInner('<span class=\"special\"></span>');\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\"><span class=\"special\">Red One</span></div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\"><span class=\"special\">Red Two</span></div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\tif(this[0]){\n\t\t\t\thtml = makeWrapNode(html, this[0]);\n\t\t\t\tfor(var i = 0; i < this.length; i++){\n\t\t\t\t\t//Always clone because if html is used to hold one of\n\t\t\t\t\t//the \"this\" nodes, then on the clone of html it will contain\n\t\t\t\t\t//that \"this\" node, and that would be bad.\n\t\t\t\t\tvar clone = this._cloneNode(html);\n\n\t\t\t\t\t//Need to convert the childNodes to an array since wrapAll modifies the\n\t\t\t\t\t//DOM and can change the live childNodes NodeList.\n\t\t\t\t\tthis._wrap(lang._toArray(this[i].childNodes), null, this._NodeListCtor).wrapAll(clone);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\treplaceWith: function(/*String||DOMNode||NodeList*/content){\n\t\t\t// summary:\n\t\t\t//\t\tReplaces each node in ths NodeList with the content passed to replaceWith.\n\t\t\t// description:\n\t\t\t//\t\tThe content will be cloned if the length of NodeList\n\t\t\t//\t\tis greater than 1. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tThe nodes currently in this NodeList will be returned, not the replacing content.\n\t\t\t//\t\tNote that the returned nodes have been removed from the DOM.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".red\").replaceWith('<div class=\"green\">Green</div>');\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"green\">Green</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"green\">Green</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\tcontent = this._normalize(content, this[0]);\n\t\t\tfor(var i = 0, node; node = this[i]; i++){\n\t\t\t\tthis._place(content, node, \"before\", i > 0);\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\treplaceAll: function(/*String*/query){\n\t\t\t// summary:\n\t\t\t//\t\treplaces nodes matched by the query passed to replaceAll with the nodes\n\t\t\t//\t\tin this NodeList.\n\t\t\t// description:\n\t\t\t//\t\tThe nodes in this NodeList will be cloned if the query\n\t\t\t//\t\tmatches more than one element. Only the DOM nodes are cloned, not\n\t\t\t//\t\tany attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\tThe nodes currently in this NodeList will be returned, not the matched nodes\n\t\t\t//\t\tfrom the query. The nodes currently in this NodeLIst could have\n\t\t\t//\t\tbeen cloned, so the returned NodeList will include the cloned nodes.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".red\").replaceAll(\".blue\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"spacer\">___</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t//\t|\t</div>\n\t\t\tvar nl = dquery(query);\n\t\t\tvar content = this._normalize(this, this[0]);\n\t\t\tfor(var i = 0, node; node = nl[i]; i++){\n\t\t\t\tthis._place(content, node, \"before\", i > 0);\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\tclone: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClones all the nodes in this NodeList and returns them as a new NodeList.\n\t\t\t// description:\n\t\t\t//\t\tOnly the DOM nodes are cloned, not any attached event handlers.\n\t\t\t// returns:\n\t\t\t//\t\ta cloned set of the original nodes.\n\t\t\t// example:\n\t\t\t//\t\tassume a DOM created by this markup:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t//\t|\t</div>\n\t\t\t//\t\tRunning this code:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-manipulate\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\".red\").clone().appendTo(\".container\");\n\t\t\t//\t| \t});\n\t\t\t//\t\tResults in this DOM structure:\n\t\t\t//\t|\t<div class=\"container\">\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t\t//\t|\t</div>\n\n\t\t\t//TODO: need option to clone events?\n\t\t\tvar ary = [];\n\t\t\tfor(var i = 0; i < this.length; i++){\n\t\t\t\tary.push(this._cloneNode(this[i]));\n\t\t\t}\n\t\t\treturn this._wrap(ary, this, this._NodeListCtor); // dojo/NodeList\n\t\t}\n\t});\n\n\t//set up html method if one does not exist\n\tif(!NodeList.prototype.html){\n\t\tNodeList.prototype.html = NodeList.prototype.innerHTML;\n\t}\n\n\treturn NodeList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/NodeList-traverse.js":"define([\"./query\", \"./_base/lang\", \"./_base/array\"], function(dquery, lang, array){\n\n// module:\n//\t\tdojo/NodeList-traverse\n\n/*=====\nreturn function(){\n\t// summary:\n\t//\t\tAdds chainable methods to dojo/query() / NodeList instances for traversing the DOM\n};\n=====*/\n\nvar NodeList = dquery.NodeList;\n\nlang.extend(NodeList, {\n\t_buildArrayFromCallback: function(/*Function*/ callback){\n\t\t// summary:\n\t\t//\t\tbuilds a new array of possibly differing size based on the input list.\n\t\t//\t\tSince the returned array is likely of different size than the input array,\n\t\t//\t\tthe array's map function cannot be used.\n\t\tvar ary = [];\n\t\tfor(var i = 0; i < this.length; i++){\n\t\t\tvar items = callback.call(this[i], this[i], ary);\n\t\t\tif(items){\n\t\t\t\tary = ary.concat(items);\n\t\t\t}\n\t\t}\n\t\treturn ary;\t//Array\n\t},\n\n\t_getUniqueAsNodeList: function(/*Array*/ nodes){\n\t\t// summary:\n\t\t//\t\tgiven a list of nodes, make sure only unique\n\t\t//\t\telements are returned as our NodeList object.\n\t\t//\t\tDoes not call _stash().\n\t\tvar ary = [];\n\t\t//Using for loop for better speed.\n\t\tfor(var i = 0, node; node = nodes[i]; i++){\n\t\t\t//Should be a faster way to do this. dojo/query has a private\n\t\t\t//_zip function that may be inspirational, but there are pathways\n\t\t\t//in query that force nozip?\n\t\t\tif(node.nodeType == 1 && array.indexOf(ary, node) == -1){\n\t\t\t\tary.push(node);\n\t\t\t}\n\t\t}\n\t\treturn this._wrap(ary, null, this._NodeListCtor);\t // dojo/NodeList\n\t},\n\n\t_getUniqueNodeListWithParent: function(/*Array*/ nodes, /*String*/ query){\n\t\t// summary:\n\t\t//\t\tgets unique element nodes, filters them further\n\t\t//\t\twith an optional query and then calls _stash to track parent NodeList.\n\t\tvar ary = this._getUniqueAsNodeList(nodes);\n\t\tary = (query ? dquery._filterResult(ary, query) : ary);\n\t\treturn ary._stash(this);  // dojo/NodeList\n\t},\n\n\t_getRelatedUniqueNodes: function(/*String?*/ query, /*Function*/ callback){\n\t\t// summary:\n\t\t//\t\tcycles over all the nodes and calls a callback\n\t\t//\t\tto collect nodes for a possible inclusion in a result.\n\t\t//\t\tThe callback will get two args: callback(node, ary),\n\t\t//\t\twhere ary is the array being used to collect the nodes.\n\t\treturn this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  // dojo/NodeList\n\t},\n\n\tchildren: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns all immediate child elements for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the child elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tall immediate child elements for the nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".container\").children();\n\t\t//\t|\t});\n\t\t//\t\treturns the four divs that are children of the container div.\n\t\t//\t\tRunning this code:\n\t\t//\t|\tdojo.query(\".container\").children(\".red\");\n\t\t//\t\treturns the two divs that have the class \"red\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\treturn lang._toArray(node.childNodes);\n\t\t}); // dojo/NodeList\n\t},\n\n\tclosest: function(/*String*/ query, /*String|DOMNode?*/ root){\n\t\t// summary:\n\t\t//\t\tReturns closest parent that matches query, including current node in this\n\t\t//\t\tdojo/NodeList if it matches the query.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// root:\n\t\t//\t\tIf specified, query is relative to \"root\" rather than document body.\n\t\t// returns:\n\t\t//\t\tthe closest parent that matches the query, including the current\n\t\t//\t\tnode in this dojo/NodeList if it matches the query.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t//\t|\t\t<div class=\"red\">Red One</div>\n\t\t//\t|\t\tSome Text\n\t\t//\t|\t\t<div class=\"blue\">Blue One</div>\n\t\t//\t|\t\t<div class=\"red\">Red Two</div>\n\t\t//\t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".red\").closest(\".container\");\n\t\t//\t|\t});\n\t\t//\t\treturns the div with class \"container\".\n\t\treturn this._getRelatedUniqueNodes(null, function(node, ary){\n\t\t\tdo{\n\t\t\t\tif(dquery._filterResult([node], query, root).length){\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}while(node != root && (node = node.parentNode) && node.nodeType == 1);\n\t\t\treturn null; //To make rhino strict checking happy.\n\t\t}); // dojo/NodeList\n\t},\n\n\tparent: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns immediate parent elements for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the parent elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\timmediate parent elements for nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\t<div class=\"blue first\"><span class=\"text\">Blue One</span></div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\"><span class=\"text\">Blue Two</span></div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".text\").parent();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class \"blue\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".text\").parent(\".first\");\n\t\t//\t\treturns the one div with class \"blue\" and \"first\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\treturn node.parentNode;\n\t\t}); // dojo/NodeList\n\t},\n\n\tparents: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns all parent elements for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the child elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tall parent elements for nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\t<div class=\"blue first\"><span class=\"text\">Blue One</span></div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\"><span class=\"text\">Blue Two</span></div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".text\").parents();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class \"blue\", the div with class \"container\",\n\t\t// \t|\tthe body element and the html element.\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".text\").parents(\".container\");\n\t\t//\t\treturns the one div with class \"container\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar pary = [];\n\t\t\twhile(node.parentNode){\n\t\t\t\tnode = node.parentNode;\n\t\t\t\tpary.push(node);\n\t\t\t}\n\t\t\treturn pary;\n\t\t}); // dojo/NodeList\n\t},\n\n\tsiblings: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns all sibling elements for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the sibling elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tall sibling elements for nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".first\").siblings();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class \"red\" and the other div\n\t\t// \t|\twith class \"blue\" that does not have \"first\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".first\").siblings(\".red\");\n\t\t//\t\treturns the two div with class \"red\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar pary = [];\n\t\t\tvar nodes = (node.parentNode && node.parentNode.childNodes);\n\t\t\tfor(var i = 0; i < nodes.length; i++){\n\t\t\t\tif(nodes[i] != node){\n\t\t\t\t\tpary.push(nodes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pary;\n\t\t}); // dojo/NodeList\n\t},\n\n\tnext: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns the next element for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the next elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tthe next element for nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue last\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".first\").next();\n\t\t//\t|\t});\n\t\t//\t\treturns the div with class \"red\" and has innerHTML of \"Red Two\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\tdojo.query(\".last\").next(\".red\");\n\t\t//\t\tdoes not return any elements.\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar next = node.nextSibling;\n\t\t\twhile(next && next.nodeType != 1){\n\t\t\t\tnext = next.nextSibling;\n\t\t\t}\n\t\t\treturn next;\n\t\t}); // dojo/NodeList\n\t},\n\n\tnextAll: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns all sibling elements that come after the nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the sibling elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tall sibling elements that come after the nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red next\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue next\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".first\").nextAll();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class of \"next\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".first\").nextAll(\".red\");\n\t\t//\t\treturns the one div with class \"red\" and innerHTML \"Red Two\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar pary = [];\n\t\t\tvar next = node;\n\t\t\twhile((next = next.nextSibling)){\n\t\t\t\tif(next.nodeType == 1){\n\t\t\t\t\tpary.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pary;\n\t\t}); // dojo/NodeList\n\t},\n\n\tprev: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns the previous element for nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the previous elements.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tthe previous element for nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".first\").prev();\n\t\t//\t|\t});\n\t\t//\t\treturns the div with class \"red\" and has innerHTML of \"Red One\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".first\").prev(\".blue\");\n\t\t//\t\tdoes not return any elements.\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar prev = node.previousSibling;\n\t\t\twhile(prev && prev.nodeType != 1){\n\t\t\t\tprev = prev.previousSibling;\n\t\t\t}\n\t\t\treturn prev;\n\t\t}); // dojo/NodeList\n\t},\n\n\tprevAll: function(/*String?*/ query){\n\t\t// summary:\n\t\t//\t\tReturns all sibling elements that come before the nodes in this dojo/NodeList.\n\t\t//\t\tOptionally takes a query to filter the sibling elements.\n\t\t// description:\n\t\t//\t\tThe returned nodes will be in reverse DOM order -- the first node in the list will\n\t\t//\t\tbe the node closest to the original node/NodeList.\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// query:\n\t\t//\t\ta CSS selector.\n\t\t// returns:\n\t\t//\t\tall sibling elements that come before the nodes in this dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red prev\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue prev\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red second\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".second\").prevAll();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class of \"prev\".\n\t\t//\t\tRunning this code:\n\t\t//\t|\t\tquery(\".first\").prevAll(\".red\");\n\t\t//\t\treturns the one div with class \"red prev\" and innerHTML \"Red One\".\n\t\treturn this._getRelatedUniqueNodes(query, function(node, ary){\n\t\t\tvar pary = [];\n\t\t\tvar prev = node;\n\t\t\twhile((prev = prev.previousSibling)){\n\t\t\t\tif(prev.nodeType == 1){\n\t\t\t\t\tpary.push(prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pary;\n\t\t}); // dojo/NodeList\n\t},\n\n\tandSelf: function(){\n\t\t// summary:\n\t\t//\t\tAdds the nodes from the previous dojo/NodeList to the current dojo/NodeList.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red prev\">Red One</div>\n\t\t// \t|\t\tSome Text\n\t\t// \t|\t\t<div class=\"blue prev\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red second\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".second\").prevAll().andSelf();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class of \"prev\", as well as the div with class \"second\".\n\t\treturn this.concat(this._parent);\t// dojo/NodeList\n\t},\n\n\t//Alternate methods for the :first/:last/:even/:odd pseudos.\n\tfirst: function(){\n\t\t// summary:\n\t\t//\t\tReturns the first node in this dojo/NodeList as a dojo/NodeList.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// returns:\n\t\t//\t\tthe first node in this dojo/NodeList\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue last\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".blue\").first();\n\t\t//\t|\t});\n\t\t//\t\treturns the div with class \"blue\" and \"first\".\n\t\treturn this._wrap(((this[0] && [this[0]]) || []), this); // dojo/NodeList\n\t},\n\n\tlast: function(){\n\t\t// summary:\n\t\t//\t\tReturns the last node in this dojo/NodeList as a dojo/NodeList.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// returns:\n\t\t//\t\tthe last node in this dojo/NodeList\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"red\">Red One</div>\n\t\t// \t|\t\t<div class=\"blue first\">Blue One</div>\n\t\t// \t|\t\t<div class=\"red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"blue last\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\tquery(\".blue\").last();\n\t\t//\t|\t});\n\t\t//\t\treturns the last div with class \"blue\",\n\t\treturn this._wrap((this.length ? [this[this.length - 1]] : []), this); // dojo/NodeList\n\t},\n\n\teven: function(){\n\t\t// summary:\n\t\t//\t\tReturns the even nodes in this dojo/NodeList as a dojo/NodeList.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// returns:\n\t\t//\t\tthe even nodes in this dojo/NodeList\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"interior red\">Red One</div>\n\t\t// \t|\t\t<div class=\"interior blue\">Blue One</div>\n\t\t// \t|\t\t<div class=\"interior red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"interior blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".interior\").even();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class \"blue\"\n\t\treturn this.filter(function(item, i){\n\t\t\treturn i % 2 != 0;\n\t\t}); // dojo/NodeList\n\t},\n\n\todd: function(){\n\t\t// summary:\n\t\t//\t\tReturns the odd nodes in this dojo/NodeList as a dojo/NodeList.\n\t\t// description:\n\t\t//\t\t.end() can be used on the returned dojo/NodeList to get back to the\n\t\t//\t\toriginal dojo/NodeList.\n\t\t// returns:\n\t\t//\t\tthe odd nodes in this dojo/NodeList\n\t\t// example:\n\t\t//\t\tassume a DOM created by this markup:\n\t\t//\t|\t<div class=\"container\">\n\t\t// \t|\t\t<div class=\"interior red\">Red One</div>\n\t\t// \t|\t\t<div class=\"interior blue\">Blue One</div>\n\t\t// \t|\t\t<div class=\"interior red\">Red Two</div>\n\t\t// \t|\t\t<div class=\"interior blue\">Blue Two</div>\n\t\t//\t|\t</div>\n\t\t//\t\tRunning this code:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-traverse\"\n\t\t//\t|\t], function(query){\n\t\t//\t|\t\tquery(\".interior\").odd();\n\t\t//\t|\t});\n\t\t//\t\treturns the two divs with class \"red\"\n\t\treturn this.filter(function(item, i){\n\t\t\treturn i % 2 == 0;\n\t\t}); // dojo/NodeList\n\t}\n});\n\nreturn NodeList;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/number.js":"define([/*===== \"./_base/declare\", =====*/ \"./_base/lang\", \"./i18n\", \"./i18n!./cldr/nls/number\", \"./string\", \"./regexp\"],\n\tfunction(/*===== declare, =====*/ lang, i18n, nlsNumber, dstring, dregexp){\n\n// module:\n//\t\tdojo/number\n\nvar number = {\n\t// summary:\n\t//\t\tlocalized formatting and parsing routines for Number\n};\nlang.setObject(\"dojo.number\", number);\n\n/*=====\nnumber.__FormatOptions = declare(null, {\n\t// pattern: String?\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\n\t//\t\tlocalization.  Literal characters in patterns are not supported.\n\t// type: String?\n\t//\t\tchoose a format type based on the locale from the following:\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\n\t// places: Number?\n\t//\t\tfixed number of decimal places to show.  This overrides any\n\t//\t\tinformation in the provided pattern.\n\t// round: Number?\n\t//\t\t5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\n\t//\t\tmeans do not round.\n\t// locale: String?\n\t//\t\toverride the locale used to determine formatting rules\n\t// fractional: Boolean?\n\t//\t\tIf false, show no decimal places, overriding places and pattern settings.\n});\n=====*/\n\nnumber.format = function(/*Number*/ value, /*number.__FormatOptions?*/ options){\n\t// summary:\n\t//\t\tFormat a Number as a String, using locale-specific settings\n\t// description:\n\t//\t\tCreate a string from a Number using a known localized pattern.\n\t//\t\tFormatting patterns appropriate to the locale are chosen from the\n\t//\t\t[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and\n\t//\t\tdelimiters.\n\t//\t\tIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.\n\t// value:\n\t//\t\tthe number to be formatted\n\n\toptions = lang.mixin({}, options || {});\n\tvar locale = i18n.normalizeLocale(options.locale),\n\t\tbundle = i18n.getLocalization(\"dojo.cldr\", \"number\", locale);\n\toptions.customs = bundle;\n\tvar pattern = options.pattern || bundle[(options.type || \"decimal\") + \"Format\"];\n\tif(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null\n\treturn number._applyPattern(value, pattern, options); // String\n};\n\n//number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\\.0*#*)?/; // not precise, but good enough\nnumber._numberPatternRE = /[#0,]*[#0](?:\\.0*#*)?/; // not precise, but good enough\n\nnumber._applyPattern = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatOptions?*/ options){\n\t// summary:\n\t//\t\tApply pattern to format value as a string using options. Gives no\n\t//\t\tconsideration to local customs.\n\t// value:\n\t//\t\tthe number to be formatted.\n\t// pattern:\n\t//\t\ta pattern string as described by\n\t//\t\t[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n\t// options: number.__FormatOptions?\n\t//\t\t_applyPattern is usually called via `dojo/number.format()` which\n\t//\t\tpopulates an extra property in the options parameter, \"customs\".\n\t//\t\tThe customs object specifies group and decimal parameters if set.\n\n\t//TODO: support escapes\n\toptions = options || {};\n\tvar group = options.customs.group,\n\t\tdecimal = options.customs.decimal,\n\t\tpatternList = pattern.split(';'),\n\t\tpositivePattern = patternList[0];\n\tpattern = patternList[(value < 0) ? 1 : 0] || (\"-\" + positivePattern);\n\n\t//TODO: only test against unescaped\n\tif(pattern.indexOf('%') != -1){\n\t\tvalue *= 100;\n\t}else if(pattern.indexOf('\\u2030') != -1){\n\t\tvalue *= 1000; // per mille\n\t}else if(pattern.indexOf('\\u00a4') != -1){\n\t\tgroup = options.customs.currencyGroup || group;//mixins instead?\n\t\tdecimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?\n\t\tpattern = pattern.replace(/\\u00a4{1,3}/, function(match){\n\t\t\tvar prop = [\"symbol\", \"currency\", \"displayName\"][match.length-1];\n\t\t\treturn options[prop] || options.currency || \"\";\n\t\t});\n\t}else if(pattern.indexOf('E') != -1){\n\t\tthrow new Error(\"exponential notation not supported\");\n\t}\n\n\t//TODO: support @ sig figs?\n\tvar numberPatternRE = number._numberPatternRE;\n\tvar numberPattern = positivePattern.match(numberPatternRE);\n\tif(!numberPattern){\n\t\tthrow new Error(\"unable to find a number expression in pattern: \"+pattern);\n\t}\n\tif(options.fractional === false){ options.places = 0; }\n\treturn pattern.replace(numberPatternRE,\n\t\tnumber._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));\n};\n\nnumber.round = function(/*Number*/ value, /*Number?*/ places, /*Number?*/ increment){\n\t// summary:\n\t//\t\tRounds to the nearest value with the given number of decimal places, away from zero\n\t// description:\n\t//\t\tRounds to the nearest value with the given number of decimal places, away from zero if equal.\n\t//\t\tSimilar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by\n\t//\t\tfractional increments also, such as the nearest quarter.\n\t//\t\tNOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.\n\t// value:\n\t//\t\tThe number to round\n\t// places:\n\t//\t\tThe number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.\n\t//\t\tMust be non-negative.\n\t// increment:\n\t//\t\tRounds next place to nearest value of increment/10.  10 by default.\n\t// example:\n\t// |\t>>> number.round(-0.5)\n\t// |\t-1\n\t// |\t>>> number.round(162.295, 2)\n\t// |\t162.29  // note floating point error.  Should be 162.3\n\t// |\t>>> number.round(10.71, 0, 2.5)\n\t// |\t10.75\n\tvar factor = 10 / (increment || 10);\n\treturn (factor * +value).toFixed(places) / factor; // Number\n};\n\nif((0.9).toFixed() == 0){\n\t// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit\n\t// is just after the rounding place and is >=5\n\tvar round = number.round;\n\tnumber.round = function(v, p, m){\n\t\tvar d = Math.pow(10, -p || 0), a = Math.abs(v);\n\t\tif(!v || a >= d){\n\t\t\td = 0;\n\t\t}else{\n\t\t\ta /= d;\n\t\t\tif(a < 0.5 || a >= 0.95){\n\t\t\t\td = 0;\n\t\t\t}\n\t\t}\n\t\treturn round(v, p, m) + (v > 0 ? d : -d);\n\t};\n\n\t// Use \"doc hint\" so the doc parser ignores this new definition of round(), and uses the one above.\n\t/*===== number.round = round; =====*/\n}\n\n/*=====\nnumber.__FormatAbsoluteOptions = declare(null, {\n\t// decimal: String?\n\t//\t\tthe decimal separator\n\t// group: String?\n\t//\t\tthe group separator\n\t// places: Number|String?\n\t//\t\tnumber of decimal places.  the range \"n,m\" will format to m places.\n\t// round: Number?\n\t//\t\t5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\n\t//\t\tmeans don't round.\n});\n=====*/\n\nnumber._formatAbsolute = function(/*Number*/ value, /*String*/ pattern, /*number.__FormatAbsoluteOptions?*/ options){\n\t// summary:\n\t//\t\tApply numeric pattern to absolute value using options. Gives no\n\t//\t\tconsideration to local customs.\n\t// value:\n\t//\t\tthe number to be formatted, ignores sign\n\t// pattern:\n\t//\t\tthe number portion of a pattern (e.g. `#,##0.00`)\n\toptions = options || {};\n\tif(options.places === true){options.places=0;}\n\tif(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit\n\n\tvar patternParts = pattern.split(\".\"),\n\t\tcomma = typeof options.places == \"string\" && options.places.indexOf(\",\"),\n\t\tmaxPlaces = options.places;\n\tif(comma){\n\t\tmaxPlaces = options.places.substring(comma + 1);\n\t}else if(!(maxPlaces >= 0)){\n\t\tmaxPlaces = (patternParts[1] || []).length;\n\t}\n\tif(!(options.round < 0)){\n\t\tvalue = number.round(value, maxPlaces, options.round);\n\t}\n\n\tvar valueParts = String(Math.abs(value)).split(\".\"),\n\t\tfractional = valueParts[1] || \"\";\n\tif(patternParts[1] || options.places){\n\t\tif(comma){\n\t\t\toptions.places = options.places.substring(0, comma);\n\t\t}\n\t\t// Pad fractional with trailing zeros\n\t\tvar pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf(\"0\") + 1);\n\t\tif(pad > fractional.length){\n\t\t\tvalueParts[1] = dstring.pad(fractional, pad, '0', true);\n\t\t}\n\n\t\t// Truncate fractional\n\t\tif(maxPlaces < fractional.length){\n\t\t\tvalueParts[1] = fractional.substr(0, maxPlaces);\n\t\t}\n\t}else{\n\t\tif(valueParts[1]){ valueParts.pop(); }\n\t}\n\n\t// Pad whole with leading zeros\n\tvar patternDigits = patternParts[0].replace(',', '');\n\tpad = patternDigits.indexOf(\"0\");\n\tif(pad != -1){\n\t\tpad = patternDigits.length - pad;\n\t\tif(pad > valueParts[0].length){\n\t\t\tvalueParts[0] = dstring.pad(valueParts[0], pad);\n\t\t}\n\n\t\t// Truncate whole\n\t\tif(patternDigits.indexOf(\"#\") == -1){\n\t\t\tvalueParts[0] = valueParts[0].substr(valueParts[0].length - pad);\n\t\t}\n\t}\n\n\t// Add group separators\n\tvar index = patternParts[0].lastIndexOf(','),\n\t\tgroupSize, groupSize2;\n\tif(index != -1){\n\t\tgroupSize = patternParts[0].length - index - 1;\n\t\tvar remainder = patternParts[0].substr(0, index);\n\t\tindex = remainder.lastIndexOf(',');\n\t\tif(index != -1){\n\t\t\tgroupSize2 = remainder.length - index - 1;\n\t\t}\n\t}\n\tvar pieces = [];\n\tfor(var whole = valueParts[0]; whole;){\n\t\tvar off = whole.length - groupSize;\n\t\tpieces.push((off > 0) ? whole.substr(off) : whole);\n\t\twhole = (off > 0) ? whole.slice(0, off) : \"\";\n\t\tif(groupSize2){\n\t\t\tgroupSize = groupSize2;\n\t\t\tdelete groupSize2;\n\t\t}\n\t}\n\tvalueParts[0] = pieces.reverse().join(options.group || \",\");\n\n\treturn valueParts.join(options.decimal || \".\");\n};\n\n/*=====\nnumber.__RegexpOptions = declare(null, {\n\t// pattern: String?\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\n\t//\t\tlocalization.\n\t// type: String?\n\t//\t\tchoose a format type based on the locale from the following:\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\n\t// locale: String?\n\t//\t\toverride the locale used to determine formatting rules\n\t// strict: Boolean?\n\t//\t\tstrict parsing, false by default.  Strict parsing requires input as produced by the format() method.\n\t//\t\tNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators\n\t// places: Number|String?\n\t//\t\tnumber of decimal places to accept: Infinity, a positive number, or\n\t//\t\ta range \"n,m\".  Defined by pattern or Infinity if pattern not provided.\n});\n=====*/\nnumber.regexp = function(/*number.__RegexpOptions?*/ options){\n\t// summary:\n\t//\t\tBuilds the regular needed to parse a number\n\t// description:\n\t//\t\tReturns regular expression with positive and negative match, group\n\t//\t\tand decimal separators\n\treturn number._parseInfo(options).regexp; // String\n};\n\nnumber._parseInfo = function(/*Object?*/ options){\n\toptions = options || {};\n\tvar locale = i18n.normalizeLocale(options.locale),\n\t\tbundle = i18n.getLocalization(\"dojo.cldr\", \"number\", locale),\n\t\tpattern = options.pattern || bundle[(options.type || \"decimal\") + \"Format\"],\n//TODO: memoize?\n\t\tgroup = bundle.group,\n\t\tdecimal = bundle.decimal,\n\t\tfactor = 1;\n\n\tif(pattern.indexOf('%') != -1){\n\t\tfactor /= 100;\n\t}else if(pattern.indexOf('\\u2030') != -1){\n\t\tfactor /= 1000; // per mille\n\t}else{\n\t\tvar isCurrency = pattern.indexOf('\\u00a4') != -1;\n\t\tif(isCurrency){\n\t\t\tgroup = bundle.currencyGroup || group;\n\t\t\tdecimal = bundle.currencyDecimal || decimal;\n\t\t}\n\t}\n\n\t//TODO: handle quoted escapes\n\tvar patternList = pattern.split(';');\n\tif(patternList.length == 1){\n\t\tpatternList.push(\"-\" + patternList[0]);\n\t}\n\n\tvar re = dregexp.buildGroupRE(patternList, function(pattern){\n\t\tpattern = \"(?:\"+dregexp.escapeString(pattern, '.')+\")\";\n\t\treturn pattern.replace(number._numberPatternRE, function(format){\n\t\t\tvar flags = {\n\t\t\t\tsigned: false,\n\t\t\t\tseparator: options.strict ? group : [group,\"\"],\n\t\t\t\tfractional: options.fractional,\n\t\t\t\tdecimal: decimal,\n\t\t\t\texponent: false\n\t\t\t\t},\n\n\t\t\t\tparts = format.split('.'),\n\t\t\t\tplaces = options.places;\n\n\t\t\t// special condition for percent (factor != 1)\n\t\t\t// allow decimal places even if not specified in pattern\n\t\t\tif(parts.length == 1 && factor != 1){\n\t\t\t    parts[1] = \"###\";\n\t\t\t}\n\t\t\tif(parts.length == 1 || places === 0){\n\t\t\t\tflags.fractional = false;\n\t\t\t}else{\n\t\t\t\tif(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }\n\t\t\t\tif(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified\n\t\t\t\tif(!options.places && (places < parts[1].length)){ places += \",\" + parts[1].length; }\n\t\t\t\tflags.places = places;\n\t\t\t}\n\t\t\tvar groups = parts[0].split(',');\n\t\t\tif(groups.length > 1){\n\t\t\t\tflags.groupSize = groups.pop().length;\n\t\t\t\tif(groups.length > 1){\n\t\t\t\t\tflags.groupSize2 = groups.pop().length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"(\"+number._realNumberRegexp(flags)+\")\";\n\t\t});\n\t}, true);\n\n\tif(isCurrency){\n\t\t// substitute the currency symbol for the placeholder in the pattern\n\t\tre = re.replace(/([\\s\\xa0]*)(\\u00a4{1,3})([\\s\\xa0]*)/g, function(match, before, target, after){\n\t\t\tvar prop = [\"symbol\", \"currency\", \"displayName\"][target.length-1],\n\t\t\t\tsymbol = dregexp.escapeString(options[prop] || options.currency || \"\");\n\t\t\tbefore = before ? \"[\\\\s\\\\xa0]\" : \"\";\n\t\t\tafter = after ? \"[\\\\s\\\\xa0]\" : \"\";\n\t\t\tif(!options.strict){\n\t\t\t\tif(before){before += \"*\";}\n\t\t\t\tif(after){after += \"*\";}\n\t\t\t\treturn \"(?:\"+before+symbol+after+\")?\";\n\t\t\t}\n\t\t\treturn before+symbol+after;\n\t\t});\n\t}\n\n//TODO: substitute localized sign/percent/permille/etc.?\n\n\t// normalize whitespace and return\n\treturn {regexp: re.replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"), group: group, decimal: decimal, factor: factor}; // Object\n};\n\n/*=====\nnumber.__ParseOptions = declare(null, {\n\t// pattern: String?\n\t//\t\toverride [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n\t//\t\twith this string.  Default value is based on locale.  Overriding this property will defeat\n\t//\t\tlocalization.  Literal characters in patterns are not supported.\n\t// type: String?\n\t//\t\tchoose a format type based on the locale from the following:\n\t//\t\tdecimal, scientific (not yet supported), percent, currency. decimal by default.\n\t// locale: String?\n\t//\t\toverride the locale used to determine formatting rules\n\t// strict: Boolean?\n\t//\t\tstrict parsing, false by default.  Strict parsing requires input as produced by the format() method.\n\t//\t\tNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators\n\t// fractional: Boolean|Array?\n\t//\t\tWhether to include the fractional portion, where the number of decimal places are implied by pattern\n\t//\t\tor explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.\n});\n=====*/\nnumber.parse = function(/*String*/ expression, /*number.__ParseOptions?*/ options){\n\t// summary:\n\t//\t\tConvert a properly formatted string to a primitive Number, using\n\t//\t\tlocale-specific settings.\n\t// description:\n\t//\t\tCreate a Number from a string using a known localized pattern.\n\t//\t\tFormatting patterns are chosen appropriate to the locale\n\t//\t\tand follow the syntax described by\n\t//\t\t[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)\n    \t//\t\tNote that literal characters in patterns are not supported.\n\t// expression:\n\t//\t\tA string representation of a Number\n\tvar info = number._parseInfo(options),\n\t\tresults = (new RegExp(\"^\"+info.regexp+\"$\")).exec(expression);\n\tif(!results){\n\t\treturn NaN; //NaN\n\t}\n\tvar absoluteMatch = results[1]; // match for the positive expression\n\tif(!results[1]){\n\t\tif(!results[2]){\n\t\t\treturn NaN; //NaN\n\t\t}\n\t\t// matched the negative pattern\n\t\tabsoluteMatch =results[2];\n\t\tinfo.factor *= -1;\n\t}\n\n\t// Transform it to something Javascript can parse as a number.  Normalize\n\t// decimal point and strip out group separators or alternate forms of whitespace\n\tabsoluteMatch = absoluteMatch.\n\t\treplace(new RegExp(\"[\"+info.group + \"\\\\s\\\\xa0\"+\"]\", \"g\"), \"\").\n\t\treplace(info.decimal, \".\");\n\t// Adjust for negative sign, percent, etc. as necessary\n\treturn absoluteMatch * info.factor; //Number\n};\n\n/*=====\nnumber.__RealNumberRegexpFlags = declare(null, {\n\t// places: Number?\n\t//\t\tThe integer number of decimal places or a range given as \"n,m\".  If\n\t//\t\tnot given, the decimal part is optional and the number of places is\n\t//\t\tunlimited.\n\t// decimal: String?\n\t//\t\tA string for the character used as the decimal point.  Default\n\t//\t\tis \".\".\n\t// fractional: Boolean|Array?\n\t//\t\tWhether decimal places are used.  Can be true, false, or [true,\n\t//\t\tfalse].  Default is [true, false] which means optional.\n\t// exponent: Boolean|Array?\n\t//\t\tExpress in exponential notation.  Can be true, false, or [true,\n\t//\t\tfalse]. Default is [true, false], (i.e. will match if the\n\t//\t\texponential part is present are not).\n\t// eSigned: Boolean|Array?\n\t//\t\tThe leading plus-or-minus sign on the exponent.  Can be true,\n\t//\t\tfalse, or [true, false].  Default is [true, false], (i.e. will\n\t//\t\tmatch if it is signed or unsigned).  flags in regexp.integer can be\n\t//\t\tapplied.\n});\n=====*/\n\nnumber._realNumberRegexp = function(/*__RealNumberRegexpFlags?*/ flags){\n\t// summary:\n\t//\t\tBuilds a regular expression to match a real number in exponential\n\t//\t\tnotation\n\n\t// assign default values to missing parameters\n\tflags = flags || {};\n\t//TODO: use mixin instead?\n\tif(!(\"places\" in flags)){ flags.places = Infinity; }\n\tif(typeof flags.decimal != \"string\"){ flags.decimal = \".\"; }\n\tif(!(\"fractional\" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }\n\tif(!(\"exponent\" in flags)){ flags.exponent = [true, false]; }\n\tif(!(\"eSigned\" in flags)){ flags.eSigned = [true, false]; }\n\n\tvar integerRE = number._integerRegexp(flags),\n\t\tdecimalRE = dregexp.buildGroupRE(flags.fractional,\n\t\tfunction(q){\n\t\t\tvar re = \"\";\n\t\t\tif(q && (flags.places!==0)){\n\t\t\t\tre = \"\\\\\" + flags.decimal;\n\t\t\t\tif(flags.places == Infinity){\n\t\t\t\t\tre = \"(?:\" + re + \"\\\\d+)?\";\n\t\t\t\t}else{\n\t\t\t\t\tre += \"\\\\d{\" + flags.places + \"}\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn re;\n\t\t},\n\t\ttrue\n\t);\n\n\tvar exponentRE = dregexp.buildGroupRE(flags.exponent,\n\t\tfunction(q){\n\t\t\tif(q){ return \"([eE]\" + number._integerRegexp({ signed: flags.eSigned}) + \")\"; }\n\t\t\treturn \"\";\n\t\t}\n\t);\n\n\tvar realRE = integerRE + decimalRE;\n\t// allow for decimals without integers, e.g. .25\n\tif(decimalRE){realRE = \"(?:(?:\"+ realRE + \")|(?:\" + decimalRE + \"))\";}\n\treturn realRE + exponentRE; // String\n};\n\n/*=====\nnumber.__IntegerRegexpFlags = declare(null, {\n\t// signed: Boolean?\n\t//\t\tThe leading plus-or-minus sign. Can be true, false, or `[true,false]`.\n\t//\t\tDefault is `[true, false]`, (i.e. will match if it is signed\n\t//\t\tor unsigned).\n\t// separator: String?\n\t//\t\tThe character used as the thousands separator. Default is no\n\t//\t\tseparator. For more than one symbol use an array, e.g. `[\",\", \"\"]`,\n\t//\t\tmakes ',' optional.\n\t// groupSize: Number?\n\t//\t\tgroup size between separators\n\t// groupSize2: Number?\n\t//\t\tsecond grouping, where separators 2..n have a different interval than the first separator (for India)\n});\n=====*/\n\nnumber._integerRegexp = function(/*number.__IntegerRegexpFlags?*/ flags){\n\t// summary:\n\t//\t\tBuilds a regular expression that matches an integer\n\n\t// assign default values to missing parameters\n\tflags = flags || {};\n\tif(!(\"signed\" in flags)){ flags.signed = [true, false]; }\n\tif(!(\"separator\" in flags)){\n\t\tflags.separator = \"\";\n\t}else if(!(\"groupSize\" in flags)){\n\t\tflags.groupSize = 3;\n\t}\n\n\tvar signRE = dregexp.buildGroupRE(flags.signed,\n\t\tfunction(q){ return q ? \"[-+]\" : \"\"; },\n\t\ttrue\n\t);\n\n\tvar numberRE = dregexp.buildGroupRE(flags.separator,\n\t\tfunction(sep){\n\t\t\tif(!sep){\n\t\t\t\treturn \"(?:\\\\d+)\";\n\t\t\t}\n\n\t\t\tsep = dregexp.escapeString(sep);\n\t\t\tif(sep == \" \"){ sep = \"\\\\s\"; }\n\t\t\telse if(sep == \"\\xa0\"){ sep = \"\\\\s\\\\xa0\"; }\n\n\t\t\tvar grp = flags.groupSize, grp2 = flags.groupSize2;\n\t\t\t//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933\n\t\t\tif(grp2){\n\t\t\t\tvar grp2RE = \"(?:0|[1-9]\\\\d{0,\" + (grp2-1) + \"}(?:[\" + sep + \"]\\\\d{\" + grp2 + \"})*[\" + sep + \"]\\\\d{\" + grp + \"})\";\n\t\t\t\treturn ((grp-grp2) > 0) ? \"(?:\" + grp2RE + \"|(?:0|[1-9]\\\\d{0,\" + (grp-1) + \"}))\" : grp2RE;\n\t\t\t}\n\t\t\treturn \"(?:0|[1-9]\\\\d{0,\" + (grp-1) + \"}(?:[\" + sep + \"]\\\\d{\" + grp + \"})*)\";\n\t\t},\n\t\ttrue\n\t);\n\n\treturn signRE + numberRE; // String\n};\n\nreturn number;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/on.js":"define([\"./has!dom-addeventlistener?:./aspect\", \"./_base/kernel\", \"./sniff\"], function(aspect, dojo, has){\n\n\t\"use strict\";\n\tif(has(\"dom\")){ // check to make sure we are in a browser, this module should work anywhere\n\t\tvar major = window.ScriptEngineMajorVersion;\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() / 10));\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); // TODO: how do we detect this?\n\t\thas.add(\"event-stopimmediatepropagation\", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);\n\t\thas.add(\"event-focusin\", function(global, doc, element){\n\t\t\treturn 'onfocusin' in element;\n\t\t});\n\t}\n\tvar on = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tA function that provides core event listening functionality. With this function\n\t\t//\t\tyou can provide a target, event type, and listener to be notified of\n\t\t//\t\tfuture matching events that are fired.\n\t\t// target: Element|Object\n\t\t//\t\tThis is the target object or DOM element that to receive events from\n\t\t// type: String|Function\n\t\t//\t\tThis is the name of the event to listen for or an extension event type.\n\t\t// listener: Function\n\t\t//\t\tThis is the function that should be called when the event fires.\n\t\t// returns: Object\n\t\t//\t\tAn object with a remove() method that can be used to stop listening for this\n\t\t//\t\tevent.\n\t\t// description:\n\t\t//\t\tTo listen for \"click\" events on a button node, we can do:\n\t\t//\t\t|\tdefine([\"dojo/on\"], function(listen){\n\t\t//\t\t|\t\ton(button, \"click\", clickHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\tEvented JavaScript objects can also have their own events.\n\t\t//\t\t|\tvar obj = new Evented;\n\t\t//\t\t|\ton(obj, \"foo\", fooHandler);\n\t\t//\t\tAnd then we could publish a \"foo\" event:\n\t\t//\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\n\t\t//\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojo/gesture/tap\", function(listen, tap){\n\t\t//\t\t|\t\ton(button, tap, tapHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\t\t//\t\t|\tobj.onfoo({key:\"value\"});\n\t\t//\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\n\n\t\tif(typeof target.on == \"function\" && typeof type != \"function\" && !target.nodeType){\n\t\t\t// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it \n\t\t\t// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the\n\t\t\t// Element prototype \n\t\t\treturn target.on(type, listener);\n\t\t}\n\t\t// delegate to main listener code\n\t\treturn on.parse(target, type, listener, addListener, dontFix, this);\n\t};\n\ton.pausable =  function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but with pausable functionality. The\n\t\t//\t\treturned signal object has pause() and resume() functions. Calling the\n\t\t//\t\tpause() method will cause the listener to not be called for future events. Calling the\n\t\t//\t\tresume() method will cause the listener to again be called for future events.\n\t\tvar paused;\n\t\tvar signal = on(target, type, function(){\n\t\t\tif(!paused){\n\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t}\n\t\t}, dontFix);\n\t\tsignal.pause = function(){\n\t\t\tpaused = true;\n\t\t};\n\t\tsignal.resume = function(){\n\t\t\tpaused = false;\n\t\t};\n\t\treturn signal;\n\t};\n\ton.once = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but will only call the listener once. The \n\t\t//\t\tlistener will be called for the first\n\t\t//\t\tevent that takes place and then listener will automatically be removed.\n\t\tvar signal = on(target, type, function(){\n\t\t\t// remove this listener\n\t\t\tsignal.remove();\n\t\t\t// proceed to call the listener\n\t\t\treturn listener.apply(this, arguments);\n\t\t});\n\t\treturn signal;\n\t};\n\ton.parse = function(target, type, listener, addListener, dontFix, matchesTarget){\n\t\tif(type.call){\n\t\t\t// event handler function\n\t\t\t// on(node, touch.press, touchListener);\n\t\t\treturn type.call(matchesTarget, target, listener);\n\t\t}\n\n\t\tif(type.indexOf(\",\") > -1){\n\t\t\t// we allow comma delimited event names, so you can register for multiple events at once\n\t\t\tvar events = type.split(/\\s*,\\s*/);\n\t\t\tvar handles = [];\n\t\t\tvar i = 0;\n\t\t\tvar eventName;\n\t\t\twhile(eventName = events[i++]){\n\t\t\t\thandles.push(addListener(target, eventName, listener, dontFix, matchesTarget));\n\t\t\t}\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t}\n\t\treturn addListener(target, type, listener, dontFix, matchesTarget);\n\t};\n\tvar touchEvents = /^touch/;\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\n\t\t// event delegation:\n\t\tvar selector = type.match(/(.*):(.*)/);\n\t\t// if we have a selector:event, the last one is interpreted as an event, and we use event delegation\n\t\tif(selector){\n\t\t\ttype = selector[2];\n\t\t\tselector = selector[1];\n\t\t\t// create the extension event for selectors and directly call it\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\n\t\t}\n\t\t// test to see if it a touch event right now, so we don't have to do it every time it fires\n\t\tif(has(\"touch\")){\n\t\t\tif(touchEvents.test(type)){\n\t\t\t\t// touch event, fix it\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\n\t\t\t\t//\"orientationchange\" not supported <= Android 2.1, \n\t\t\t\t//but works through \"resize\" on window\n\t\t\t\ttype = \"resize\"; \n\t\t\t\ttarget = window;\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t} \n\t\t}\n\t\tif(addStopImmediate){\n\t\t\t// add stopImmediatePropagation if it doesn't exist\n\t\t\tlistener = addStopImmediate(listener);\n\t\t}\n\t\t// normal path, the target is |this|\n\t\tif(target.addEventListener){\n\t\t\t// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\n\t\t\t// check for capture conversions\n\t\t\tvar capture = type in captures,\n\t\t\t\tadjustedType = capture ? captures[type] : type;\n\t\t\ttarget.addEventListener(adjustedType, listener, capture);\n\t\t\t// create and return the signal\n\t\t\treturn {\n\t\t\t\tremove: function(){\n\t\t\t\t\ttarget.removeEventListener(adjustedType, listener, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttype = \"on\" + type;\n\t\tif(fixAttach && target.attachEvent){\n\t\t\treturn fixAttach(target, type, listener);\n\t\t}\n\t\tthrow new Error(\"Target must be an event emitter\");\n\t}\n\n\ton.selector = function(selector, eventType, children){\n\t\t// summary:\n\t\t//\t\tCreates a new extension event with event delegation. This is based on\n\t\t//\t\tthe provided event type (can be extension event) that\n\t\t//\t\tonly calls the listener when the CSS selector matches the target of the event.\n\t\t//\n\t\t//\t\tThe application must require() an appropriate level of dojo/query to handle the selector.\n\t\t// selector:\n\t\t//\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\n\t\t// eventType:\n\t\t//\t\tThe event to listen for\n\t\t// children:\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to \n\t\t//\t\ttrue\n\t\t// example:\n\t\t// |\trequire([\"dojo/on\", \"dojo/mouse\", \"dojo/query!css2\"], function(listen, mouse){\n\t\t// |\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\n\t\treturn function(target, listener){\n\t\t\t// if the selector is function, use it to select the node, otherwise use the matches method\n\t\t\tvar matchesTarget = typeof selector == \"function\" ? {matches: selector} : this,\n\t\t\t\tbubble = eventType.bubble;\n\t\t\tfunction select(eventTarget){\n\t\t\t\t// see if we have a valid matchesTarget or default to dojo/query\n\t\t\t\tmatchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;\n\t\t\t\t// there is a selector, so make sure it matches\n\t\t\t\twhile(!matchesTarget.matches(eventTarget, selector, target)){\n\t\t\t\t\tif(eventTarget == target || children === false || !(eventTarget = eventTarget.parentNode) || eventTarget.nodeType != 1){ // intentional assignment\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn eventTarget;\n\t\t\t}\n\t\t\tif(bubble){\n\t\t\t\t// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself\n\t\t\t\treturn on(target, bubble(select), listener);\n\t\t\t}\n\t\t\t// standard event delegation\n\t\t\treturn on(target, eventType, function(event){\n\t\t\t\t// call select to see if we match\n\t\t\t\tvar eventTarget = select(event.target);\n\t\t\t\t// if it matches we call the listener\n\t\t\t\treturn eventTarget && listener.call(eventTarget, event);\n\t\t\t});\n\t\t};\n\t};\n\n\tfunction syntheticPreventDefault(){\n\t\tthis.cancelable = false;\n\t\tthis.defaultPrevented = true;\n\t}\n\tfunction syntheticStopPropagation(){\n\t\tthis.bubbles = false;\n\t}\n\tvar slice = [].slice,\n\t\tsyntheticDispatch = on.emit = function(target, type, event){\n\t\t// summary:\n\t\t//\t\tFires an event on the target object.\n\t\t// target:\n\t\t//\t\tThe target object to fire the event on. This can be a DOM element or a plain \n\t\t//\t\tJS object. If the target is a DOM element, native event emitting mechanisms\n\t\t//\t\tare used when possible.\n\t\t// type:\n\t\t//\t\tThe event type name. You can emulate standard native events like \"click\" and \n\t\t//\t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\n\t\t// event:\n\t\t//\t\tAn object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent \n\t\t//\t\tfor some of the properties. These properties are copied to the event object.\n\t\t//\t\tOf particular importance are the cancelable and bubbles properties. The\n\t\t//\t\tcancelable property indicates whether or not the event has a default action\n\t\t//\t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\n\t\t//\t\tthe event object. The bubbles property indicates whether or not the\n\t\t//\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\n\t\t//\t\ton the target and then each parent successively until the top of the tree\n\t\t//\t\tis reached or stopPropagation() is called. Both bubbles and cancelable \n\t\t//\t\tdefault to false.\n\t\t// returns:\n\t\t//\t\tIf the event is cancelable and the event is not cancelled,\n\t\t//\t\temit will return true. If the event is cancelable and the event is cancelled,\n\t\t//\t\temit will return false.\n\t\t// details:\n\t\t//\t\tNote that this is designed to emit events for listeners registered through\n\t\t//\t\tdojo/on. It should actually work with any event listener except those\n\t\t//\t\tadded through IE's attachEvent (IE8 and below's non-W3C event emitting\n\t\t//\t\tdoesn't support custom event types). It should work with all events registered\n\t\t//\t\tthrough dojo/on. Also note that the emit method does do any default\n\t\t//\t\taction, it only returns a value to indicate if the default action should take\n\t\t//\t\tplace. For example, emitting a keypress event would not cause a character\n\t\t//\t\tto appear in a textbox.\n\t\t// example:\n\t\t//\t\tTo fire our own click event\n\t\t//\t|\trequire([\"dojo/on\", \"dojo/dom\"\n\t\t//\t|\t], function(on, dom){\n\t\t//\t|\t\ton.emit(dom.byId(\"button\"), \"click\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tscreenX: 33,\n\t\t//\t|\t\t\tscreenY: 44\n\t\t//\t|\t\t});\n\t\t//\t\tWe can also fire our own custom events:\n\t\t//\t|\t\ton.emit(dom.byId(\"slider\"), \"slide\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tdirection: \"left-to-right\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\tvar args = slice.call(arguments, 2);\n\t\tvar method = \"on\" + type;\n\t\tif(\"parentNode\" in target){\n\t\t\t// node (or node-like), create event controller methods\n\t\t\tvar newEvent = args[0] = {};\n\t\t\tfor(var i in event){\n\t\t\t\tnewEvent[i] = event[i];\n\t\t\t}\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\n\t\t\tnewEvent.target = target;\n\t\t\tnewEvent.type = type;\n\t\t\tevent = newEvent;\n\t\t}\n\t\tdo{\n\t\t\t// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)\n\t\t\ttarget[method] && target[method].apply(target, args);\n\t\t\t// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\n\t\t}while(event && event.bubbles && (target = target.parentNode));\n\t\treturn event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\n\t};\n\tvar captures = has(\"event-focusin\") ? {} : {focusin: \"focus\", focusout: \"blur\"};\n\tif(!has(\"event-stopimmediatepropagation\")){\n\t\tvar stopImmediatePropagation =function(){\n\t\t\tthis.immediatelyStopped = true;\n\t\t\tthis.modified = true; // mark it as modified so the event will be cached in IE\n\t\t};\n\t\tvar addStopImmediate = function(listener){\n\t\t\treturn function(event){\n\t\t\t\tif(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately\n\t\t\t\t\tevent.stopImmediatePropagation = stopImmediatePropagation;\n\t\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} \n\tif(has(\"dom-addeventlistener\")){\n\t\t// emitter that works with native event handling\n\t\ton.emit = function(target, type, event){\n\t\t\tif(target.dispatchEvent && document.createEvent){\n\t\t\t\t// use the native event emitting mechanism if it is available on the target object\n\t\t\t\t// create a generic event\t\t\t\t\n\t\t\t\t// we could create branch into the different types of event constructors, but \n\t\t\t\t// that would be a lot of extra code, with little benefit that I can see, seems \n\t\t\t\t// best to use the generic constructor and copy properties over, making it \n\t\t\t\t// easy to have events look like the ones created with specific initializers\n\t\t\t\tvar ownerDocument = target.ownerDocument || document;\n\t\t\t\tvar nativeEvent = ownerDocument.createEvent(\"HTMLEvents\");\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\n\t\t\t\t// and copy all our properties over\n\t\t\t\tfor(var i in event){\n\t\t\t\t\tif(!(i in nativeEvent)){\n\t\t\t\t\t\tnativeEvent[i] = event[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\n\t\t\t}\n\t\t\treturn syntheticDispatch.apply(on, arguments); // emit for a non-node\n\t\t};\n\t}else{\n\t\t// no addEventListener, basically old IE event normalization\n\t\ton._fixEvent = function(evt, sender){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes properties on the event object including event\n\t\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\n\t\t\t// evt:\n\t\t\t//\t\tnative event object\n\t\t\t// sender:\n\t\t\t//\t\tnode to treat as \"currentTarget\"\n\t\t\tif(!evt){\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\n\t\t\t\tevt = w.event;\n\t\t\t}\n\t\t\tif(!evt){return evt;}\n\t\t\ttry{\n\t\t\t\tif(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){\n\t\t\t\t\t// should be same event, reuse event object (so it can be augmented);\n\t\t\t\t\t// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below\n\t\t\t\t\tevt = lastEvent;\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\t// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already\n\t\t\t\t// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet\n\t\t\t}\n\t\t\tif(!evt.target){ // check to see if it has been fixed yet\n\t\t\t\tevt.target = evt.srcElement;\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\n\t\t\t\tif(evt.type == \"mouseover\"){\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\n\t\t\t\t}\n\t\t\t\tif(evt.type == \"mouseout\"){\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\n\t\t\t\t}\n\t\t\t\tif(!evt.stopPropagation){\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\n\t\t\t\t\tevt.preventDefault = preventDefault;\n\t\t\t\t}\n\t\t\t\tswitch(evt.type){\n\t\t\t\t\tcase \"keypress\":\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\n\t\t\t\t\t\tif (c==10){\n\t\t\t\t\t\t\t// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tevt.keyCode = 13;\n\t\t\t\t\t\t}else if(c==13||c==27){\n\t\t\t\t\t\t\tc=0; // Mozilla considers ENTER and ESC non-printable\n\t\t\t\t\t\t}else if(c==3){\n\t\t\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Mozilla sets keyCode to 0 when there is a charCode\n\t\t\t\t\t\t// but that stops the event on IE.\n\t\t\t\t\t\tevt.charCode = c;\n\t\t\t\t\t\t_setKeyChar(evt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\n\t\tvar lastEvent, IESignal = function(handle){\n\t\t\tthis.handle = handle;\n\t\t};\n\t\tIESignal.prototype.remove = function(){\n\t\t\tdelete _dojoIEListeners_[this.handle];\n\t\t};\n\t\tvar fixListener = function(listener){\n\t\t\t// this is a minimal function for closing on the previous listener with as few as variables as possible\n\t\t\treturn function(evt){\n\t\t\t\tevt = on._fixEvent(evt, this);\n\t\t\t\tvar result = listener.call(this, evt);\n\t\t\t\tif(evt.modified){\n\t\t\t\t\t// cache the last event and reuse it if we can\n\t\t\t\t\tif(!lastEvent){\n\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tlastEvent = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlastEvent = evt;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t};\n\t\tvar fixAttach = function(target, type, listener){\n\t\t\tlistener = fixListener(listener);\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || \n\t\t\t\t\t\thas(\"jscript\") < 5.8) && \n\t\t\t\t\t!has(\"config-_allow_leaks\")){\n\t\t\t\t// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\n\t\t\t\t// Here we use global redirection to solve the memory leaks\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\n\t\t\t\t\t_dojoIEListeners_ = [];\n\t\t\t\t}\n\t\t\t\tvar emitter = target[type];\n\t\t\t\tif(!emitter || !emitter.listeners){\n\t\t\t\t\tvar oldListener = emitter;\n\t\t\t\t\temitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\n\t\t\t\t\temitter.listeners = [];\n\t\t\t\t\ttarget[type] = emitter;\n\t\t\t\t\temitter.global = this;\n\t\t\t\t\tif(oldListener){\n\t\t\t\t\t\temitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar handle;\n\t\t\t\temitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));\n\t\t\t\treturn new IESignal(handle);\n\t\t\t}\n\t\t\treturn aspect.after(target, type, listener, true);\n\t\t};\n\n\t\tvar _setKeyChar = function(evt){\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\n\t\t};\n\t\t// Called in Event scope\n\t\tvar stopPropagation = function(){\n\t\t\tthis.cancelBubble = true;\n\t\t};\n\t\tvar preventDefault = on._preventDefault = function(){\n\t\t\t// Setting keyCode to 0 is the only way to prevent certain keypresses (namely\n\t\t\t// ctrl-combinations that correspond to menu accelerator keys).\n\t\t\t// Otoh, it prevents upstream listeners from getting this information\n\t\t\t// Try to split the difference here by clobbering keyCode only for ctrl\n\t\t\t// combinations. If you still need to access the key upstream, bubbledKeyCode is\n\t\t\t// provided as a workaround.\n\t\t\tthis.bubbledKeyCode = this.keyCode;\n\t\t\tif(this.ctrlKey){\n\t\t\t\ttry{\n\t\t\t\t\t// squelch errors when keyCode is read-only\n\t\t\t\t\t// (e.g. if keyCode is ctrl or shift)\n\t\t\t\t\tthis.keyCode = 0;\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.defaultPrevented = true;\n\t\t\tthis.returnValue = false;\n\t\t\tthis.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE\n\t\t};\n\t}\n\tif(has(\"touch\")){ \n\t\tvar Event = function(){};\n\t\tvar windowOrientation = window.orientation; \n\t\tvar fixTouchListener = function(listener){ \n\t\t\treturn function(originalEvent){ \n\t\t\t\t//Event normalization(for ontouchxxx and resize): \n\t\t\t\t//1.incorrect e.pageX|pageY in iOS \n\t\t\t\t//2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Android\n\t\t\t\t//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\n\n\t\t\t\t// see if it has already been corrected\n\t\t\t\tvar event = originalEvent.corrected;\n\t\t\t\tif(!event){\n\t\t\t\t\tvar type = originalEvent.type;\n\t\t\t\t\ttry{\n\t\t\t\t\t\tdelete originalEvent.type; // on some JS engines (android), deleting properties make them mutable\n\t\t\t\t\t}catch(e){} \n\t\t\t\t\tif(originalEvent.type){\n\t\t\t\t\t\t// deleting properties doesn't work (older iOS), have to use delegation\n\t\t\t\t\t\tif(has('mozilla')){\n\t\t\t\t\t\t\t// Firefox doesn't like delegated properties, so we have to copy\n\t\t\t\t\t\t\tvar event = {};\n\t\t\t\t\t\t\tfor(var name in originalEvent){\n\t\t\t\t\t\t\t\tevent[name] = originalEvent[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// old iOS branch\n\t\t\t\t\t\t\tEvent.prototype = originalEvent;\n\t\t\t\t\t\t\tvar event = new Event;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have to delegate methods to make them work\n\t\t\t\t\t\tevent.preventDefault = function(){\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tevent.stopPropagation = function(){\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// deletion worked, use property as is\n\t\t\t\t\t\tevent = originalEvent;\n\t\t\t\t\t\tevent.type = type;\n\t\t\t\t\t}\n\t\t\t\t\toriginalEvent.corrected = event;\n\t\t\t\t\tif(type == 'resize'){\n\t\t\t\t\t\tif(windowOrientation == window.orientation){ \n\t\t\t\t\t\t\treturn null;//double tap causes an unexpected 'resize' in Android\n\t\t\t\t\t\t} \n\t\t\t\t\t\twindowOrientation = window.orientation;\n\t\t\t\t\t\tevent.type = \"orientationchange\"; \n\t\t\t\t\t\treturn listener.call(this, event);\n\t\t\t\t\t}\n\t\t\t\t\t// We use the original event and augment, rather than doing an expensive mixin operation\n\t\t\t\t\tif(!(\"rotation\" in event)){ // test to see if it has rotation\n\t\t\t\t\t\tevent.rotation = 0; \n\t\t\t\t\t\tevent.scale = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\n\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\n\t\t\t\t\tfor(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here\n\t\t\t\t\t\tdelete event[i]; // delete it first to make it mutable\n\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, event); \n\t\t\t}; \n\t\t}; \n\t}\n\treturn on;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/OpenAjax.js":"/*******************************************************************************\n * OpenAjax.js\n *\n * Reference implementation of the OpenAjax Hub, as specified by OpenAjax Alliance.\n * Specification is under development at:\n *\n *   http://www.openajax.org/member/wiki/OpenAjax_Hub_Specification\n *\n * Copyright 2006-2007 OpenAjax Alliance\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0 . Unless\n * required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n ******************************************************************************/\n\n// prevent re-definition of the OpenAjax object\nif(!window[\"OpenAjax\"]){\n\tOpenAjax = new function(){\n\t\t// summary:\n\t\t//\t\tthe OpenAjax hub\n\t\t// description:\n\t\t//\t\tsee http://www.openajax.org/member/wiki/OpenAjax_Hub_Specification\n\n\t\tvar libs = {};\n\t\tvar ooh = \"org.openajax.hub.\";\n\n\t\tvar h = {};\n\t\tthis.hub = h;\n\t\th.implementer = \"http://openajax.org\";\n\t\th.implVersion = \"0.6\";\n\t\th.specVersion = \"0.6\";\n\t\th.implExtraData = {};\n\t\th.libraries = libs;\n\n\t\th.registerLibrary = function(prefix, nsURL, version, extra){\n\t\t\tlibs[prefix] = {\n\t\t\t\tprefix: prefix,\n\t\t\t\tnamespaceURI: nsURL,\n\t\t\t\tversion: version,\n\t\t\t\textraData: extra\n\t\t\t};\n\t\t\tthis.publish(ooh+\"registerLibrary\", libs[prefix]);\n\t\t};\n\t\th.unregisterLibrary = function(prefix){\n\t\t\tthis.publish(ooh+\"unregisterLibrary\", libs[prefix]);\n\t\t\tdelete libs[prefix];\n\t\t};\n\n\t\th._subscriptions = { c:{}, s:[] };\n\t\th._cleanup = [];\n\t\th._subIndex = 0;\n\t\th._pubDepth = 0;\n\n\t\th.subscribe = function(name, callback, scope, subscriberData, filter){\n\t\t\tif(!scope){\n\t\t\t\tscope = window;\n\t\t\t}\n\t\t\tvar handle = name + \".\" + this._subIndex;\n\t\t\tvar sub = { scope: scope, cb: callback, fcb: filter, data: subscriberData, sid: this._subIndex++, hdl: handle };\n\t\t\tvar path = name.split(\".\");\n\t \t\tthis._subscribe(this._subscriptions, path, 0, sub);\n\t\t\treturn handle;\n\t\t};\n\n\t\th.publish = function(name, message){\n\t\t\tvar path = name.split(\".\");\n\t\t\tthis._pubDepth++;\n\t\t\tthis._publish(this._subscriptions, path, 0, name, message);\n\t\t\tthis._pubDepth--;\n\t\t\tif((this._cleanup.length > 0) && (this._pubDepth == 0)){\n\t\t\t\tfor(var i = 0; i < this._cleanup.length; i++){\n\t\t\t\t\tthis.unsubscribe(this._cleanup[i].hdl);\n\t\t\t\t}\n\t\t\t\tdelete(this._cleanup);\n\t\t\t\tthis._cleanup = [];\n\t\t\t}\n\t\t};\n\n\t\th.unsubscribe = function(sub){\n\t\t\tvar path = sub.split(\".\");\n\t\t\tvar sid = path.pop();\n\t\t\tthis._unsubscribe(this._subscriptions, path, 0, sid);\n\t\t};\n\t\t\n\t\th._subscribe = function(tree, path, index, sub){\n\t\t\tvar token = path[index];\n\t\t\tif(index == path.length){\n\t\t\t\ttree.s.push(sub);\n\t\t\t}else{\n\t\t\t\tif(typeof tree.c == \"undefined\"){\n\t\t\t\t\ttree.c = {};\n\t\t\t\t}\n\t\t\t\tif(typeof tree.c[token] == \"undefined\"){\n\t\t\t\t\ttree.c[token] = { c: {}, s: [] };\n\t\t\t\t}\n\t\t\t\tthis._subscribe(tree.c[token], path, index + 1, sub);\n\t\t\t}\n\t\t};\n\n\t\th._publish = function(tree, path, index, name, msg){\n\t\t\tif(typeof tree != \"undefined\"){\n\t\t\t\tvar node;\n\t\t\t\tif(index == path.length){\n\t\t\t\t\tnode = tree;\n\t\t\t\t}else{\n\t\t\t\t\tthis._publish(tree.c[path[index]], path, index + 1, name, msg);\n\t\t\t\t\tthis._publish(tree.c[\"*\"], path, index + 1, name, msg);\n\t\t\t\t\tnode = tree.c[\"**\"];\n\t\t\t\t}\n\t\t\t\tif(typeof node != \"undefined\"){\n\t\t\t\t\tvar callbacks = node.s;\n\t\t\t\t\tvar max = callbacks.length;\n\t\t\t\t\tfor(var i = 0; i < max; i++){\n\t\t\t\t\t\tif(callbacks[i].cb){\n\t\t\t\t\t\t\tvar sc = callbacks[i].scope;\n\t\t\t\t\t\t\tvar cb = callbacks[i].cb;\n\t\t\t\t\t\t\tvar fcb = callbacks[i].fcb;\n\t\t\t\t\t\t\tvar d = callbacks[i].data;\n\t\t\t\t\t\t\tif(typeof cb == \"string\"){\n\t\t\t\t\t\t\t\t// get a function object\n\t\t\t\t\t\t\t\tcb = sc[cb];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(typeof fcb == \"string\"){\n\t\t\t\t\t\t\t\t// get a function object\n\t\t\t\t\t\t\t\tfcb = sc[fcb];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif((!fcb) ||\n\t\t\t\t\t\t\t\t(fcb.call(sc, name, msg, d))){\n\t\t\t\t\t\t\t\tcb.call(sc, name, msg, d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\t\n\t\th._unsubscribe = function(tree, path, index, sid){\n\t\t\tif(typeof tree != \"undefined\"){\n\t\t\t\tif(index < path.length){\n\t\t\t\t\tvar childNode = tree.c[path[index]];\n\t\t\t\t\tthis._unsubscribe(childNode, path, index + 1, sid);\n\t\t\t\t\tif(childNode.s.length == 0){\n\t\t\t\t\t\tfor(var x in childNode.c)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tdelete tree.c[path[index]];\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvar callbacks = tree.s;\n\t\t\t\t\tvar max = callbacks.length;\n\t\t\t\t\tfor(var i = 0; i < max; i++){\n\t\t\t\t\t\tif(sid == callbacks[i].sid){\n\t\t\t\t\t\t\tif(this._pubDepth > 0){\n\t\t\t\t\t\t\t\tcallbacks[i].cb = null;\n\t\t\t\t\t\t\t\tthis._cleanup.push(callbacks[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcallbacks.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// The following function is provided for automatic testing purposes.\n\t\t// It is not expected to be deployed in run-time OpenAjax Hub implementations.\n\t\th.reinit = function(){\n\t\t\tfor (var lib in OpenAjax.hub.libraries){\n\t\t\t\tdelete OpenAjax.hub.libraries[lib];\n\t\t\t}\n\t\t\tOpenAjax.hub.registerLibrary(\"OpenAjax\", \"http://openajax.org/hub\", \"0.6\", {});\n\n\t\t\tdelete OpenAjax._subscriptions;\n\t\t\tOpenAjax._subscriptions = {c:{},s:[]};\n\t\t\tdelete OpenAjax._cleanup;\n\t\t\tOpenAjax._cleanup = [];\n\t\t\tOpenAjax._subIndex = 0;\n\t\t\tOpenAjax._pubDepth = 0;\n\t\t};\n\t};\n\n\t// Register the OpenAjax Hub itself as a library.\n\tOpenAjax.hub.registerLibrary(\"OpenAjax\", \"http://openajax.org/hub\", \"0.6\", {});\n\n}\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/parser.js":"define([\n\t\"require\", \"./_base/kernel\", \"./_base/lang\", \"./_base/array\", \"./_base/config\", \"./dom\", \"./_base/window\",\n\t\t\"./_base/url\", \"./aspect\", \"./promise/all\", \"./date/stamp\", \"./Deferred\", \"./has\", \"./query\", \"./on\", \"./ready\"\n], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){\n\n\t// module:\n\t//\t\tdojo/parser\n\n\tnew Date(\"X\"); // workaround for #11279, new Date(\"\") == NaN\n\n\t// data-dojo-props etc. is not restricted to JSON, it can be any javascript\n\tfunction myEval(text){\n\t\treturn eval(\"(\" + text + \")\");\n\t}\n\n\t// Widgets like BorderContainer add properties to _Widget via dojo.extend().\n\t// If BorderContainer is loaded after _Widget's parameter list has been cached,\n\t// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).\n\tvar extendCnt = 0;\n\taspect.after(dlang, \"extend\", function(){\n\t\textendCnt++;\n\t}, true);\n\n\tfunction getNameMap(ctor){\n\t\t// summary:\n\t\t//\t\tReturns map from lowercase name to attribute name in class, ex: {onclick: \"onClick\"}\n\t\tvar map = ctor._nameCaseMap, proto = ctor.prototype;\n\n\t\t// Create the map if it's undefined.\n\t\t// Refresh the map if a superclass was possibly extended with new methods since the map was created.\n\t\tif(!map || map._extendCnt < extendCnt){\n\t\t\tmap = ctor._nameCaseMap = {};\n\t\t\tfor(var name in proto){\n\t\t\t\tif(name.charAt(0) === \"_\"){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t// skip internal properties\n\t\t\t\tmap[name.toLowerCase()] = name;\n\t\t\t}\n\t\t\tmap._extendCnt = extendCnt;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// Map from widget name or list of widget names(ex: \"dijit/form/Button,acme/MyMixin\") to a constructor.\n\tvar _ctorMap = {};\n\n\tfunction getCtor(/*String[]*/ types, /*Function?*/ contextRequire){\n\t\t// summary:\n\t\t//\t\tRetrieves a constructor.  If the types array contains more than one class/MID then the\n\t\t//\t\tsubsequent classes will be mixed into the first class and a unique constructor will be\n\t\t//\t\treturned for that array.\n\n\t\tvar ts = types.join();\n\t\tif(!_ctorMap[ts]){\n\t\t\tvar mixins = [];\n\t\t\tfor(var i = 0, l = types.length; i < l; i++){\n\t\t\t\tvar t = types[i];\n\t\t\t\t// TODO: Consider swapping getObject and require in the future\n\t\t\t\tmixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&\n\t\t\t\t\t(contextRequire ? contextRequire(t) : require(t)))));\n\t\t\t}\n\t\t\tvar ctor = mixins.shift();\n\t\t\t_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;\n\t\t}\n\n\t\treturn _ctorMap[ts];\n\t}\n\n\tvar parser = {\n\t\t// summary:\n\t\t//\t\tThe Dom/Widget parsing package\n\n\t\t_clearCache: function(){\n\t\t\t// summary:\n\t\t\t//\t\tClear cached data.   Used mainly for benchmarking.\n\t\t\textendCnt++;\n\t\t\t_ctorMap = {};\n\t\t},\n\n\t\t_functionFromScript: function(script, attrData){\n\t\t\t// summary:\n\t\t\t//\t\tConvert a `<script type=\"dojo/method\" args=\"a, b, c\"> ... </script>`\n\t\t\t//\t\tinto a function\n\t\t\t// script: DOMNode\n\t\t\t//\t\tThe `<script>` DOMNode\n\t\t\t// attrData: String\n\t\t\t//\t\tFor HTML5 compliance, searches for attrData + \"args\" (typically\n\t\t\t//\t\t\"data-dojo-args\") instead of \"args\"\n\t\t\tvar preamble = \"\",\n\t\t\t\tsuffix = \"\",\n\t\t\t\targsStr = (script.getAttribute(attrData + \"args\") || script.getAttribute(\"args\")),\n\t\t\t\twithStr = script.getAttribute(\"with\");\n\n\t\t\t// Convert any arguments supplied in script tag into an array to be passed to the\n\t\t\tvar fnArgs = (argsStr || \"\").split(/\\s*,\\s*/);\n\n\t\t\tif(withStr && withStr.length){\n\t\t\t\tdarray.forEach(withStr.split(/\\s*,\\s*/), function(part){\n\t\t\t\t\tpreamble += \"with(\" + part + \"){\";\n\t\t\t\t\tsuffix += \"}\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Function(fnArgs, preamble + script.innerHTML + suffix);\n\t\t},\n\n\t\tinstantiate: function(nodes, mixin, options){\n\t\t\t// summary:\n\t\t\t//\t\tTakes array of nodes, and turns them into class instances and\n\t\t\t//\t\tpotentially calls a startup method to allow them to connect with\n\t\t\t//\t\tany children.\n\t\t\t// nodes: Array\n\t\t\t//\t\tArray of DOM nodes\n\t\t\t// mixin: Object?\n\t\t\t//\t\tAn object that will be mixed in with each node in the array.\n\t\t\t//\t\tValues in the mixin will override values in the node, if they\n\t\t\t//\t\texist.\n\t\t\t// options: Object?\n\t\t\t//\t\tAn object used to hold kwArgs for instantiation.\n\t\t\t//\t\tSee parse.options argument for details.\n\t\t\t// returns:\n\t\t\t//\t\tArray of instances.\n\n\t\t\tmixin = mixin || {};\n\t\t\toptions = options || {};\n\n\t\t\tvar dojoType = (options.scope || dojo._scopeName) + \"Type\", // typically \"dojoType\"\n\t\t\t\tattrData = \"data-\" + (options.scope || dojo._scopeName) + \"-\", // typically \"data-dojo-\"\n\t\t\t\tdataDojoType = attrData + \"type\", // typically \"data-dojo-type\"\n\t\t\t\tdataDojoMixins = attrData + \"mixins\";\t\t\t\t\t// typically \"data-dojo-mixins\"\n\n\t\t\tvar list = [];\n\t\t\tdarray.forEach(nodes, function(node){\n\t\t\t\tvar type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);\n\t\t\t\tif(type){\n\t\t\t\t\tvar mixinsValue = node.getAttribute(dataDojoMixins),\n\t\t\t\t\t\ttypes = mixinsValue ? [type].concat(mixinsValue.split(/\\s*,\\s*/)) : [type];\n\n\t\t\t\t\tlist.push({\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\ttypes: types\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Instantiate the nodes and return the list of instances.\n\t\t\treturn this._instantiate(list, mixin, options);\n\t\t},\n\n\t\t_instantiate: function(nodes, mixin, options, returnPromise){\n\t\t\t// summary:\n\t\t\t//\t\tTakes array of objects representing nodes, and turns them into class instances and\n\t\t\t//\t\tpotentially calls a startup method to allow them to connect with\n\t\t\t//\t\tany children.\n\t\t\t// nodes: Array\n\t\t\t//\t\tArray of objects like\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tctor: Function (may be null)\n\t\t\t//\t|\t\t\ttypes: [\"dijit/form/Button\", \"acme/MyMixin\"] (used if ctor not specified)\n\t\t\t//\t|\t\t\tnode: DOMNode,\n\t\t\t//\t|\t\t\tscripts: [ ... ],\t// array of <script type=\"dojo/...\"> children of node\n\t\t\t//\t|\t\t\tinherited: { ... }\t// settings inherited from ancestors like dir, theme, etc.\n\t\t\t//\t|\t\t}\n\t\t\t// mixin: Object\n\t\t\t//\t\tAn object that will be mixed in with each node in the array.\n\t\t\t//\t\tValues in the mixin will override values in the node, if they\n\t\t\t//\t\texist.\n\t\t\t// options: Object\n\t\t\t//\t\tAn options object used to hold kwArgs for instantiation.\n\t\t\t//\t\tSee parse.options argument for details.\n\t\t\t// returnPromise: Boolean\n\t\t\t//\t\tReturn a Promise rather than the instance; supports asynchronous widget creation.\n\t\t\t// returns:\n\t\t\t//\t\tArray of instances, or if returnPromise is true, a promise for array of instances\n\t\t\t//\t\tthat resolves when instances have finished initializing.\n\n\t\t\t// Call widget constructors.   Some may be asynchronous and return promises.\n\t\t\tvar thelist = darray.map(nodes, function(obj){\n\t\t\t\tvar ctor = obj.ctor || getCtor(obj.types, options.contextRequire);\n\t\t\t\t// If we still haven't resolved a ctor, it is fatal now\n\t\t\t\tif(!ctor){\n\t\t\t\t\tthrow new Error(\"Unable to resolve constructor for: '\" + obj.types.join() + \"'\");\n\t\t\t\t}\n\t\t\t\treturn this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);\n\t\t\t}, this);\n\n\t\t\t// After all widget construction finishes, call startup on each top level instance if it makes sense (as for\n\t\t\t// widgets).  Parent widgets will recursively call startup on their (non-top level) children\n\t\t\tfunction onConstruct(thelist){\n\t\t\t\tif(!mixin._started && !options.noStart){\n\t\t\t\t\tdarray.forEach(thelist, function(instance){\n\t\t\t\t\t\tif(typeof instance.startup === \"function\" && !instance._started){\n\t\t\t\t\t\t\tinstance.startup();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn thelist;\n\t\t\t}\n\n\t\t\tif(returnPromise){\n\t\t\t\treturn all(thelist).then(onConstruct);\n\t\t\t}else{\n\t\t\t\t// Back-compat path, remove for 2.0\n\t\t\t\treturn onConstruct(thelist);\n\t\t\t}\n\t\t},\n\n\t\tconstruct: function(ctor, node, mixin, options, scripts, inherited){\n\t\t\t// summary:\n\t\t\t//\t\tCalls new ctor(params, node), where params is the hash of parameters specified on the node,\n\t\t\t//\t\texcluding data-dojo-type and data-dojo-mixins.   Does not call startup().\n\t\t\t// ctor: Function\n\t\t\t//\t\tWidget constructor.\n\t\t\t// node: DOMNode\n\t\t\t//\t\tThis node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.\n\t\t\t// mixin: Object?\n\t\t\t//\t\tAttributes in this object will be passed as parameters to ctor,\n\t\t\t//\t\toverriding attributes specified on the node.\n\t\t\t// options: Object?\n\t\t\t//\t\tAn options object used to hold kwArgs for instantiation.   See parse.options argument for details.\n\t\t\t// scripts: DomNode[]?\n\t\t\t//\t\tArray of `<script type=\"dojo/*\">` DOMNodes.  If not specified, will search for `<script>` tags inside node.\n\t\t\t// inherited: Object?\n\t\t\t//\t\tSettings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.\n\t\t\t// returns:\n\t\t\t//\t\tInstance or Promise for the instance, if markupFactory() itself returned a promise\n\n\t\t\tvar proto = ctor && ctor.prototype;\n\t\t\toptions = options || {};\n\n\t\t\t// Setup hash to hold parameter settings for this widget.\tStart with the parameter\n\t\t\t// settings inherited from ancestors (\"dir\" and \"lang\").\n\t\t\t// Inherited setting may later be overridden by explicit settings on node itself.\n\t\t\tvar params = {};\n\n\t\t\tif(options.defaults){\n\t\t\t\t// settings for the document itself (or whatever subtree is being parsed)\n\t\t\t\tdlang.mixin(params, options.defaults);\n\t\t\t}\n\t\t\tif(inherited){\n\t\t\t\t// settings from dir=rtl or lang=... on a node above this node\n\t\t\t\tdlang.mixin(params, inherited);\n\t\t\t}\n\n\t\t\t// Get list of attributes explicitly listed in the markup\n\t\t\tvar attributes;\n\t\t\tif(has(\"dom-attributes-explicit\")){\n\t\t\t\t// Standard path to get list of user specified attributes\n\t\t\t\tattributes = node.attributes;\n\t\t\t}else if(has(\"dom-attributes-specified-flag\")){\n\t\t\t\t// Special processing needed for IE8, to skip a few faux values in attributes[]\n\t\t\t\tattributes = darray.filter(node.attributes, function(a){\n\t\t\t\t\treturn a.specified;\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes\n\t\t\t\tvar clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),\n\t\t\t\t\tattrs = clone.outerHTML.replace(/=[^\\s\"']+|=\"[^\"]*\"|='[^']*'/g, \"\").replace(/^\\s*<[a-zA-Z0-9]*\\s*/, \"\").replace(/\\s*>.*$/, \"\");\n\n\t\t\t\tattributes = darray.map(attrs.split(/\\s+/), function(name){\n\t\t\t\t\tvar lcName = name.toLowerCase();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t// getAttribute() doesn't work for button.value, returns innerHTML of button.\n\t\t\t\t\t\t// but getAttributeNode().value doesn't work for the form.encType or li.value\n\t\t\t\t\t\tvalue: (node.nodeName == \"LI\" && name == \"value\") || lcName == \"enctype\" ?\n\t\t\t\t\t\t\tnode.getAttribute(lcName) : node.getAttributeNode(lcName).value\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)\n\t\t\t// TODO: remove scope for 2.0\n\t\t\tvar scope = options.scope || dojo._scopeName,\n\t\t\t\tattrData = \"data-\" + scope + \"-\", // typically \"data-dojo-\"\n\t\t\t\thash = {};\n\t\t\tif(scope !== \"dojo\"){\n\t\t\t\thash[attrData + \"props\"] = \"data-dojo-props\";\n\t\t\t\thash[attrData + \"type\"] = \"data-dojo-type\";\n\t\t\t\thash[attrData + \"mixins\"] = \"data-dojo-mixins\";\n\t\t\t\thash[scope + \"type\"] = \"dojoType\";\n\t\t\t\thash[attrData + \"id\"] = \"data-dojo-id\";\n\t\t\t}\n\n\t\t\t// Read in attributes and process them, including data-dojo-props, data-dojo-type,\n\t\t\t// dojoAttachPoint, etc., as well as normal foo=bar attributes.\n\t\t\tvar i = 0, item, funcAttrs = [], jsname, extra;\n\t\t\twhile(item = attributes[i++]){\n\t\t\t\tvar name = item.name,\n\t\t\t\t\tlcName = name.toLowerCase(),\n\t\t\t\t\tvalue = item.value;\n\n\t\t\t\tswitch(hash[lcName] || lcName){\n\t\t\t\t// Already processed, just ignore\n\t\t\t\tcase \"data-dojo-type\":\n\t\t\t\tcase \"dojotype\":\n\t\t\t\tcase \"data-dojo-mixins\":\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings\n\t\t\t\tcase \"data-dojo-props\":\n\t\t\t\t\textra = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// data-dojo-id or jsId. TODO: drop jsId in 2.0\n\t\t\t\tcase \"data-dojo-id\":\n\t\t\t\tcase \"jsid\":\n\t\t\t\t\tjsname = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// For the benefit of _Templated\n\t\t\t\tcase \"data-dojo-attach-point\":\n\t\t\t\tcase \"dojoattachpoint\":\n\t\t\t\t\tparams.dojoAttachPoint = value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"data-dojo-attach-event\":\n\t\t\t\tcase \"dojoattachevent\":\n\t\t\t\t\tparams.dojoAttachEvent = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Special parameter handling needed for IE\n\t\t\t\tcase \"class\":\n\t\t\t\t\tparams[\"class\"] = node.className;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"style\":\n\t\t\t\t\tparams[\"style\"] = node.style && node.style.cssText;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Normal attribute, ex: value=\"123\"\n\n\t\t\t\t\t// Find attribute in widget corresponding to specified name.\n\t\t\t\t\t// May involve case conversion, ex: onclick --> onClick\n\t\t\t\t\tif(!(name in proto)){\n\t\t\t\t\t\tvar map = getNameMap(ctor);\n\t\t\t\t\t\tname = map[lcName] || name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set params[name] to value, doing type conversion\n\t\t\t\t\tif(name in proto){\n\t\t\t\t\t\tswitch(typeof proto[name]){\n\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\t\tparams[name] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\tparams[name] = value.length ? Number(value) : NaN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\t// for checked/disabled value might be \"\" or \"checked\".\t interpret as true.\n\t\t\t\t\t\t\tparams[name] = value.toLowerCase() != \"false\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\t\tif(value === \"\" || value.search(/[^\\w\\.]+/i) != -1){\n\t\t\t\t\t\t\t\t// The user has specified some text for a function like \"return x+5\"\n\t\t\t\t\t\t\t\tparams[name] = new Function(value);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// The user has specified the name of a global function like \"myOnClick\"\n\t\t\t\t\t\t\t\t// or a single word function \"return\"\n\t\t\t\t\t\t\t\tparams[name] = dlang.getObject(value, false) || new Function(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfuncAttrs.push(name);\t// prevent \"double connect\", see #15026\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tvar pVal = proto[name];\n\t\t\t\t\t\t\tparams[name] =\n\t\t\t\t\t\t\t\t(pVal && \"length\" in pVal) ? (value ? value.split(/\\s*,\\s*/) : []) :\t// array\n\t\t\t\t\t\t\t\t\t(pVal instanceof Date) ?\n\t\t\t\t\t\t\t\t\t\t(value == \"\" ? new Date(\"\") :\t// the NaN of dates\n\t\t\t\t\t\t\t\t\t\tvalue == \"now\" ? new Date() :\t// current date\n\t\t\t\t\t\t\t\t\t\tdates.fromISOString(value)) :\n\t\t\t\t\t\t\t\t(pVal instanceof _Url) ? (dojo.baseUrl + value) :\n\t\t\t\t\t\t\t\tmyEval(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparams[name] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove function attributes from DOMNode to prevent \"double connect\" problem, see #15026.\n\t\t\t// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).\n\t\t\tfor(var j = 0; j < funcAttrs.length; j++){\n\t\t\t\tvar lcfname = funcAttrs[j].toLowerCase();\n\t\t\t\tnode.removeAttribute(lcfname);\n\t\t\t\tnode[lcfname] = null;\n\t\t\t}\n\n\t\t\t// Mix things found in data-dojo-props into the params, overriding any direct settings\n\t\t\tif(extra){\n\t\t\t\ttry{\n\t\t\t\t\textra = myEval.call(options.propsThis, \"{\" + extra + \"}\");\n\t\t\t\t\tdlang.mixin(params, extra);\n\t\t\t\t}catch(e){\n\t\t\t\t\t// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?\n\t\t\t\t\tthrow new Error(e.toString() + \" in data-dojo-props='\" + extra + \"'\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Any parameters specified in \"mixin\" override everything else.\n\t\t\tdlang.mixin(params, mixin);\n\n\t\t\t// Get <script> nodes associated with this widget, if they weren't specified explicitly\n\t\t\tif(!scripts){\n\t\t\t\tscripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query(\"> script[type^='dojo/']\", node));\n\t\t\t}\n\n\t\t\t// Process <script type=\"dojo/*\"> script tags\n\t\t\t// <script type=\"dojo/method\" data-dojo-event=\"foo\"> tags are added to params, and passed to\n\t\t\t// the widget on instantiation.\n\t\t\t// <script type=\"dojo/method\"> tags (with no event) are executed after instantiation\n\t\t\t// <script type=\"dojo/connect\" data-dojo-event=\"foo\"> tags are dojo.connected after instantiation,\n\t\t\t// and likewise with <script type=\"dojo/aspect\" data-dojo-method=\"foo\">\n\t\t\t// <script type=\"dojo/watch\" data-dojo-prop=\"foo\"> tags are dojo.watch after instantiation\n\t\t\t// <script type=\"dojo/on\" data-dojo-event=\"foo\"> tags are dojo.on after instantiation\n\t\t\t// note: dojo/* script tags cannot exist in self closing widgets, like <input />\n\t\t\tvar aspects = [],\t// aspects to connect after instantiation\n\t\t\t\tcalls = [],\t\t// functions to call after instantiation\n\t\t\t\twatches = [],  // functions to watch after instantiation\n\t\t\t\tons = []; // functions to on after instantiation\n\n\t\t\tif(scripts){\n\t\t\t\tfor(i = 0; i < scripts.length; i++){\n\t\t\t\t\tvar script = scripts[i];\n\t\t\t\t\tnode.removeChild(script);\n\t\t\t\t\t// FIXME: drop event=\"\" support in 2.0. use data-dojo-event=\"\" instead\n\t\t\t\t\tvar event = (script.getAttribute(attrData + \"event\") || script.getAttribute(\"event\")),\n\t\t\t\t\t\tprop = script.getAttribute(attrData + \"prop\"),\n\t\t\t\t\t\tmethod = script.getAttribute(attrData + \"method\"),\n\t\t\t\t\t\tadvice = script.getAttribute(attrData + \"advice\"),\n\t\t\t\t\t\tscriptType = script.getAttribute(\"type\"),\n\t\t\t\t\t\tnf = this._functionFromScript(script, attrData);\n\t\t\t\t\tif(event){\n\t\t\t\t\t\tif(scriptType == \"dojo/connect\"){\n\t\t\t\t\t\t\taspects.push({ method: event, func: nf });\n\t\t\t\t\t\t}else if(scriptType == \"dojo/on\"){\n\t\t\t\t\t\t\tons.push({ event: event, func: nf });\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// <script type=\"dojo/method\" data-dojo-event=\"foo\">\n\t\t\t\t\t\t\t// TODO for 2.0: use data-dojo-method=\"foo\" instead (also affects dijit/Declaration)\n\t\t\t\t\t\t\tparams[event] = nf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(scriptType == \"dojo/aspect\"){\n\t\t\t\t\t\taspects.push({ method: method, advice: advice, func: nf });\n\t\t\t\t\t}else if(scriptType == \"dojo/watch\"){\n\t\t\t\t\t\twatches.push({ prop: prop, func: nf });\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalls.push(nf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create the instance\n\t\t\tvar markupFactory = ctor.markupFactory || proto.markupFactory;\n\t\t\tvar instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);\n\n\t\t\tfunction onInstantiate(instance){\n\t\t\t\t// map it to the JS namespace if that makes sense\n\t\t\t\tif(jsname){\n\t\t\t\t\tdlang.setObject(jsname, instance);\n\t\t\t\t}\n\n\t\t\t\t// process connections and startup functions\n\t\t\t\tfor(i = 0; i < aspects.length; i++){\n\t\t\t\t\taspect[aspects[i].advice || \"after\"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);\n\t\t\t\t}\n\t\t\t\tfor(i = 0; i < calls.length; i++){\n\t\t\t\t\tcalls[i].call(instance);\n\t\t\t\t}\n\t\t\t\tfor(i = 0; i < watches.length; i++){\n\t\t\t\t\tinstance.watch(watches[i].prop, watches[i].func);\n\t\t\t\t}\n\t\t\t\tfor(i = 0; i < ons.length; i++){\n\t\t\t\t\tdon(instance, ons[i].event, ons[i].func);\n\t\t\t\t}\n\n\t\t\t\treturn instance;\n\t\t\t}\n\n\t\t\tif(instance.then){\n\t\t\t\treturn instance.then(onInstantiate);\n\t\t\t}else{\n\t\t\t\treturn onInstantiate(instance);\n\t\t\t}\n\t\t},\n\n\t\tscan: function(root, options){\n\t\t\t// summary:\n\t\t\t//\t\tScan a DOM tree and return an array of objects representing the DOMNodes\n\t\t\t//\t\tthat need to be turned into widgets.\n\t\t\t// description:\n\t\t\t//\t\tSearch specified node (or document root node) recursively for class instances\n\t\t\t//\t\tand return an array of objects that represent potential widgets to be\n\t\t\t//\t\tinstantiated. Searches for either data-dojo-type=\"MID\" or dojoType=\"MID\" where\n\t\t\t//\t\t\"MID\" is a module ID like \"dijit/form/Button\" or a fully qualified Class name\n\t\t\t//\t\tlike \"dijit/form/Button\".  If the MID is not currently available, scan will\n\t\t\t//\t\tattempt to require() in the module.\n\t\t\t//\n\t\t\t//\t\tSee parser.parse() for details of markup.\n\t\t\t// root: DomNode?\n\t\t\t//\t\tA default starting root node from which to start the parsing. Can be\n\t\t\t//\t\tomitted, defaulting to the entire document. If omitted, the `options`\n\t\t\t//\t\tobject can be passed in this place. If the `options` object has a\n\t\t\t//\t\t`rootNode` member, that is used.\n\t\t\t// options: Object\n\t\t\t//\t\ta kwArgs options object, see parse() for details\n\t\t\t//\n\t\t\t// returns: Promise\n\t\t\t//\t\tA promise that is resolved with the nodes that have been parsed.\n\n\t\t\tvar list = [], // Output List\n\t\t\t\tmids = [], // An array of modules that are not yet loaded\n\t\t\t\tmidsHash = {}; // Used to keep the mids array unique\n\n\t\t\tvar dojoType = (options.scope || dojo._scopeName) + \"Type\", // typically \"dojoType\"\n\t\t\t\tattrData = \"data-\" + (options.scope || dojo._scopeName) + \"-\", // typically \"data-dojo-\"\n\t\t\t\tdataDojoType = attrData + \"type\", // typically \"data-dojo-type\"\n\t\t\t\tdataDojoTextDir = attrData + \"textdir\", // typically \"data-dojo-textdir\"\n\t\t\t\tdataDojoMixins = attrData + \"mixins\";\t\t\t\t\t// typically \"data-dojo-mixins\"\n\n\t\t\t// Info on DOMNode currently being processed\n\t\t\tvar node = root.firstChild;\n\n\t\t\t// Info on parent of DOMNode currently being processed\n\t\t\t//\t- inherited: dir, lang, and textDir setting of parent, or inherited by parent\n\t\t\t//\t- parent: pointer to identical structure for my parent (or null if no parent)\n\t\t\t//\t- scripts: if specified, collects <script type=\"dojo/...\"> type nodes from children\n\t\t\tvar inherited = options.inherited;\n\t\t\tif(!inherited){\n\t\t\t\tfunction findAncestorAttr(node, attr){\n\t\t\t\t\treturn (node.getAttribute && node.getAttribute(attr)) ||\n\t\t\t\t\t\t(node.parentNode && findAncestorAttr(node.parentNode, attr));\n\t\t\t\t}\n\n\t\t\t\tinherited = {\n\t\t\t\t\tdir: findAncestorAttr(root, \"dir\"),\n\t\t\t\t\tlang: findAncestorAttr(root, \"lang\"),\n\t\t\t\t\ttextDir: findAncestorAttr(root, dataDojoTextDir)\n\t\t\t\t};\n\t\t\t\tfor(var key in inherited){\n\t\t\t\t\tif(!inherited[key]){\n\t\t\t\t\t\tdelete inherited[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Metadata about parent node\n\t\t\tvar parent = {\n\t\t\t\tinherited: inherited\n\t\t\t};\n\n\t\t\t// For collecting <script type=\"dojo/...\"> type nodes (when null, we don't need to collect)\n\t\t\tvar scripts;\n\n\t\t\t// when true, only look for <script type=\"dojo/...\"> tags, and don't recurse to children\n\t\t\tvar scriptsOnly;\n\n\t\t\tfunction getEffective(parent){\n\t\t\t\t// summary:\n\t\t\t\t//\t\tGet effective dir, lang, textDir settings for specified obj\n\t\t\t\t//\t\t(matching \"parent\" object structure above), and do caching.\n\t\t\t\t//\t\tTake care not to return null entries.\n\t\t\t\tif(!parent.inherited){\n\t\t\t\t\tparent.inherited = {};\n\t\t\t\t\tvar node = parent.node,\n\t\t\t\t\t\tgrandparent = getEffective(parent.parent);\n\t\t\t\t\tvar inherited = {\n\t\t\t\t\t\tdir: node.getAttribute(\"dir\") || grandparent.dir,\n\t\t\t\t\t\tlang: node.getAttribute(\"lang\") || grandparent.lang,\n\t\t\t\t\t\ttextDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir\n\t\t\t\t\t};\n\t\t\t\t\tfor(var key in inherited){\n\t\t\t\t\t\tif(inherited[key]){\n\t\t\t\t\t\t\tparent.inherited[key] = inherited[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn parent.inherited;\n\t\t\t}\n\n\t\t\t// DFS on DOM tree, collecting nodes with data-dojo-type specified.\n\t\t\twhile(true){\n\t\t\t\tif(!node){\n\t\t\t\t\t// Finished this level, continue to parent's next sibling\n\t\t\t\t\tif(!parent || !parent.node){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent.node.nextSibling;\n\t\t\t\t\tscriptsOnly = false;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\tscripts = parent.scripts;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(node.nodeType != 1){\n\t\t\t\t\t// Text or comment node, skip to next sibling\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(scripts && node.nodeName.toLowerCase() == \"script\"){\n\t\t\t\t\t// Save <script type=\"dojo/...\"> for parent, then continue to next sibling\n\t\t\t\t\ttype = node.getAttribute(\"type\");\n\t\t\t\t\tif(type && /^dojo\\/\\w/i.test(type)){\n\t\t\t\t\t\tscripts.push(node);\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(scriptsOnly){\n\t\t\t\t\t// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't\n\t\t\t\t\t// continue further analysis of the node and will continue to the next sibling\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check for data-dojo-type attribute, fallback to backward compatible dojoType\n\t\t\t\t// TODO: Remove dojoType in 2.0\n\t\t\t\tvar type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);\n\n\t\t\t\t// Short circuit for leaf nodes containing nothing [but text]\n\t\t\t\tvar firstChild = node.firstChild;\n\t\t\t\tif(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Meta data about current node\n\t\t\t\tvar current;\n\n\t\t\t\tvar ctor = null;\n\t\t\t\tif(type){\n\t\t\t\t\t// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.\n\t\t\t\t\tvar mixinsValue = node.getAttribute(dataDojoMixins),\n\t\t\t\t\t\ttypes = mixinsValue ? [type].concat(mixinsValue.split(/\\s*,\\s*/)) : [type];\n\n\t\t\t\t\t// Note: won't find classes declared via dojo/Declaration or any modules that haven't been\n\t\t\t\t\t// loaded yet so use try/catch to avoid throw from require()\n\t\t\t\t\ttry{\n\t\t\t\t\t\tctor = getCtor(types, options.contextRequire);\n\t\t\t\t\t}catch(e){}\n\n\t\t\t\t\t// If the constructor was not found, check to see if it has modules that can be loaded\n\t\t\t\t\tif(!ctor){\n\t\t\t\t\t\tdarray.forEach(types, function(t){\n\t\t\t\t\t\t\tif(~t.indexOf('/') && !midsHash[t]){\n\t\t\t\t\t\t\t\t// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.\n\t\t\t\t\t\t\t\tmidsHash[t] = true;\n\t\t\t\t\t\t\t\tmids[mids.length] = t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tvar childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children\n\n\t\t\t\t\t// Setup meta data about this widget node, and save it to list of nodes to instantiate\n\t\t\t\t\tcurrent = {\n\t\t\t\t\t\ttypes: types,\n\t\t\t\t\t\tctor: ctor,\n\t\t\t\t\t\tparent: parent,\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\tscripts: childScripts\n\t\t\t\t\t};\n\t\t\t\t\tcurrent.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited\n\t\t\t\t\tlist.push(current);\n\t\t\t\t}else{\n\t\t\t\t\t// Meta data about this non-widget node\n\t\t\t\t\tcurrent = {\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\tscripts: scripts,\n\t\t\t\t\t\tparent: parent\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Recurse, collecting <script type=\"dojo/...\"> children, and also looking for\n\t\t\t\t// descendant nodes with dojoType specified (unless the widget has the stopParser flag).\n\t\t\t\t// When finished with children, go to my next sibling.\n\t\t\t\tscripts = childScripts;\n\t\t\t\tscriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));\n\t\t\t\tparent = current;\n\t\t\t\tnode = firstChild;\n\t\t\t}\n\n\t\t\tvar d = new Deferred();\n\n\t\t\t// If there are modules to load then require them in\n\t\t\tif(mids.length){\n\t\t\t\t// Warn that there are modules being auto-required\n\t\t\t\tif(has(\"dojo-debug-messages\")){\n\t\t\t\t\tconsole.warn(\"WARNING: Modules being Auto-Required: \" + mids.join(\", \"));\n\t\t\t\t}\n\t\t\t\tvar r = options.contextRequire || require;\n\t\t\t\tr(mids, function(){\n\t\t\t\t\t// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't\n\t\t\t\t\t// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to\n\t\t\t\t\t// auto-require of a module like ContentPane.   Assumes list is in DFS order.\n\t\t\t\t\td.resolve(darray.filter(list, function(widget){\n\t\t\t\t\t\tif(!widget.ctor){\n\t\t\t\t\t\t\t// Attempt to find the constructor again.   Still won't find classes defined via\n\t\t\t\t\t\t\t// dijit/Declaration so need to try/catch.\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\twidget.ctor = getCtor(widget.types, options.contextRequire);\n\t\t\t\t\t\t\t}catch(e){}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get the parent widget\n\t\t\t\t\t\tvar parent = widget.parent;\n\t\t\t\t\t\twhile(parent && !parent.types){\n\t\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Return false if this node should be skipped due to stopParser on an ancestor.\n\t\t\t\t\t\t// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before\n\t\t\t\t\t\t// trying to compute widget.instantiate.\n\t\t\t\t\t\tvar proto = widget.ctor && widget.ctor.prototype;\n\t\t\t\t\t\twidget.instantiateChildren = !(proto && proto.stopParser && !(options.template));\n\t\t\t\t\t\twidget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);\n\t\t\t\t\t\treturn widget.instantiate;\n\t\t\t\t\t}));\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for\n\t\t\t\t// efficiency, to avoid running the require() and the callback code above.\n\t\t\t\td.resolve(list);\n\t\t\t}\n\n\t\t\t// Return the promise\n\t\t\treturn d.promise;\n\t\t},\n\n\t\t_require: function(/*DOMNode*/ script, /*Object?*/ options){\n\t\t\t// summary:\n\t\t\t//\t\tHelper for _scanAMD().  Takes a `<script type=dojo/require>bar: \"acme/bar\", ...</script>` node,\n\t\t\t//\t\tcalls require() to load the specified modules and (asynchronously) assign them to the specified global\n\t\t\t//\t\tvariables, and returns a Promise for when that operation completes.\n\t\t\t//\n\t\t\t//\t\tIn the example above, it is effectively doing a require([\"acme/bar\", ...], function(a){ bar = a; }).\n\n\t\t\tvar hash = myEval(\"{\" + script.innerHTML + \"}\"), // can't use dojo/json::parse() because maybe no quotes\n\t\t\t\tvars = [],\n\t\t\t\tmids = [],\n\t\t\t\td = new Deferred();\n\n\t\t\tvar contextRequire = (options && options.contextRequire) || require;\n\n\t\t\tfor(var name in hash){\n\t\t\t\tvars.push(name);\n\t\t\t\tmids.push(hash[name]);\n\t\t\t}\n\n\t\t\tcontextRequire(mids, function(){\n\t\t\t\tfor(var i = 0; i < vars.length; i++){\n\t\t\t\t\tdlang.setObject(vars[i], arguments[i]);\n\t\t\t\t}\n\t\t\t\td.resolve(arguments);\n\t\t\t});\n\n\t\t\treturn d.promise;\n\t\t},\n\n\t\t_scanAmd: function(root, options){\n\t\t\t// summary:\n\t\t\t//\t\tScans the DOM for any declarative requires and returns their values.\n\t\t\t// description:\n\t\t\t//\t\tLooks for `<script type=dojo/require>bar: \"acme/bar\", ...</script>` node, calls require() to load the\n\t\t\t//\t\tspecified modules and (asynchronously) assign them to the specified global variables,\n\t\t\t//\t\tand returns a Promise for when those operations complete.\n\t\t\t// root: DomNode\n\t\t\t//\t\tThe node to base the scan from.\n\t\t\t// options: Object?\n\t\t\t//\t\ta kwArgs options object, see parse() for details\n\n\t\t\t// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.\n\t\t\tvar deferred = new Deferred(),\n\t\t\t\tpromise = deferred.promise;\n\t\t\tdeferred.resolve(true);\n\n\t\t\tvar self = this;\n\t\t\tquery(\"script[type='dojo/require']\", root).forEach(function(node){\n\t\t\t\t// Fire off require() call for specified modules.  Chain this require to fire after\n\t\t\t\t// any previous requires complete, so that layers can be loaded before individual module require()'s fire.\n\t\t\t\tpromise = promise.then(function(){\n\t\t\t\t\treturn self._require(node, options);\n\t\t\t\t});\n\n\t\t\t\t// Remove from DOM so it isn't seen again\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t});\n\n\t\t\treturn promise;\n\t\t},\n\n\t\tparse: function(rootNode, options){\n\t\t\t// summary:\n\t\t\t//\t\tScan the DOM for class instances, and instantiate them.\n\t\t\t// description:\n\t\t\t//\t\tSearch specified node (or root node) recursively for class instances,\n\t\t\t//\t\tand instantiate them. Searches for either data-dojo-type=\"Class\" or\n\t\t\t//\t\tdojoType=\"Class\" where \"Class\" is a a fully qualified class name,\n\t\t\t//\t\tlike `dijit/form/Button`\n\t\t\t//\n\t\t\t//\t\tUsing `data-dojo-type`:\n\t\t\t//\t\tAttributes using can be mixed into the parameters used to instantiate the\n\t\t\t//\t\tClass by using a `data-dojo-props` attribute on the node being converted.\n\t\t\t//\t\t`data-dojo-props` should be a string attribute to be converted from JSON.\n\t\t\t//\n\t\t\t//\t\tUsing `dojoType`:\n\t\t\t//\t\tAttributes are read from the original domNode and converted to appropriate\n\t\t\t//\t\ttypes by looking up the Class prototype values. This is the default behavior\n\t\t\t//\t\tfrom Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will\n\t\t\t//\t\tgo away in Dojo 2.0.\n\t\t\t// rootNode: DomNode?\n\t\t\t//\t\tA default starting root node from which to start the parsing. Can be\n\t\t\t//\t\tomitted, defaulting to the entire document. If omitted, the `options`\n\t\t\t//\t\tobject can be passed in this place. If the `options` object has a\n\t\t\t//\t\t`rootNode` member, that is used.\n\t\t\t// options: Object?\n\t\t\t//\t\tA hash of options.\n\t\t\t//\n\t\t\t//\t\t- noStart: Boolean?:\n\t\t\t//\t\t\twhen set will prevent the parser from calling .startup()\n\t\t\t//\t\t\twhen locating the nodes.\n\t\t\t//\t\t- rootNode: DomNode?:\n\t\t\t//\t\t\tidentical to the function's `rootNode` argument, though\n\t\t\t//\t\t\tallowed to be passed in via this `options object.\n\t\t\t//\t\t- template: Boolean:\n\t\t\t//\t\t\tIf true, ignores ContentPane's stopParser flag and parses contents inside of\n\t\t\t//\t\t\ta ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes\n\t\t\t//\t\t\tnested inside the ContentPane to work.\n\t\t\t//\t\t- inherited: Object:\n\t\t\t//\t\t\tHash possibly containing dir and lang settings to be applied to\n\t\t\t//\t\t\tparsed widgets, unless there's another setting on a sub-node that overrides\n\t\t\t//\t\t- scope: String:\n\t\t\t//\t\t\tRoot for attribute names to search for.   If scopeName is dojo,\n\t\t\t//\t\t\twill search for data-dojo-type (or dojoType).   For backwards compatibility\n\t\t\t//\t\t\treasons defaults to dojo._scopeName (which is \"dojo\" except when\n\t\t\t//\t\t\tmulti-version support is used, when it will be something like dojo16, dojo20, etc.)\n\t\t\t//\t\t- propsThis: Object:\n\t\t\t//\t\t\tIf specified, \"this\" referenced from data-dojo-props will refer to propsThis.\n\t\t\t//\t\t\tIntended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`\n\t\t\t//\t\t- contextRequire: Function:\n\t\t\t//\t\t\tIf specified, this require is utilised for looking resolving modules instead of the\n\t\t\t//\t\t\t`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of\n\t\t\t//\t\t\t`dijit._WidgetsInTemplateMixin`.\n\t\t\t// returns: Mixed\n\t\t\t//\t\tReturns a blended object that is an array of the instantiated objects, but also can include\n\t\t\t//\t\ta promise that is resolved with the instantiated objects.  This is done for backwards\n\t\t\t//\t\tcompatibility.  If the parser auto-requires modules, it will always behave in a promise\n\t\t\t//\t\tfashion and `parser.parse().then(function(instances){...})` should be used.\n\t\t\t// example:\n\t\t\t//\t\tParse all widgets on a page:\n\t\t\t//\t|\t\tparser.parse();\n\t\t\t// example:\n\t\t\t//\t\tParse all classes within the node with id=\"foo\"\n\t\t\t//\t|\t\tparser.parse(dojo.byId('foo'));\n\t\t\t// example:\n\t\t\t//\t\tParse all classes in a page, but do not call .startup() on any\n\t\t\t//\t\tchild\n\t\t\t//\t|\t\tparser.parse({ noStart: true })\n\t\t\t// example:\n\t\t\t//\t\tParse all classes in a node, but do not call .startup()\n\t\t\t//\t|\t\tparser.parse(someNode, { noStart:true });\n\t\t\t//\t|\t\t// or\n\t\t\t//\t|\t\tparser.parse({ noStart:true, rootNode: someNode });\n\n\t\t\t// determine the root node and options based on the passed arguments.\n\t\t\tvar root;\n\t\t\tif(!options && rootNode && rootNode.rootNode){\n\t\t\t\toptions = rootNode;\n\t\t\t\troot = options.rootNode;\n\t\t\t}else if(rootNode && dlang.isObject(rootNode) && !(\"nodeType\" in rootNode)){\n\t\t\t\toptions = rootNode;\n\t\t\t}else{\n\t\t\t\troot = rootNode;\n\t\t\t}\n\t\t\troot = root ? dom.byId(root) : dwindow.body();\n\n\t\t\toptions = options || {};\n\n\t\t\tvar mixin = options.template ? { template: true } : {},\n\t\t\t\tinstances = [],\n\t\t\t\tself = this;\n\n\t\t\t// First scan for any <script type=dojo/require> nodes, and execute.\n\t\t\t// Then scan for all nodes with data-dojo-type, and load any unloaded modules.\n\t\t\t// Then build the object instances.  Add instances to already existing (but empty) instances[] array,\n\t\t\t// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors\n\t\t\t// that occur during the parse().\n\t\t\tvar p =\n\t\t\t\tthis._scanAmd(root, options).then(function(){\n\t\t\t\t\treturn self.scan(root, options);\n\t\t\t\t}).then(function(parsedNodes){\n\t\t\t\t\treturn self._instantiate(parsedNodes, mixin, options, true);\n\t\t\t\t}).then(function(_instances){\n\t\t\t\t\t// Copy the instances into the instances[] array we declared above, and are accessing as\n\t\t\t\t\t// our return value.\n\t\t\t\t\treturn instances = instances.concat(_instances);\n\t\t\t\t}).otherwise(function(e){\n\t\t\t\t\t// TODO Modify to follow better pattern for promise error management when available\n\t\t\t\t\tconsole.error(\"dojo/parser::parse() error\", e);\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\n\t\t\t// Blend the array with the promise\n\t\t\tdlang.mixin(instances, p);\n\t\t\treturn instances;\n\t\t}\n\t};\n\n\tif(has(\"extend-dojo\")){\n\t\tdojo.parser = parser;\n\t}\n\n\t// Register the parser callback. It should be the first callback\n\t// after the a11y test.\n\tif(config.parseOnLoad){\n\t\tready(100, parser, \"parse\");\n\t}\n\n\treturn parser;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/query.js":"define([\"./_base/kernel\", \"./has\", \"./dom\", \"./on\", \"./_base/array\", \"./_base/lang\", \"./selector/_loader\", \"./selector/_loader!default\"],\n\tfunction(dojo, has, dom, on, array, lang, loader, defaultEngine){\n\n\t\"use strict\";\n\n\thas.add(\"array-extensible\", function(){\n\t\t// test to see if we can extend an array (not supported in old IE)\n\t\treturn lang.delegate([], {length: 1}).length == 1 && !has(\"bug-for-in-skips-shadowed\");\n\t});\n\t\n\tvar ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;\n\n\tvar tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){\n\t\t// summary:\n\t\t//\t\tdecorate an array to make it look like a `dojo/NodeList`.\n\t\t// a:\n\t\t//\t\tArray of nodes to decorate.\n\t\t// parent:\n\t\t//\t\tAn optional parent NodeList that generated the current\n\t\t//\t\tlist of nodes. Used to call _stash() so the parent NodeList\n\t\t//\t\tcan be accessed via end() later.\n\t\t// NodeListCtor:\n\t\t//\t\tAn optional constructor function to use for any\n\t\t//\t\tnew NodeList calls. This allows a certain chain of\n\t\t//\t\tNodeList calls to use a different object than dojo/NodeList.\n\t\tvar nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);\n\t\treturn parent ? nodeList._stash(parent) : nodeList;\n\t};\n\n\tvar loopBody = function(f, a, o){\n\t\ta = [0].concat(aps.call(a, 0));\n\t\to = o || dojo.global;\n\t\treturn function(node){\n\t\t\ta[0] = node;\n\t\t\treturn f.apply(o, a);\n\t\t};\n\t};\n\n\t// adapters\n\n\tvar adaptAsForEach = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the forEach-type\n\t\t//\t\tactions. The initial object is returned from the specialized\n\t\t//\t\tfunction.\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\tthis.forEach(loopBody(f, arguments, o));\n\t\t\treturn this;\t// Object\n\t\t};\n\t};\n\n\tvar adaptAsMap = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the map-type\n\t\t//\t\tactions. The return is a new array of values, as via `dojo/_base/array.map`\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\treturn this.map(loopBody(f, arguments, o));\n\t\t};\n\t};\n\n\tvar adaptAsFilter = function(f, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the filter-type actions\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// o: Object?\n\t\t//\t\tan optional context for f\n\t\treturn function(){\n\t\t\treturn this.filter(loopBody(f, arguments, o));\n\t\t};\n\t};\n\n\tvar adaptWithCondition = function(f, g, o){\n\t\t// summary:\n\t\t//\t\tadapts a single node function to be used in the map-type\n\t\t//\t\tactions, behaves like forEach() or map() depending on arguments\n\t\t// f: Function\n\t\t//\t\ta function to adapt\n\t\t// g: Function\n\t\t//\t\ta condition function, if true runs as map(), otherwise runs as forEach()\n\t\t// o: Object?\n\t\t//\t\tan optional context for f and g\n\t\treturn function(){\n\t\t\tvar a = arguments, body = loopBody(f, a, o);\n\t\t\tif(g.call(o || dojo.global, a)){\n\t\t\t\treturn this.map(body);\t// self\n\t\t\t}\n\t\t\tthis.forEach(body);\n\t\t\treturn this;\t// self\n\t\t};\n\t};\n\n\tvar NodeList = function(array){\n\t\t// summary:\n\t\t//\t\tArray-like object which adds syntactic\n\t\t//\t\tsugar for chaining, common iteration operations, animation, and\n\t\t//\t\tnode manipulation. NodeLists are most often returned as the\n\t\t//\t\tresult of dojo/query() calls.\n\t\t// description:\n\t\t//\t\tNodeList instances provide many utilities that reflect\n\t\t//\t\tcore Dojo APIs for Array iteration and manipulation, DOM\n\t\t//\t\tmanipulation, and event handling. Instead of needing to dig up\n\t\t//\t\tfunctions in the dojo package, NodeLists generally make the\n\t\t//\t\tfull power of Dojo available for DOM manipulation tasks in a\n\t\t//\t\tsimple, chainable way.\n\t\t// example:\n\t\t//\t\tcreate a node list from a node\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/dom\"\n\t\t//\t\t|\t], function(query, dom){\n\t\t//\t\t|\t\tquery.NodeList(dom.byId(\"foo\"));\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tget a NodeList from a CSS query and iterate on it\n\t\t//\t\t|\trequire([\"dojo/on\", \"dojo/dom\"\n\t\t//\t\t|\t], function(on, dom){\n\t\t//\t\t|\t\tvar l = query(\".thinger\");\n\t\t//\t\t|\t\tl.forEach(function(node, index, nodeList){\n\t\t//\t\t|\t\t\tconsole.log(index, node.innerHTML);\n\t\t//\t\t|\t\t});\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tuse native and Dojo-provided array methods to manipulate a\n\t\t//\t\tNodeList without needing to use dojo.* functions explicitly:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/dom-construct\", \"dojo/dom\"\n\t\t//\t\t|\t], function(query, domConstruct, dom){\n\t\t//\t\t|\t\tvar l = query(\".thinger\");\n\t\t//\t\t|\t\t// since NodeLists are real arrays, they have a length\n\t\t//\t\t|\t\t// property that is both readable and writable and\n\t\t//\t\t|\t\t// push/pop/shift/unshift methods\n\t\t//\t\t|\t\tconsole.log(l.length);\n\t\t//\t\t|\t\tl.push(domConstruct.create(\"span\"));\n\t\t//\t\t|\n\t\t//\t\t|\t\t// dojo's normalized array methods work too:\n\t\t//\t\t|\t\tconsole.log( l.indexOf(dom.byId(\"foo\")) );\n\t\t//\t\t|\t\t// ...including the special \"function as string\" shorthand\n\t\t//\t\t|\t\tconsole.log( l.every(\"item.nodeType == 1\") );\n\t\t//\t\t|\n\t\t//\t\t|\t\t// NodeLists can be [..] indexed, or you can use the at()\n\t\t//\t\t|\t\t// function to get specific items wrapped in a new NodeList:\n\t\t//\t\t|\t\tvar node = l[3]; // the 4th element\n\t\t//\t\t|\t\tvar newList = l.at(1, 3); // the 2nd and 4th elements\n\t\t//\t\t|\t});\n\t\t// example:\n\t\t//\t\tchainability is a key advantage of NodeLists:\n\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t//\t\t|\t], function(query){\n\t\t//\t\t|\t\tquery(\".thinger\")\n\t\t//\t\t|\t\t\t.onclick(function(e){ /* ... */ })\n\t\t//\t\t|\t\t\t.at(1, 3, 8) // get a subset\n\t\t//\t\t|\t\t\t\t.style(\"padding\", \"5px\")\n\t\t//\t\t|\t\t\t\t.forEach(console.log);\n\t\t//\t\t|\t});\n\n\t\tvar isNew = this instanceof nl && has(\"array-extensible\");\n\t\tif(typeof array == \"number\"){\n\t\t\tarray = Array(array);\n\t\t}\n\t\tvar nodeArray = (array && \"length\" in array) ? array : arguments;\n\t\tif(isNew || !nodeArray.sort){\n\t\t\t// make sure it's a real array before we pass it on to be wrapped \n\t\t\tvar target = isNew ? this : [],\n\t\t\t\tl = target.length = nodeArray.length;\n\t\t\tfor(var i = 0; i < l; i++){\n\t\t\t\ttarget[i] = nodeArray[i];\n\t\t\t}\n\t\t\tif(isNew){\n\t\t\t\t// called with new operator, this means we are going to use this instance and push\n\t\t\t\t// the nodes on to it. This is usually much faster since the NodeList properties\n\t\t\t\t//\tdon't need to be copied (unless the list of nodes is extremely large).\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tnodeArray = target;\n\t\t}\n\t\t// called without new operator, use a real array and copy prototype properties,\n\t\t// this is slower and exists for back-compat. Should be removed in 2.0.\n\t\tlang._mixin(nodeArray, nlp);\n\t\tnodeArray._NodeListCtor = function(array){\n\t\t\t// call without new operator to preserve back-compat behavior\n\t\t\treturn nl(array);\n\t\t};\n\t\treturn nodeArray;\n\t};\n\t\n\tvar nl = NodeList, nlp = nl.prototype = \n\t\thas(\"array-extensible\") ? [] : {};// extend an array if it is extensible\n\n\t// expose adapters and the wrapper as private functions\n\n\tnl._wrap = nlp._wrap = tnl;\n\tnl._adaptAsMap = adaptAsMap;\n\tnl._adaptAsForEach = adaptAsForEach;\n\tnl._adaptAsFilter  = adaptAsFilter;\n\tnl._adaptWithCondition = adaptWithCondition;\n\n\t// mass assignment\n\n\t// add array redirectors\n\tforEach([\"slice\", \"splice\"], function(name){\n\t\tvar f = ap[name];\n\t\t//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.\n\t\t// CANNOT apply ._stash()/end() to splice since it currently modifies\n\t\t// the existing this array -- it would break backward compatibility if we copy the array before\n\t\t// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.\n\t\tnlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == \"slice\" ? this : null); };\n\t});\n\t// concat should be here but some browsers with native NodeList have problems with it\n\n\t// add array.js redirectors\n\tforEach([\"indexOf\", \"lastIndexOf\", \"every\", \"some\"], function(name){\n\t\tvar f = array[name];\n\t\tnlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };\n\t});\n\n\tlang.extend(NodeList, {\n\t\t// copy the constructors\n\t\tconstructor: nl,\n\t\t_NodeListCtor: nl,\n\t\ttoString: function(){\n\t\t\t// Array.prototype.toString can't be applied to objects, so we use join\n\t\t\treturn this.join(\",\");\n\t\t},\n\t\t_stash: function(parent){\n\t\t\t// summary:\n\t\t\t//\t\tprivate function to hold to a parent NodeList. end() to return the parent NodeList.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tHow to make a `dojo/NodeList` method that only returns the third node in\n\t\t\t//\t\tthe dojo/NodeList but allows access to the original NodeList by using this._stash:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/_base/lang\", \"dojo/NodeList\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query, lang){\n\t\t\t//\t|\t\tlang.extend(NodeList, {\n\t\t\t//\t|\t\t\tthird: function(){\n\t\t\t//\t|\t\t\t\tvar newNodeList = NodeList(this[2]);\n\t\t\t//\t|\t\t\t\treturn newNodeList._stash(this);\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t\t// then see how _stash applies a sub-list, to be .end()'ed out of\n\t\t\t//\t|\t\tquery(\".foo\")\n\t\t\t//\t|\t\t\t.third()\n\t\t\t//\t|\t\t\t\t.addClass(\"thirdFoo\")\n\t\t\t//\t|\t\t\t.end()\n\t\t\t//\t|\t\t\t// access to the orig .foo list\n\t\t\t//\t|\t\t\t.removeClass(\"foo\")\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\tthis._parent = parent;\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\n\t\ton: function(eventName, listener){\n\t\t\t// summary:\n\t\t\t//\t\tListen for events on the nodes in the NodeList. Basic usage is:\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\t|\trequire([\"dojo/query\"\n\t\t\t//\t\t|\t], function(query){\n\t\t\t//\t\t|\t\tquery(\".my-class\").on(\"click\", listener);\n\t\t\t//\t\t\tThis supports event delegation by using selectors as the first argument with the event names as\n\t\t\t//\t\t\tpseudo selectors. For example:\n\t\t\t//\t\t| \t\tquery(\"#my-list\").on(\"li:click\", listener);\n\t\t\t//\t\t\tThis will listen for click events within `<li>` elements that are inside the `#my-list` element.\n\t\t\t//\t\t\tBecause on supports CSS selector syntax, we can use comma-delimited events as well:\n\t\t\t//\t\t| \t\tquery(\"#my-list\").on(\"li button:mouseover, li:click\", listener);\n\t\t\t//\t\t|\t});\n\t\t\tvar handles = this.map(function(node){\n\t\t\t\treturn on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches\n\t\t\t});\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t},\n\n\t\tend: function(){\n\t\t\t// summary:\n\t\t\t//\t\tEnds use of the current `NodeList` by returning the previous NodeList\n\t\t\t//\t\tthat generated the current NodeList.\n\t\t\t// description:\n\t\t\t//\t\tReturns the `NodeList` that generated the current `NodeList`. If there\n\t\t\t//\t\tis no parent NodeList, an empty NodeList is returned.\n\t\t\t// example:\n\t\t\t//\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"a\")\n\t\t\t//\t|\t\t\t.filter(\".disabled\")\n\t\t\t//\t|\t\t\t\t// operate on the anchors that only have a disabled class\n\t\t\t//\t|\t\t\t\t.style(\"color\", \"grey\")\n\t\t\t//\t|\t\t\t.end()\n\t\t\t//\t|\t\t\t// jump back to the list of anchors\n\t\t\t//\t|\t\t\t.style(...)\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\tif(this._parent){\n\t\t\t\treturn this._parent;\n\t\t\t}else{\n\t\t\t\t//Just return empty list.\n\t\t\t\treturn new this._NodeListCtor(0);\n\t\t\t}\n\t\t},\n\n\t\t// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods\n\n\t\t// FIXME: handle return values for #3244\n\t\t//\t\thttp://trac.dojotoolkit.org/ticket/3244\n\n\t\t// FIXME:\n\t\t//\t\tneed to wrap or implement:\n\t\t//\t\t\tjoin (perhaps w/ innerHTML/outerHTML overload for toString() of items?)\n\t\t//\t\t\treduce\n\t\t//\t\t\treduceRight\n\n\t\t/*=====\n\t\tslice: function(begin, end){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList, maintaining this one in place\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.slice method\n\t\t\t//\t\twith the caveat that it returns a `dojo/NodeList` and not a\n\t\t\t//\t\traw Array. For more details, see Mozilla's [slice\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)\n\t\t\t// begin: Integer\n\t\t\t//\t\tCan be a positive or negative integer, with positive\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\n\t\t\t//\t\tof the end)\n\t\t\t// end: Integer?\n\t\t\t//\t\tOptional parameter to describe what position relative to\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\n\t\t\t//\t\tcan be positive or negative.\n\t\t\treturn this._wrap(a.slice.apply(this, arguments));\n\t\t},\n\n\t\tsplice: function(index, howmany, item){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList, manipulating this NodeList based on\n\t\t\t//\t\tthe arguments passed, potentially splicing in new elements\n\t\t\t//\t\tat an offset, optionally deleting elements\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.splice method\n\t\t\t//\t\twith the caveat that it returns a `dojo/NodeList` and not a\n\t\t\t//\t\traw Array. For more details, see Mozilla's [splice\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)\n\t\t\t//\t\tFor backwards compatibility, calling .end() on the spliced NodeList\n\t\t\t//\t\tdoes not return the original NodeList -- splice alters the NodeList in place.\n\t\t\t// index: Integer\n\t\t\t//\t\tbegin can be a positive or negative integer, with positive\n\t\t\t//\t\tintegers noting the offset to begin at, and negative\n\t\t\t//\t\tintegers denoting an offset from the end (i.e., to the left\n\t\t\t//\t\tof the end)\n\t\t\t// howmany: Integer?\n\t\t\t//\t\tOptional parameter to describe what position relative to\n\t\t\t//\t\tthe NodeList's zero index to end the slice at. Like begin,\n\t\t\t//\t\tcan be positive or negative.\n\t\t\t// item: Object...?\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\n\t\t\t//\t\tspliced into the NodeList\n\t\t\treturn this._wrap(a.splice.apply(this, arguments));\t// dojo/NodeList\n\t\t},\n\n\t\tindexOf: function(value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo/_base/array.indexOf()`. The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList\n\t\t\t// value: Object\n\t\t\t//\t\tThe value to search for.\n\t\t\t// fromIndex: Integer?\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\n\t\t\t// description:\n\t\t\t//\t\tFor more details on the behavior of indexOf, see Mozilla's\n\t\t\t//\t\t[indexOf\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)\n\t\t\t// returns:\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\n\t\t\treturn d.indexOf(this, value, fromIndex); // Integer\n\t\t},\n\n\t\tlastIndexOf: function(value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo/_base/array.lastIndexOf()`. The primary difference is that the\n\t\t\t//\t\tacted-on array is implicitly this NodeList\n\t\t\t// description:\n\t\t\t//\t\tFor more details on the behavior of lastIndexOf, see\n\t\t\t//\t\tMozilla's [lastIndexOf\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)\n\t\t\t// value: Object\n\t\t\t//\t\tThe value to search for.\n\t\t\t// fromIndex: Integer?\n\t\t\t//\t\tThe location to start searching from. Optional. Defaults to 0.\n\t\t\t// returns:\n\t\t\t//\t\tPositive Integer or 0 for a match, -1 of not found.\n\t\t\treturn d.lastIndexOf(this, value, fromIndex); // Integer\n\t\t},\n\n\t\tevery: function(callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo/_base/array.every()` and the [Array.every\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).\n\t\t\t//\t\tTakes the same structure of arguments and returns as\n\t\t\t//\t\tdojo/_base/array.every() with the caveat that the passed array is\n\t\t\t//\t\timplicitly this NodeList\n\t\t\t// callback: Function\n\t\t\t//\t\tthe callback\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tthe context\n\t\t\treturn d.every(this, callback, thisObject); // Boolean\n\t\t},\n\n\t\tsome: function(callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tTakes the same structure of arguments and returns as\n\t\t\t//\t\t`dojo/_base/array.some()` with the caveat that the passed array is\n\t\t\t//\t\timplicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's\n\t\t\t//\t\t[Array.some\n\t\t\t//\t\tdocumentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).\n\t\t\t// callback: Function\n\t\t\t//\t\tthe callback\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tthe context\n\t\t\treturn d.some(this, callback, thisObject); // Boolean\n\t\t},\n\t\t=====*/\n\n\t\tconcat: function(item){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\n\t\t\t//\t\tas well as items passed in as parameters\n\t\t\t// description:\n\t\t\t//\t\tThis method behaves exactly like the Array.concat method\n\t\t\t//\t\twith the caveat that it returns a `NodeList` and not a\n\t\t\t//\t\traw Array. For more details, see the [Array.concat\n\t\t\t//\t\tdocs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)\n\t\t\t// item: Object?\n\t\t\t//\t\tAny number of optional parameters may be passed in to be\n\t\t\t//\t\tspliced into the NodeList\n\n\t\t\t//return this._wrap(apc.apply(this, arguments));\n\t\t\t// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(\n\n\t\t\t// implementation notes:\n\t\t\t// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists\n\t\t\t// as arrays, and so does not inline them into a unioned array, but\n\t\t\t// appends them as single entities. Both the original NodeList and the\n\t\t\t// items passed in as parameters must be converted to raw Arrays\n\t\t\t// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.\n\n\t\t\tvar t = aps.call(this, 0),\n\t\t\t\tm = array.map(arguments, function(a){\n\t\t\t\t\treturn aps.call(a, 0);\n\t\t\t\t});\n\t\t\treturn this._wrap(apc.apply(t, m), this);\t// dojo/NodeList\n\t\t},\n\n\t\tmap: function(/*Function*/ func, /*Function?*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo/_base/array.map()`. The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList and the return is a\n\t\t\t//\t\tNodeList (a subclass of Array)\n\t\t\treturn this._wrap(array.map(this, func, obj), this); // dojo/NodeList\n\t\t},\n\n\t\tforEach: function(callback, thisObj){\n\t\t\t// summary:\n\t\t\t//\t\tsee `dojo/_base/array.forEach()`. The primary difference is that the acted-on\n\t\t\t//\t\tarray is implicitly this NodeList. If you want the option to break out\n\t\t\t//\t\tof the forEach loop, use every() or some() instead.\n\t\t\tforEach(this, callback, thisObj);\n\t\t\t// non-standard return to allow easier chaining\n\t\t\treturn this; // dojo/NodeList\n\t\t},\n\t\tfilter: function(/*String|Function*/ filter){\n\t\t\t// summary:\n\t\t\t//\t\t\"masks\" the built-in javascript filter() method (supported\n\t\t\t//\t\tin Dojo via `dojo/_base/array.filter`) to support passing a simple\n\t\t\t//\t\tstring filter in addition to supporting filtering function\n\t\t\t//\t\tobjects.\n\t\t\t// filter:\n\t\t\t//\t\tIf a string, a CSS rule like \".thinger\" or \"div > span\".\n\t\t\t// example:\n\t\t\t//\t\t\"regular\" JS filter syntax as exposed in `dojo/_base/array.filter`:\n\t\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t\t|\t], function(query){\n\t\t\t//\t\t|\t\tquery(\"*\").filter(function(item){\n\t\t\t//\t\t|\t\t\t// highlight every paragraph\n\t\t\t//\t\t|\t\t\treturn (item.nodeName == \"p\");\n\t\t\t//\t\t|\t\t}).style(\"backgroundColor\", \"yellow\");\n\t\t\t//\t\t|\t});\n\t\t\t// example:\n\t\t\t//\t\tthe same filtering using a CSS selector\n\t\t\t//\t\t|\trequire([\"dojo/query\", \"dojo/NodeList-dom\"\n\t\t\t//\t\t|\t], function(query){\n\t\t\t//\t\t|\t\tquery(\"*\").filter(\"p\").styles(\"backgroundColor\", \"yellow\");\n\t\t\t//\t\t|\t});\n\n\t\t\tvar a = arguments, items = this, start = 0;\n\t\t\tif(typeof filter == \"string\"){ // inline'd type check\n\t\t\t\titems = query._filterResult(this, a[0]);\n\t\t\t\tif(a.length == 1){\n\t\t\t\t\t// if we only got a string query, pass back the filtered results\n\t\t\t\t\treturn items._stash(this); // dojo/NodeList\n\t\t\t\t}\n\t\t\t\t// if we got a callback, run it over the filtered items\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t\treturn this._wrap(array.filter(items, a[start], a[start + 1]), this);\t// dojo/NodeList\n\t\t},\n\t\tinstantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a new instance of a specified class, using the\n\t\t\t//\t\tspecified properties and each node in the NodeList as a\n\t\t\t//\t\tsrcNodeRef.\n\t\t\t// example:\n\t\t\t//\t\tGrabs all buttons in the page and converts them to dijit/form/Button's.\n\t\t\t//\t|\tvar buttons = query(\"button\").instantiate(Button, {showLabel: true});\n\t\t\tvar c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);\n\t\t\tproperties = properties || {};\n\t\t\treturn this.forEach(function(node){\n\t\t\t\tnew c(properties, node);\n\t\t\t});\t// dojo/NodeList\n\t\t},\n\t\tat: function(/*===== index =====*/){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new NodeList comprised of items in this NodeList\n\t\t\t//\t\tat the given index or indices.\n\t\t\t//\n\t\t\t// index: Integer...\n\t\t\t//\t\tOne or more 0-based indices of items in the current\n\t\t\t//\t\tNodeList. A negative index will start at the end of the\n\t\t\t//\t\tlist and go backwards.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tShorten the list to the first, second, and third elements\n\t\t\t//\t|\trequire([\"dojo/query\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"a\").at(0, 1, 2).forEach(fn);\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tRetrieve the first and last elements of a unordered list:\n\t\t\t//\t|\trequire([\"dojo/query\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"ul > li\").at(0, -1).forEach(cb);\n\t\t\t//\t|\t});\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\tDo something for the first element only, but end() out back to\n\t\t\t//\tthe original list and continue chaining:\n\t\t\t//\t|\trequire([\"dojo/query\"\n\t\t\t//\t|\t], function(query){\n\t\t\t//\t|\t\tquery(\"a\").at(0).onclick(fn).end().forEach(function(n){\n\t\t\t//\t|\t\t\tconsole.log(n); // all anchors on the page.\n\t\t\t//\t|\t})\n\t\t\t//\t|\t});\n\n\t\t\tvar t = new this._NodeListCtor(0);\n\t\t\tforEach(arguments, function(i){\n\t\t\t\tif(i < 0){ i = this.length + i; }\n\t\t\t\tif(this[i]){ t.push(this[i]); }\n\t\t\t}, this);\n\t\t\treturn t._stash(this); // dojo/NodeList\n\t\t}\n\t});\n\n\tfunction queryForEngine(engine, NodeList){\n\t\tvar query = function(/*String*/ query, /*String|DOMNode?*/ root){\n\t\t\t// summary:\n\t\t\t//\t\tReturns nodes which match the given CSS selector, searching the\n\t\t\t//\t\tentire document by default but optionally taking a node to scope\n\t\t\t//\t\tthe search by. Returns an instance of NodeList.\n\t\t\tif(typeof root == \"string\"){\n\t\t\t\troot = dom.byId(root);\n\t\t\t\tif(!root){\n\t\t\t\t\treturn new NodeList([]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar results = typeof query == \"string\" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];\n\t\t\tif(results.end && results.on){\n\t\t\t\t// already wrapped\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\treturn new NodeList(results);\n\t\t};\n\t\tquery.matches = engine.match || function(node, selector, root){\n\t\t\t// summary:\n\t\t\t//\t\tTest to see if a node matches a selector\n\t\t\treturn query.filter([node], selector, root).length > 0;\n\t\t};\n\t\t// the engine provides a filtering function, use it to for matching\n\t\tquery.filter = engine.filter || function(nodes, selector, root){\n\t\t\t// summary:\n\t\t\t//\t\tFilters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.\n\t\t\treturn query(selector, root).filter(function(node){\n\t\t\t\treturn array.indexOf(nodes, node) > -1;\n\t\t\t});\n\t\t};\n\t\tif(typeof engine != \"function\"){\n\t\t\tvar search = engine.search;\n\t\t\tengine = function(selector, root){\n\t\t\t\t// Slick does it backwards (or everyone else does it backwards, probably the latter)\n\t\t\t\treturn search(root || document, selector);\n\t\t\t};\n\t\t}\n\t\treturn query;\n\t}\n\tvar query = queryForEngine(defaultEngine, NodeList);\n\t/*=====\n\tquery = function(selector, context){\n\t\t// summary:\n\t\t//\t\tThis modules provides DOM querying functionality. The module export is a function\n\t\t//\t\tthat can be used to query for DOM nodes by CSS selector and returns a NodeList\n\t\t//\t\trepresenting the matching nodes.\n\t\t// selector: String\n\t\t//\t\tA CSS selector to search for.\n\t\t// context: String|DomNode?\n\t\t//\t\tAn optional context to limit the searching scope. Only nodes under `context` will be\n\t\t//\t\tscanned.\n\t\t// example:\n\t\t//\t\tadd an onclick handler to every submit button in the document\n\t\t//\t\twhich causes the form to be sent via Ajax instead:\n\t\t//\t|\trequire([\"dojo/query\", \"dojo/request\", \"dojo/dom-form\", \"dojo/dom-construct\", \"dojo/dom-style\"\n\t\t//\t|\t], function(query, request, domForm, domConstruct, domStyle){\n\t\t//\t|\t\tquery(\"input[type='submit']\").on(\"click\", function(e){\n\t\t//\t|\t\t\te.preventDefault(); // prevent sending the form\n\t\t//\t|\t\t\tvar btn = e.target;\n\t\t//\t|\t\t\trequest.post(\"http://example.com/\", {\n\t\t//\t|\t\t\t\tdata: domForm.toObject(btn.form)\n\t\t//\t|\t\t\t}).then(function(response){\n\t\t//\t|\t\t\t\t// replace the form with the response\n\t\t//\t|\t\t\t\tdomConstruct.create(div, {innerHTML: response}, btn.form, \"after\");\n\t\t//\t|\t\t\t\tdomStyle.set(btn.form, \"display\", \"none\");\n\t\t//\t|\t\t\t});\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\n\t\t// description:\n\t\t//\t\tdojo/query is responsible for loading the appropriate query engine and wrapping\n\t\t//\t\tits results with a `NodeList`. You can use dojo/query with a specific selector engine\n\t\t//\t\tby using it as a plugin. For example, if you installed the sizzle package, you could\n\t\t//\t\tuse it as the selector engine with:\n\t\t//\t\t|\trequire([\"dojo/query!sizzle\"], function(query){\n\t\t//\t\t|\t\tquery(\"div\")...\n\t\t//\n\t\t//\t\tThe id after the ! can be a module id of the selector engine or one of the following values:\n\t\t//\n\t\t//\t\t- acme: This is the default engine used by Dojo base, and will ensure that the full\n\t\t//\t\tAcme engine is always loaded.\n\t\t//\n\t\t//\t\t- css2: If the browser has a native selector engine, this will be used, otherwise a\n\t\t//\t\tvery minimal lightweight selector engine will be loaded that can do simple CSS2 selectors\n\t\t//\t\t(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)\n\t\t//\t\toperators) and nothing more.\n\t\t//\n\t\t//\t\t- css2.1: If the browser has a native selector engine, this will be used, otherwise the\n\t\t//\t\tfull Acme engine will be loaded.\n\t\t//\n\t\t//\t\t- css3: If the browser has a native selector engine with support for CSS3 pseudo\n\t\t//\t\tselectors (most modern browsers except IE8), this will be used, otherwise the\n\t\t//\t\tfull Acme engine will be loaded.\n\t\t//\n\t\t//\t\t- Or the module id of a selector engine can be used to explicitly choose the selector engine\n\t\t//\n\t\t//\t\tFor example, if you are using CSS3 pseudo selectors in module, you can specify that\n\t\t//\t\tyou will need support them with:\n\t\t//\t\t|\trequire([\"dojo/query!css3\"], function(query){\n\t\t//\t\t|\t\tquery('#t > h3:nth-child(odd)')...\n\t\t//\n\t\t//\t\tYou can also choose the selector engine/load configuration by setting the query-selector:\n\t\t//\t\tFor example:\n\t\t//\t\t|\t<script data-dojo-config=\"query-selector:'css3'\" src=\"dojo.js\"></script>\n\t\t//\n\t\treturn new NodeList(); // dojo/NodeList\n\t };\n\t =====*/\n\n\t// the query that is returned from this module is slightly different than dojo.query,\n\t// because dojo.query has to maintain backwards compatibility with returning a\n\t// true array which has performance problems. The query returned from the module\n\t// does not use true arrays, but rather inherits from Array, making it much faster to\n\t// instantiate.\n\tdojo.query = queryForEngine(defaultEngine, function(array){\n\t\t// call it without the new operator to invoke the back-compat behavior that returns a true array\n\t\treturn NodeList(array);\t// dojo/NodeList\n\t});\n\n\tquery.load = function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t\tcan be used as AMD plugin to conditionally load new query engine\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/query!custom\"], function(qsa){\n\t\t//\t|\t\t// loaded selector/custom.js as engine\n\t\t//\t|\t\tqsa(\"#foobar\").forEach(...);\n\t\t//\t|\t});\n\t\tloader.load(id, parentRequire, function(engine){\n\t\t\tloaded(queryForEngine(engine, NodeList));\n\t\t});\n\t};\n\n\tdojo._filterQueryResult = query._filterResult = function(nodes, selector, root){\n\t\treturn new NodeList(query.filter(nodes, selector, root));\n\t};\n\tdojo.NodeList = query.NodeList = NodeList;\n\treturn query;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/ready.js":"define([\"./_base/kernel\", \"./has\", \"require\", \"./has!host-browser?./domReady\", \"./_base/lang\"], function(dojo, has, require, domReady, lang){\n\t// module:\n\t//\t\tdojo/ready\n\t// note:\n\t//\t\tThis module should be unnecessary in dojo 2.0\n\n\tvar\n\t\t// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved\n\t\tisDomReady = 0,\n\n\t\t// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied\n\t\tloadQ = [],\n\n\t\t// prevent recursion in onLoad\n\t\tonLoadRecursiveGuard = 0,\n\n\t\thandleDomReady = function(){\n\t\t\tisDomReady = 1;\n\t\t\tdojo._postLoad = dojo.config.afterOnLoad = true;\n\t\t\tonEvent();\n\t\t},\n\n\t\tonEvent = function(){\n\t\t\t// Called when some state changes:\n\t\t\t//\t\t- dom ready\n\t\t\t//\t\t- dojo/domReady has finished processing everything in its queue\n\t\t\t//\t\t- task added to loadQ\n\t\t\t//\t\t- require() has finished loading all currently requested modules\n\t\t\t//\n\t\t\t// Run the functions queued with dojo.ready if appropriate.\n\n\n\t\t\t//guard against recursions into this function\n\t\t\tif(onLoadRecursiveGuard){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonLoadRecursiveGuard = 1;\n\n\t\t\t// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no\n\t\t\t// pending tasks registered via domReady().\n\t\t\t// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the\n\t\t\t// domReady() calls inside of dojo.\t  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8\n\t\t\t// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.\n\t\t\twhile(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){\n\t\t\t\tvar f = loadQ.shift();\n\t\t\t\ttry{\n\t\t\t\t\tf();\n\t\t\t\t}catch(e){\n\t\t\t\t\t// force the dojo.js on(\"error\") handler do display the message\n\t\t\t\t\te.info = e.message;\n\t\t\t\t\tif(require.signal){\n\t\t\t\t\t\trequire.signal(\"error\", e);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonLoadRecursiveGuard = 0;\n\t\t};\n\n\t// Check if we should run the next queue operation whenever require() finishes loading modules or domReady\n\t// finishes processing it's queue.\n\trequire.on && require.on(\"idle\", onEvent);\n\tif(domReady){\n\t\tdomReady._onQEmpty = onEvent;\n\t}\n\n\tvar ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){\n\t\t// summary:\n\t\t//\t\tAdd a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\n\t\t//\t\tIn most cases, the `domReady` plug-in should suffice and this method should not be needed.\n\t\t//\n\t\t//\t\tWhen called in a non-browser environment, just checks that all requested modules have arrived and been\n\t\t//\t\tevaluated.\n\t\t// priority: Integer?\n\t\t//\t\tThe order in which to exec this callback relative to other callbacks, defaults to 1000\n\t\t// context: Object?|Function\n\t\t//\t\tThe context in which to run execute callback, or a callback if not using context\n\t\t// callback: Function?\n\t\t//\t\tThe function to execute.\n\t\t//\n\t\t// example:\n\t\t//\tSimple DOM and Modules ready syntax\n\t\t//\t|\trequire([\"dojo/ready\"], function(ready){\n\t\t//\t|\t\tready(function(){ alert(\"Dom ready!\"); });\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tUsing a priority\n\t\t//\t|\trequire([\"dojo/ready\"], function(ready){\n\t\t//\t|\t\tready(2, function(){ alert(\"low priority ready!\"); })\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tUsing context\n\t\t//\t|\trequire([\"dojo/ready\"], function(ready){\n\t\t//\t|\t\tready(foo, function(){\n\t\t//\t|\t\t\t// in here, this == foo\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\tUsing dojo/hitch style args:\n\t\t//\t|\trequire([\"dojo/ready\"], function(ready){\n\t\t//\t|\t\tvar foo = { dojoReady: function(){ console.warn(this, \"dojo dom and modules ready.\"); } };\n\t\t//\t|\t\tready(foo, \"dojoReady\");\n\t\t//\t|\t});\n\n\t\tvar hitchArgs = lang._toArray(arguments);\n\t\tif(typeof priority != \"number\"){\n\t\t\tcallback = context;\n\t\t\tcontext = priority;\n\t\t\tpriority = 1000;\n\t\t}else{\n\t\t\thitchArgs.shift();\n\t\t}\n\t\tcallback = callback ?\n\t\t\tlang.hitch.apply(dojo, hitchArgs) :\n\t\t\tfunction(){\n\t\t\t\tcontext();\n\t\t\t};\n\t\tcallback.priority = priority;\n\t\tfor(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}\n\t\tloadQ.splice(i, 0, callback);\n\t\tonEvent();\n\t};\n\n\thas.add(\"dojo-config-addOnLoad\", 1);\n\tif(has(\"dojo-config-addOnLoad\")){\n\t\tvar dca = dojo.config.addOnLoad;\n\t\tif(dca){\n\t\t\tready[(lang.isArray(dca) ? \"apply\" : \"call\")](dojo, dca);\n\t\t}\n\t}\n\n\tif(has(\"dojo-sync-loader\") && dojo.config.parseOnLoad && !dojo.isAsync){\n\t\tready(99, function(){\n\t\t\tif(!dojo.parser){\n\t\t\t\tdojo.deprecated(\"Add explicit require(['dojo/parser']);\", \"\", \"2.0\");\n\t\t\t\trequire([\"dojo/parser\"]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif(domReady){\n\t\tdomReady(handleDomReady);\n\t}else{\n\t\thandleDomReady();\n\t}\n\n\treturn ready;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/regexp.js":"define([\"./_base/kernel\", \"./_base/lang\"], function(dojo, lang){\n\n// module:\n//\t\tdojo/regexp\n\nvar regexp = {\n\t// summary:\n\t//\t\tRegular expressions and Builder resources\n};\nlang.setObject(\"dojo.regexp\", regexp);\n\nregexp.escapeString = function(/*String*/str, /*String?*/except){\n\t// summary:\n\t//\t\tAdds escape sequences for special characters in regular expressions\n\t// except:\n\t//\t\ta String with special characters to be left unescaped\n\n\treturn str.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(ch){\n\t\tif(except && except.indexOf(ch) != -1){\n\t\t\treturn ch;\n\t\t}\n\t\treturn \"\\\\\" + ch;\n\t}); // String\n};\n\nregexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){\n\t// summary:\n\t//\t\tBuilds a regular expression that groups subexpressions\n\t// description:\n\t//\t\tA utility function used by some of the RE generators. The\n\t//\t\tsubexpressions are constructed by the function, re, in the second\n\t//\t\tparameter.  re builds one subexpression for each elem in the array\n\t//\t\ta, in the first parameter. Returns a string for a regular\n\t//\t\texpression that groups all the subexpressions.\n\t// arr:\n\t//\t\tA single value or an array of values.\n\t// re:\n\t//\t\tA function. Takes one parameter and converts it to a regular\n\t//\t\texpression.\n\t// nonCapture:\n\t//\t\tIf true, uses non-capturing match, otherwise matches are retained\n\t//\t\tby regular expression. Defaults to false\n\n\t// case 1: a is a single value.\n\tif(!(arr instanceof Array)){\n\t\treturn re(arr); // String\n\t}\n\n\t// case 2: a is an array\n\tvar b = [];\n\tfor(var i = 0; i < arr.length; i++){\n\t\t// convert each elem to a RE\n\t\tb.push(re(arr[i]));\n\t}\n\n\t // join the REs as alternatives in a RE group.\n\treturn regexp.group(b.join(\"|\"), nonCapture); // String\n};\n\nregexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){\n\t// summary:\n\t//\t\tadds group match to expression\n\t// nonCapture:\n\t//\t\tIf true, uses non-capturing match, otherwise matches are retained\n\t//\t\tby regular expression.\n\treturn \"(\" + (nonCapture ? \"?:\":\"\") + expression + \")\"; // String\n};\n\nreturn regexp;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/request.js":"define([\n\t'./request/default!'/*=====,\n\t'./_base/declare',\n\t'./promise/Promise' =====*/\n], function(request/*=====, declare, Promise =====*/){\n\t/*=====\n\trequest = function(url, options){\n\t\t// summary:\n\t\t//\t\tSend a request using the default transport for the current platform.\n\t\t// url: String\n\t\t//\t\tThe URL to request.\n\t\t// options: dojo/request.__Options?\n\t\t//\t\tOptions for the request.\n\t\t// returns: dojo/request.__Promise\n\t};\n\trequest.__Promise = declare(Promise, {\n\t\t// response: dojo/promise/Promise\n\t\t//\t\tA promise resolving to an object representing\n\t\t//\t\tthe response from the server.\n\t});\n\trequest.__BaseOptions = declare(null, {\n\t\t// query: String|Object?\n\t\t//\t\tQuery parameters to append to the URL.\n\t\t// data: String|Object?\n\t\t//\t\tData to transfer.  This is ignored for GET and DELETE\n\t\t//\t\trequests.\n\t\t// preventCache: Boolean?\n\t\t//\t\tWhether to append a cache-busting parameter to the URL.\n\t\t// timeout: Integer?\n\t\t//\t\tMilliseconds to wait for the response.  If this time\n\t\t//\t\tpasses, the then the promise is rejected.\n\t\t// handleAs: String?\n\t\t//\t\tHow to handle the response from the server.  Default is\n\t\t//\t\t'text'.  Other values are 'json', 'javascript', and 'xml'.\n\t});\n\trequest.__MethodOptions = declare(null, {\n\t\t// method: String?\n\t\t//\t\tThe HTTP method to use to make the request.  Must be\n\t\t//\t\tuppercase.\n\t});\n\trequest.__Options = declare([request.__BaseOptions, request.__MethodOptions]);\n\n\trequest.get = function(url, options){\n\t\t// summary:\n\t\t//\t\tSend an HTTP GET request using the default transport for the current platform.\n\t\t// url: String\n\t\t//\t\tURL to request\n\t\t// options: dojo/request.__BaseOptions?\n\t\t//\t\tOptions for the request.\n\t\t// returns: dojo/request.__Promise\n\t};\n\trequest.post = function(url, options){\n\t\t// summary:\n\t\t//\t\tSend an HTTP POST request using the default transport for the current platform.\n\t\t// url: String\n\t\t//\t\tURL to request\n\t\t// options: dojo/request.__BaseOptions?\n\t\t//\t\tOptions for the request.\n\t\t// returns: dojo/request.__Promise\n\t};\n\trequest.put = function(url, options){\n\t\t// summary:\n\t\t//\t\tSend an HTTP POST request using the default transport for the current platform.\n\t\t// url: String\n\t\t//\t\tURL to request\n\t\t// options: dojo/request.__BaseOptions?\n\t\t//\t\tOptions for the request.\n\t\t// returns: dojo/request.__Promise\n\t};\n\trequest.del = function(url, options){\n\t\t// summary:\n\t\t//\t\tSend an HTTP DELETE request using the default transport for the current platform.\n\t\t// url: String\n\t\t//\t\tURL to request\n\t\t// options: dojo/request.__BaseOptions?\n\t\t//\t\tOptions for the request.\n\t\t// returns: dojo/request.__Promise\n\t};\n\t=====*/\n\treturn request;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/require.js":"define([\"./_base/loader\"], function(loader){\n\treturn {\n\t\tdynamic:0,\n\t\tnormalize:function(id){return id;},\n\t\tload:loader.require\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/robot.js":"define([\n\t\"./_base/array\",\n\t\"./dom\",\n\t\"./dom-geometry\",\n\t\"./_base/kernel\",\n\t\"./_base/lang\",\n\t\"./_base/window\",\n\t\"doh/_browserRunner\",\n\t\"doh/robot\",\n\t\"./window\"\n], function(array, dom, geom, kernel, lang, win, doh, robot, winUtils){\n\nkernel.experimental(\"dojo.robot\");\n\n// users who use doh+dojo get the added convenience of robot.mouseMoveAt(),\n// instead of computing the absolute coordinates of their elements themselves\nlang.mixin(robot, {\n\n\t_resolveNode: function(/*String||DOMNode||Function*/ n){\n\t\tif(typeof n == \"function\"){\n\t\t\t// if the user passed a function returning a node, evaluate it\n\t\t\tn = n();\n\t\t}\n\t\treturn n ? dom.byId(n) : null;\n\t},\n\n\t_scrollIntoView: function(/*Node*/ n){\n\t\t// scrolls the passed node into view, scrolling all ancestor frames/windows as well.\n\t\t// Assumes parent iframes can be made fully visible given the current browser window size\n\t\tvar p = null;\n\t\tarray.forEach(robot._getWindowChain(n), function(w){\n\t\t\t// get the position of the node wrt its parent window\n\t\t\t// if it is a parent frame, its padding and border extents will get added in\n\t\t\tvar p2 = geom.position(n, false),\n\t\t\t\tb = geom.getPadBorderExtents(n),\n\t\t\t\toldp = null;\n\t\t\t// if p2 is the position of the original passed node, store the position away as p\n\t\t\t// otherwise, node is actually an iframe. in this case, add the iframe's position wrt its parent window and also the iframe's padding and border extents\n\t\t\tif(!p){\n\t\t\t\tp = p2;\n\t\t\t}else{\n\t\t\t\toldp = p;\n\t\t\t\tp = {x: p.x+p2.x+b.l,\n\t\t\t\t\ty: p.y+p2.y+b.t,\n\t\t\t\t\tw: p.w,\n\t\t\t\t\th: p.h};\n\n\t\t\t}\n\t\t\t// scroll the parent window so that the node translated into the parent window's coordinate space is in view\n\t\t\twinUtils.scrollIntoView(n,p);\n\t\t\t// adjust position for the new scroll offsets\n\t\t\tp2 = geom.position(n, false);\n\t\t\tif(!oldp){\n\t\t\t\tp = p2;\n\t\t\t}else{\n\t\t\t\tp = {x: oldp.x+p2.x+b.l,\n\t\t\t\t\ty: oldp.y+p2.y+b.t,\n\t\t\t\t\tw: p.w,\n\t\t\t\t\th: p.h};\n\t\t\t}\n\t\t\t// get the parent iframe so it can be scrolled too\n\t\t\tn = w.frameElement;\n\t\t});\n\t},\n\n\t_position: function(/*Node*/ n){\n\t\t// Returns the geom.position of the passed node wrt the passed window's viewport,\n\t\t// following any parent iframes containing the node and clipping the node to each iframe.\n\t\t// precondition: _scrollIntoView already called\n\t\tvar p = null, max = Math.max, min = Math.min;\n\t\t// p: the returned position of the node\n\t\tarray.forEach(robot._getWindowChain(n), function(w){\n\t\t\t// get the position of the node wrt its parent window\n\t\t\t// if it is a parent frame, its padding and border extents will get added in\n\t\t\tvar p2 = geom.position(n, false), b = geom.getPadBorderExtents(n);\n\t\t\t// if p2 is the position of the original passed node, store the position away as p\n\t\t\t// otherwise, node is actually an iframe. in this case, add the iframe's position wrt its parent window and also the iframe's padding and border extents\n\t\t\tif(!p){\n\t\t\t\tp = p2;\n\t\t\t}else{\n\t\t\t\tvar view = winUtils.getBox(n.contentWindow.document);\n\t\t\t\tp2.r = p2.x+view.w;\n\t\t\t\tp2.b = p2.y+view.h;\n\t\t\t\tp = {x: max(p.x+p2.x,p2.x)+b.l, // clip left edge of node wrt the iframe\n\t\t\t\t\ty: max(p.y+p2.y,p2.y)+b.t,\t// top edge\n\t\t\t\t\tr: min(p.x+p2.x+p.w,p2.r)+b.l,\t// right edge (to compute width)\n\t\t\t\t\tb: min(p.y+p2.y+p.h,p2.b)+b.t}; // bottom edge (to compute height)\n\t\t\t\t// save a few bytes by computing width and height from r and b\n\t\t\t\tp.w = p.r-p.x;\n\t\t\t\tp.h = p.b-p.y;\n\t\t\t}\n\t\t\t// the new node is now the old node's parent iframe\n\t\t\tn=w.frameElement;\n\t\t});\n\t\treturn p;\n\t},\n\n\t_getWindowChain : function(/*Node*/ n){\n\t\t// Returns an array of windows starting from the passed node's parent window and ending at dojo's window\n\t\tvar cW = winUtils.get(n.ownerDocument);\n\t\tvar arr = [cW];\n\t\tvar f = cW.frameElement;\n\t\treturn (cW == win.global || !f) ? arr : arr.concat(robot._getWindowChain(f));\n\t},\n\n\tscrollIntoView : function(/*String||DOMNode||Function*/ node, /*Number, optional*/ delay){\n\t\t// summary:\n\t\t//\t\tScroll the passed node into view, if it is not.\n\t\t// node:\n\t\t//\t\tThe id of the node, or the node itself, to move the mouse to.\n\t\t//\t\tIf you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.\n\t\t//\t\tThis is useful if you need to move the mouse to an node that is not yet present.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\n\t\trobot.sequence(function(){\n\t\t\trobot._scrollIntoView(robot._resolveNode(node));\n\t\t}, delay);\n\t},\n\n\tmouseMoveAt : function(/*String||DOMNode||Function*/ node, /*Integer, optional*/ delay, /*Integer, optional*/ duration, /*Number, optional*/ offsetX, /*Number, optional*/ offsetY){\n\t\t// summary:\n\t\t//\t\tMoves the mouse over the specified node at the specified relative x,y offset.\n\t\t// description:\n\t\t//\t\tMoves the mouse over the specified node at the specified relative x,y offset.\n\t\t//\t\tIf you do not specify an offset, mouseMove will default to move to the middle of the node.\n\t\t//\t\tExample: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);\n\t\t// node:\n\t\t//\t\tThe id of the node, or the node itself, to move the mouse to.\n\t\t//\t\tIf you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.\n\t\t//\t\tThis is useful if you need to move the mouse to an node that is not yet present.\n\t\t// delay:\n\t\t//\t\tDelay, in milliseconds, to wait before firing.\n\t\t//\t\tThe delay is a delta with respect to the previous automation call.\n\t\t//\t\tFor example, the following code ends after 600ms:\n\t\t// |\trobot.mouseClick({left:true}, 100) // first call; wait 100ms\n\t\t// |\trobot.typeKeys(\"dij\", 500) // 500ms AFTER previous call; 600ms in all\n\t\t// duration:\n\t\t//\t\tApproximate time Robot will spend moving the mouse\n\t\t//\t\tThe default is 100ms.\n\t\t// offsetX:\n\t\t//\t\tx offset relative to the node, in pixels, to move the mouse. The default is half the node's width.\n\t\t// offsetY:\n\t\t//\t\ty offset relative to the node, in pixels, to move the mouse. The default is half the node's height.\n\n\t\trobot._assertRobot();\n\n\t\t// Schedule an action to scroll the node into view, then calculate it's center point\n\t\tvar point = {};\n\t\tthis.sequence(function(){\n\t\t\tnode = robot._resolveNode(node);\n\t\t\trobot._scrollIntoView(node);\n\t\t\tvar pos = robot._position(node);\n\t\t\tif(offsetY === undefined){\n\t\t\t\toffsetX = pos.w/2;\n\t\t\t\toffsetY = pos.h/2;\n\t\t\t}\n\t\t\tpoint.x = pos.x+offsetX;\n\t\t\tpoint.y = pos.y+offsetY;\n\t\t}, delay);\n\n\t\t// Schedule a bunch of actions to move the mouse from the current position to point.\n\t\t// These actions won't run until after the above callback.\n\t\tthis.mouseMoveTo(point, 0, duration, false);\n\t}\n});\n\nreturn robot;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/robotx.js":"define([\n\t\"require\",\n\t\"doh/main\",\n\t\"./aspect\",\n\t\"./dom-construct\",\n\t\"./dom-style\",\n\t\"./_base/kernel\",\n\t\"./_base/lang\",\n\t\"./on\",\n\t\"./robot\",\n\t\"./sniff\",\n\t\"./_base/window\"\n], function(require, doh, aspect, construct, style, kernel, lang, on, robot, has, win){\n\nkernel.experimental(\"dojo.robotx\");\n\n// module:\n//\t\tdojo.robotx\n// description:\n//\t\tloads an external app into an iframe and points dojo.doc to the iframe document, allowing the robot to control it\n//\t\tto use: set robotURL in djConfig to the URL you want to load\n//\t\tdojo.require this file\n\n// The iframe containing the external app\nvar iframe = null;\n\n// On IE6/7, a firebug console will appear.   Scrunch it a bit to leave room for the external test file.\nkernel.config.debugHeight = kernel.config.debugHeight || 200;\n\n\n// urlLoaded is a Deferred that will be resolved whenever the iframe passed to initRobot() finishes loading, or reloads\nvar urlLoaded;\n\nfunction attachIframe(url){\n\t// summary:\n\t//\t\tCreate iframe to load external app at specified url.   Iframe gets onload handler to  call onIframeLoad()\n\t//\t\twhen specified URL finishes loading, and also if the iframe loads a different URL in the future.\n\t// returns:\n\t//\t\tA Deferred that fires when everything has finished initializing\n\n\trequire([\"./domReady!\"], function(){\n\t\tvar emptyStyle = {\n\t\t\toverflow: \"hidden\",\n\t\t\tmargin: \"0px\",\n\t\t\tborderWidth: \"0px\",\n\t\t\theight: \"100%\",\n\t\t\twidth: \"100%\"\n\t\t};\n\t\tstyle.set(document.documentElement, emptyStyle);\n\t\tstyle.set(document.body, emptyStyle);\n\n\t\t// Create the iframe for the external document.   Put it above the firebug-lite div (if such a div exists).\n\t\t// console.log(\"creating iframe for external document\");\n\t\tiframe = document.createElement(\"iframe\");\n\t\tiframe.setAttribute(\"ALLOWTRANSPARENCY\",\"true\");\n\t\tiframe.scrolling = has(\"ie\") ? \"yes\" : \"auto\";\n\t\tvar scrollRoot = document.compatMode == \"BackCompat\" ? document.body : document.documentElement;\n\t\tvar consoleHeight = (document.getElementById(\"firebug\") || {}).offsetHeight || 0;\n\t\tstyle.set(iframe, {\n\t\t\tborder: \"0px none\",\n\t\t\tpadding: \"0px\",\n\t\t\tmargin: \"0px\",\n\t\t\twidth: \"100%\",\n\t\t\theight: consoleHeight ? (scrollRoot.clientHeight - consoleHeight)+\"px\" : \"100%\"\n\t\t});\n\t\tiframe.src = url;\n\n\t\t// Code to handle load event on iframe.  Seems like this should happen before setting iframe src on line above?\n\t\t// Also, can't we use on() in all cases, even for old IE?\n\t\tif(iframe.attachEvent !== undefined){\n\t\t\tiframe.attachEvent(\"onload\", onIframeLoad);\n\t\t}else{\n\t\t\ton(iframe, \"load\", onIframeLoad);\n\t\t}\n\n\t\tconstruct.place(iframe, win.body(), \"first\");\n\t});\n}\n\nfunction onIframeLoad(){\n\t// summary:\n\t//\t\tLoad handler when iframe specified to initRobot() finishes loading, or when it reloads.\n\t//\t\tIt resolves the urlLoaded Deferred to make the rests of the tests runs.\n\n\trobot._updateDocument();\n\n\t// If dojo is present in the test case, then at least make a best effort to wait for it to load.\n\t// The test must handle other race conditions like initial data queries or asynchronous parses by itself.\n\tif(iframe.contentWindow.require){\n\t\tiframe.contentWindow.require([\"dojo/ready\"], function(ready){\n\t\t\tready(Infinity, function(){\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\turlLoaded.resolve(true);\n\t\t\t\t}, 500);\t// 500ms fudge factor; otherwise focus doesn't work on IE8, see ValidationTextBox.js, TimeTextBox.js, etc.\n\t\t\t});\n\t\t});\n\t}else{\n\t\turlLoaded.resolve(true);\n\t}\n}\n\nlang.mixin(robot, {\n\t_updateDocument: function(){\n\t\t// summary:\n\t\t//\t\tCalled every time a new page is loaded into the iframe, to setup variables\n\t\t//\t\tPoint dojo.global, dojo.publish, etc. to refer to iframe.\n\t\t//\t\tRemove for 2.0?\n\n\t\tkernel.setContext(iframe.contentWindow, iframe.contentWindow.document);\n\n\t\t// Also set pointers inside robot, for easy access via AMD (where there is no dojo variable)\n\t\trobot.window = iframe.contentWindow;\n\t\trobot.doc = iframe.contentWindow.document;\n\n\t\t// TODO: shouldn't this wait until dojo has finished loading in the iframe?  See require code in onIframeLoad().\n\t\tvar win = kernel.global;\n\t\tif(win.dojo){\n\t\t\t// allow the tests to subscribe to topics published by the iframe\n\t\t\tkernel.publish = win.dojo.publish;\n\t\t\tkernel.subscribe = win.dojo.subscribe;\n\t\t\tkernel.connectPublisher = win.dojo.connectPublisher;\n\t\t}\n\t},\n\n\tinitRobot: function(/*String*/ url){\n\t\t// summary:\n\t\t//\t\tOpens the application at the specified URL for testing, redirecting dojo to point to the application\n\t\t//\t\tenvironment instead of the test environment.\n\t\t// url:\n\t\t//\t\tURL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls\n\t\t//\t\t(e.g. dijit.byId()) will point to elements and widgets inside this application.\n\n\t\tdoh.registerGroup(\"initialize robot\", {\n\t\t\tname: \"load \" + url,\n\t\t\ttimeout: 100000,\t// could take more than 10s so setting to 100s\n\t\t\trunTest: function(){\n\t\t\t\t// Setup module level urlLoaded Deferred that will be resolved by onIframeLoad(), after the iframe\n\t\t\t\t// has finished loading\n\t\t\t\turlLoaded = new doh.Deferred();\n\t\t\t\tattachIframe(url);\n\n\t\t\t\treturn urlLoaded;\n\t\t\t}\n\t\t});\n\t},\n\n\twaitForPageToLoad: function(/*Function*/ submitActions){\n\t\t// summary:\n\t\t//\t\tNotifies DOH that the doh.robot is about to make a page change in the application it is driving,\n\t\t//\t\treturning a doh.Deferred object the user should return in their runTest function as part of a DOH test.\n\t\t// example:\n\t\t// |\trunTest: function(){\n\t\t// |\t\treturn waitForPageLoad(function(){ doh.robot.keyPress(keys.ENTER, 500); });\n\t\t// |\t}\n\t\t// submitActions:\n\t\t//\t\tThe doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),\n\t\t//\t\texpecting these actions to create a page change (like a form submit).\n\t\t//\t\tAfter these actions execute and the resulting page loads, the next test will start.\n\n\t\t// Setup a new Deferred that onIframeLoad() will resolve when the iframe finishes loading\n\t\turlLoaded = new doh.Deferred();\n\n\t\tsubmitActions();\n\n\t\treturn urlLoaded;\n\t}\n\n});\n\nreturn robot;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/router.js":"define([\n\t\"./router/RouterBase\"\n], function(RouterBase){\n\n\t// module:\n\t//\t\tdojo/router\n\n/*=====\nreturn {\n\t// summary:\n\t//\t\tA singleton-style instance of dojo/router/RouterBase. See that\n\t//\t\tmodule for specifics.\n\t// example:\n\t//\t|\trouter.register(\"/widgets/:id\", function(evt){\n\t//\t|\t\t// If \"/widgets/3\" was matched,\n\t//\t|\t\t// evt.params.id === \"3\"\n\t//\t|\t\txhr.get({\n\t//\t|\t\t\turl: \"/some/path/\" + evt.params.id,\n\t//\t|\t\t\tload: function(data){\n\t//\t|\t\t\t\t// ...\n\t//\t|\t\t\t}\n\t//\t|\t\t});\n\t//\t|\t});\n};\n=====*/\n\n\treturn new RouterBase({});\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/sniff.js":"define([\"./has\"], function(has){\n\t// module:\n\t//\t\tdojo/sniff\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tThis module sets has() flags based on the current browser.\n\t\t//\t\tIt returns the has() function.\n\t};\n\t=====*/\n\n\tif(has(\"host-browser\")){\n\t\tvar n = navigator,\n\t\t\tdua = n.userAgent,\n\t\t\tdav = n.appVersion,\n\t\t\ttv = parseFloat(dav);\n\n\t\thas.add(\"air\", dua.indexOf(\"AdobeAIR\") >= 0);\n\t\thas.add(\"msapp\", parseFloat(dua.split(\"MSAppHost/\")[1]) || undefined);\n\t\thas.add(\"khtml\", dav.indexOf(\"Konqueror\") >= 0 ? tv : undefined);\n\t\thas.add(\"webkit\", parseFloat(dua.split(\"WebKit/\")[1]) || undefined);\n\t\thas.add(\"chrome\", parseFloat(dua.split(\"Chrome/\")[1]) || undefined);\n\t\thas.add(\"safari\", dav.indexOf(\"Safari\")>=0 && !has(\"chrome\") ? parseFloat(dav.split(\"Version/\")[1]) : undefined);\n\t\thas.add(\"mac\", dav.indexOf(\"Macintosh\") >= 0);\n\t\thas.add(\"quirks\", document.compatMode == \"BackCompat\");\n\t\tif(dua.match(/(iPhone|iPod|iPad)/)){\n\t\t\tvar p = RegExp.$1.replace(/P/, \"p\");\n\t\t\tvar v = dua.match(/OS ([\\d_]+)/) ? RegExp.$1 : \"1\";\n\t\t\tvar os = parseFloat(v.replace(/_/, \".\").replace(/_/g, \"\"));\n\t\t\thas.add(p, os);\t\t// \"iphone\", \"ipad\" or \"ipod\"\n\t\t\thas.add(\"ios\", os);\n\t\t}\n\t\thas.add(\"android\", parseFloat(dua.split(\"Android \")[1]) || undefined);\n\t\thas.add(\"bb\", (dua.indexOf(\"BlackBerry\") >= 0 || dua.indexOf(\"BB10\") >= 0) && parseFloat(dua.split(\"Version/\")[1]) || undefined);\n\t\thas.add(\"trident\", parseFloat(dav.split(\"Trident/\")[1]) || undefined);\n\n\t\thas.add(\"svg\", typeof SVGAngle !== \"undefined\");\n\n\t\tif(!has(\"webkit\")){\n\t\t\t// Opera\n\t\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\t\t// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/\n\t\t\t\t// 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\t\thas.add(\"opera\", tv >= 9.8 ? parseFloat(dua.split(\"Version/\")[1]) || tv : tv);\n\t\t\t}\n\n\t\t\t// Mozilla and firefox\n\t\t\tif(dua.indexOf(\"Gecko\") >= 0 && !has(\"khtml\") && !has(\"webkit\") && !has(\"trident\")){\n\t\t\t\thas.add(\"mozilla\", tv);\n\t\t\t}\n\t\t\tif(has(\"mozilla\")){\n\t\t\t\t//We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\t\thas.add(\"ff\", parseFloat(dua.split(\"Firefox/\")[1] || dua.split(\"Minefield/\")[1]) || undefined);\n\t\t\t}\n\n\t\t\t// IE\n\t\t\tif(document.all && !has(\"opera\")){\n\t\t\t\tvar isIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\n\t\t\t\t//In cases where the page has an HTTP header or META tag with\n\t\t\t\t//X-UA-Compatible, then it is in emulation mode.\n\t\t\t\t//Make sure isIE reflects the desired version.\n\t\t\t\t//document.documentMode of 5 means quirks mode.\n\t\t\t\t//Only switch the value if documentMode's major version\n\t\t\t\t//is different from isIE's major version.\n\t\t\t\tvar mode = document.documentMode;\n\t\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\t\tisIE = mode;\n\t\t\t\t}\n\n\t\t\t\thas.add(\"ie\", isIE);\n\t\t\t}\n\n\t\t\t// Wii\n\t\t\thas.add(\"wii\", typeof opera != \"undefined\" && opera.wiiremote);\n\t\t}\n\t}\n\n\treturn has;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/Stateful.js":"define([\"./_base/declare\", \"./_base/lang\", \"./_base/array\", \"./when\"], function(declare, lang, array, when){\n\t// module:\n\t//\t\tdojo/Stateful\n\nreturn declare(\"dojo.Stateful\", null, {\n\t// summary:\n\t//\t\tBase class for objects that provide named properties with optional getter/setter\n\t//\t\tcontrol and the ability to watch for property changes\n\t//\n\t//\t\tThe class also provides the functionality to auto-magically manage getters\n\t//\t\tand setters for object attributes/properties.\n\t//\t\t\n\t//\t\tGetters and Setters should follow the format of _xxxGetter or _xxxSetter where \n\t//\t\tthe xxx is a name of the attribute to handle.  So an attribute of \"foo\" \n\t//\t\twould have a custom getter of _fooGetter and a custom setter of _fooSetter.\n\t//\n\t// example:\n\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\n\t//\t|\t\tvar obj = new Stateful();\n\t//\t|\t\tobj.watch(\"foo\", function(){\n\t//\t|\t\t\tconsole.log(\"foo changed to \" + this.get(\"foo\"));\n\t//\t|\t\t});\n\t//\t|\t\tobj.set(\"foo\",\"bar\");\n\t//\t|\t});\n\n\t// _attrPairNames: Hash\n\t//\t\tUsed across all instances a hash to cache attribute names and their getter \n\t//\t\tand setter names.\n\t_attrPairNames: {},\n\n\t_getAttrNames: function(name){\n\t\t// summary:\n\t\t//\t\tHelper function for get() and set().\n\t\t//\t\tCaches attribute name values so we don't do the string ops every time.\n\t\t// tags:\n\t\t//\t\tprivate\n\n\t\tvar apn = this._attrPairNames;\n\t\tif(apn[name]){ return apn[name]; }\n\t\treturn (apn[name] = {\n\t\t\ts: \"_\" + name + \"Setter\",\n\t\t\tg: \"_\" + name + \"Getter\"\n\t\t});\n\t},\n\n\tpostscript: function(/*Object?*/ params){\n\t\t// Automatic setting of params during construction\n\t\tif (params){ this.set(params); }\n\t},\n\n\t_get: function(name, names){\n\t\t// summary:\n\t\t//\t\tPrivate function that does a get based off a hash of names\n\t\t// names:\n\t\t//\t\tHash of names of custom attributes\n\t\treturn typeof this[names.g] === \"function\" ? this[names.g]() : this[name];\n\t},\n\tget: function(/*String*/name){\n\t\t// summary:\n\t\t//\t\tGet a property on a Stateful instance.\n\t\t// name:\n\t\t//\t\tThe property to get.\n\t\t// returns:\n\t\t//\t\tThe property value on this Stateful instance.\n\t\t// description:\n\t\t//\t\tGet a named property on a Stateful object. The property may\n\t\t//\t\tpotentially be retrieved via a getter method in subclasses. In the base class\n\t\t//\t\tthis just retrieves the object's property.\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\n\t\t//\t|\t\tvar stateful = new Stateful({foo: 3});\n\t\t//\t|\t\tstateful.get(\"foo\") // returns 3\n\t\t//\t|\t\tstateful.foo // returns 3\n\t\t//\t|\t});\n\n\t\treturn this._get(name, this._getAttrNames(name)); //Any\n\t},\n\tset: function(/*String*/name, /*Object*/value){\n\t\t// summary:\n\t\t//\t\tSet a property on a Stateful instance\n\t\t// name:\n\t\t//\t\tThe property to set.\n\t\t// value:\n\t\t//\t\tThe value to set in the property.\n\t\t// returns:\n\t\t//\t\tThe function returns this dojo.Stateful instance.\n\t\t// description:\n\t\t//\t\tSets named properties on a stateful object and notifies any watchers of\n\t\t//\t\tthe property. A programmatic setter may be defined in subclasses.\n\t\t// example:\n\t\t//\t|\trequire([\"dojo/Stateful\", function(Stateful) {\n\t\t//\t|\t\tvar stateful = new Stateful();\n\t\t//\t|\t\tstateful.watch(function(name, oldValue, value){\n\t\t//\t|\t\t\t// this will be called on the set below\n\t\t//\t|\t\t}\n\t\t//\t|\t\tstateful.set(foo, 5);\n\t\t//\tset() may also be called with a hash of name/value pairs, ex:\n\t\t//\t|\t\tstateful.set({\n\t\t//\t|\t\t\tfoo: \"Howdy\",\n\t\t//\t|\t\t\tbar: 3\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\t//\tThis is equivalent to calling set(foo, \"Howdy\") and set(bar, 3)\n\n\t\t// If an object is used, iterate through object\n\t\tif(typeof name === \"object\"){\n\t\t\tfor(var x in name){\n\t\t\t\tif(name.hasOwnProperty(x) && x !=\"_watchCallbacks\"){\n\t\t\t\t\tthis.set(x, name[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tvar names = this._getAttrNames(name),\n\t\t\toldValue = this._get(name, names),\n\t\t\tsetter = this[names.s],\n\t\t\tresult;\n\t\tif(typeof setter === \"function\"){\n\t\t\t// use the explicit setter\n\t\t\tresult = setter.apply(this, Array.prototype.slice.call(arguments, 1));\n\t\t}else{\n\t\t\t// no setter so set attribute directly\n\t\t\tthis[name] = value;\n\t\t}\n\t\tif(this._watchCallbacks){\n\t\t\tvar self = this;\n\t\t\t// If setter returned a promise, wait for it to complete, otherwise call watches immediatly\n\t\t\twhen(result, function(){\n\t\t\t\tself._watchCallbacks(name, oldValue, value);\n\t\t\t});\n\t\t}\n\t\treturn this; // dojo/Stateful\n\t},\n\t_changeAttrValue: function(name, value){\n\t\t// summary:\n\t\t//\t\tInternal helper for directly changing an attribute value.\n\t\t//\n\t\t// name: String\n\t\t//\t\tThe property to set.\n\t\t// value: Mixed\n\t\t//\t\tThe value to set in the property.\n\t\t//\n\t\t// description:\n\t\t//\t\tDirectly change the value of an attribute on an object, bypassing any \n\t\t//\t\taccessor setter.  Also handles the calling of watch and emitting events. \n\t\t//\t\tIt is designed to be used by descendent class when there are two values \n\t\t//\t\tof attributes that are linked, but calling .set() is not appropriate.\n\n\t\tvar oldValue = this.get(name);\n\t\tthis[name] = value;\n\t\tif(this._watchCallbacks){\n\t\t\tthis._watchCallbacks(name, oldValue, value);\n\t\t}\n\t\treturn this; // dojo/Stateful\n\t},\n\twatch: function(/*String?*/name, /*Function*/callback){\n\t\t// summary:\n\t\t//\t\tWatches a property for changes\n\t\t// name:\n\t\t//\t\tIndicates the property to watch. This is optional (the callback may be the\n\t\t//\t\tonly parameter), and if omitted, all the properties will be watched\n\t\t// returns:\n\t\t//\t\tAn object handle for the watch. The unwatch method of this object\n\t\t//\t\tcan be used to discontinue watching this property:\n\t\t//\t\t|\tvar watchHandle = obj.watch(\"foo\", callback);\n\t\t//\t\t|\twatchHandle.unwatch(); // callback won't be called now\n\t\t// callback:\n\t\t//\t\tThe function to execute when the property changes. This will be called after\n\t\t//\t\tthe property has been changed. The callback will be called with the |this|\n\t\t//\t\tset to the instance, the first argument as the name of the property, the\n\t\t//\t\tsecond argument as the old value and the third argument as the new value.\n\n\t\tvar callbacks = this._watchCallbacks;\n\t\tif(!callbacks){\n\t\t\tvar self = this;\n\t\t\tcallbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){\n\t\t\t\tvar notify = function(propertyCallbacks){\n\t\t\t\t\tif(propertyCallbacks){\n\t\t\t\t\t\tpropertyCallbacks = propertyCallbacks.slice();\n\t\t\t\t\t\tfor(var i = 0, l = propertyCallbacks.length; i < l; i++){\n\t\t\t\t\t\t\tpropertyCallbacks[i].call(self, name, oldValue, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnotify(callbacks['_' + name]);\n\t\t\t\tif(!ignoreCatchall){\n\t\t\t\t\tnotify(callbacks[\"*\"]); // the catch-all\n\t\t\t\t}\n\t\t\t}; // we use a function instead of an object so it will be ignored by JSON conversion\n\t\t}\n\t\tif(!callback && typeof name === \"function\"){\n\t\t\tcallback = name;\n\t\t\tname = \"*\";\n\t\t}else{\n\t\t\t// prepend with dash to prevent name conflicts with function (like \"name\" property)\n\t\t\tname = '_' + name;\n\t\t}\n\t\tvar propertyCallbacks = callbacks[name];\n\t\tif(typeof propertyCallbacks !== \"object\"){\n\t\t\tpropertyCallbacks = callbacks[name] = [];\n\t\t}\n\t\tpropertyCallbacks.push(callback);\n\n\t\t// TODO: Remove unwatch in 2.0\n\t\tvar handle = {};\n\t\thandle.unwatch = handle.remove = function(){\n\t\t\tvar index = array.indexOf(propertyCallbacks, callback);\n\t\t\tif(index > -1){\n\t\t\t\tpropertyCallbacks.splice(index, 1);\n\t\t\t}\n\t\t};\n\t\treturn handle; //Object\n\t}\n\n});\n\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/string.js":"define([\n\t\"./_base/kernel\",\t// kernel.global\n\t\"./_base/lang\"\n], function(kernel, lang){\n\n// module:\n//\t\tdojo/string\n\nvar string = {\n\t// summary:\n\t//\t\tString utilities for Dojo\n};\nlang.setObject(\"dojo.string\", string);\n\nstring.rep = function(/*String*/str, /*Integer*/num){\n\t// summary:\n\t//\t\tEfficiently replicate a string `n` times.\n\t// str:\n\t//\t\tthe string to replicate\n\t// num:\n\t//\t\tnumber of times to replicate the string\n\n\tif(num <= 0 || !str){ return \"\"; }\n\n\tvar buf = [];\n\tfor(;;){\n\t\tif(num & 1){\n\t\t\tbuf.push(str);\n\t\t}\n\t\tif(!(num >>= 1)){ break; }\n\t\tstr += str;\n\t}\n\treturn buf.join(\"\");\t// String\n};\n\nstring.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){\n\t// summary:\n\t//\t\tPad a string to guarantee that it is at least `size` length by\n\t//\t\tfilling with the character `ch` at either the start or end of the\n\t//\t\tstring. Pads at the start, by default.\n\t// text:\n\t//\t\tthe string to pad\n\t// size:\n\t//\t\tlength to provide padding\n\t// ch:\n\t//\t\tcharacter to pad, defaults to '0'\n\t// end:\n\t//\t\tadds padding at the end if true, otherwise pads at start\n\t// example:\n\t//\t|\t// Fill the string to length 10 with \"+\" characters on the right.  Yields \"Dojo++++++\".\n\t//\t|\tstring.pad(\"Dojo\", 10, \"+\", true);\n\n\tif(!ch){\n\t\tch = '0';\n\t}\n\tvar out = String(text),\n\t\tpad = string.rep(ch, Math.ceil((size - out.length) / ch.length));\n\treturn end ? out + pad : pad + out;\t// String\n};\n\nstring.substitute = function(\t/*String*/\t\ttemplate,\n\t\t\t\t\t\t\t\t\t/*Object|Array*/map,\n\t\t\t\t\t\t\t\t\t/*Function?*/\ttransform,\n\t\t\t\t\t\t\t\t\t/*Object?*/\t\tthisObject){\n\t// summary:\n\t//\t\tPerforms parameterized substitutions on a string. Throws an\n\t//\t\texception if any parameter is unmatched.\n\t// template:\n\t//\t\ta string with expressions in the form `${key}` to be replaced or\n\t//\t\t`${key:format}` which specifies a format function. keys are case-sensitive.\n\t// map:\n\t//\t\thash to search for substitutions\n\t// transform:\n\t//\t\ta function to process all parameters before substitution takes\n\t//\t\tplace, e.g. mylib.encodeXML\n\t// thisObject:\n\t//\t\twhere to look for optional format function; default to the global\n\t//\t\tnamespace\n\t// example:\n\t//\t\tSubstitutes two expressions in a string from an Array or Object\n\t//\t|\t// returns \"File 'foo.html' is not found in directory '/temp'.\"\n\t//\t|\t// by providing substitution data in an Array\n\t//\t|\tstring.substitute(\n\t//\t|\t\t\"File '${0}' is not found in directory '${1}'.\",\n\t//\t|\t\t[\"foo.html\",\"/temp\"]\n\t//\t|\t);\n\t//\t|\n\t//\t|\t// also returns \"File 'foo.html' is not found in directory '/temp'.\"\n\t//\t|\t// but provides substitution data in an Object structure.  Dotted\n\t//\t|\t// notation may be used to traverse the structure.\n\t//\t|\tstring.substitute(\n\t//\t|\t\t\"File '${name}' is not found in directory '${info.dir}'.\",\n\t//\t|\t\t{ name: \"foo.html\", info: { dir: \"/temp\" } }\n\t//\t|\t);\n\t// example:\n\t//\t\tUse a transform function to modify the values:\n\t//\t|\t// returns \"file 'foo.html' is not found in directory '/temp'.\"\n\t//\t|\tstring.substitute(\n\t//\t|\t\t\"${0} is not found in ${1}.\",\n\t//\t|\t\t[\"foo.html\",\"/temp\"],\n\t//\t|\t\tfunction(str){\n\t//\t|\t\t\t// try to figure out the type\n\t//\t|\t\t\tvar prefix = (str.charAt(0) == \"/\") ? \"directory\": \"file\";\n\t//\t|\t\t\treturn prefix + \" '\" + str + \"'\";\n\t//\t|\t\t}\n\t//\t|\t);\n\t// example:\n\t//\t\tUse a formatter\n\t//\t|\t// returns \"thinger -- howdy\"\n\t//\t|\tstring.substitute(\n\t//\t|\t\t\"${0:postfix}\", [\"thinger\"], null, {\n\t//\t|\t\t\tpostfix: function(value, key){\n\t//\t|\t\t\t\treturn value + \" -- howdy\";\n\t//\t|\t\t\t}\n\t//\t|\t\t}\n\t//\t|\t);\n\n\tthisObject = thisObject || kernel.global;\n\ttransform = transform ?\n\t\tlang.hitch(thisObject, transform) : function(v){ return v; };\n\n\treturn template.replace(/\\$\\{([^\\s\\:\\}]+)(?:\\:([^\\s\\:\\}]+))?\\}/g,\n\t\tfunction(match, key, format){\n\t\t\tvar value = lang.getObject(key, false, map);\n\t\t\tif(format){\n\t\t\t\tvalue = lang.getObject(format, false, thisObject).call(thisObject, value, key);\n\t\t\t}\n\t\t\treturn transform(value, key).toString();\n\t\t}); // String\n};\n\nstring.trim = String.prototype.trim ?\n\tlang.trim : // aliasing to the native function\n\tfunction(str){\n\t\tstr = str.replace(/^\\s+/, '');\n\t\tfor(var i = str.length - 1; i >= 0; i--){\n\t\t\tif(/\\S/.test(str.charAt(i))){\n\t\t\t\tstr = str.substring(0, i + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t};\n\n/*=====\n string.trim = function(str){\n\t // summary:\n\t //\t\tTrims whitespace from both sides of the string\n\t // str: String\n\t //\t\tString to be trimmed\n\t // returns: String\n\t //\t\tReturns the trimmed string\n\t // description:\n\t //\t\tThis version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).\n\t //\t\tThe short yet performant version of this function is dojo/_base/lang.trim(),\n\t //\t\twhich is part of Dojo base.  Uses String.prototype.trim instead, if available.\n\t return \"\";\t// String\n };\n =====*/\n\n\treturn string;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/text.js":"define([\"./_base/kernel\", \"require\", \"./has\", \"./has!host-browser?./request\"], function(dojo, require, has, request){\n\t// module:\n\t//\t\tdojo/text\n\n\tvar getText;\n\tif(has(\"host-browser\")){\n\t\tgetText= function(url, sync, load){\n\t\t\trequest(url, {sync:!!sync}).then(load);\n\t\t};\n\t}else{\n\t\t// Path for node.js and rhino, to load from local file system.\n\t\t// TODO: use node.js native methods rather than depending on a require.getText() method to exist.\n\t\tif(require.getText){\n\t\t\tgetText= require.getText;\n\t\t}else{\n\t\t\tconsole.error(\"dojo/text plugin failed to load because loader does not support getText\");\n\t\t}\n\t}\n\n\tvar\n\t\ttheCache = {},\n\n\t\tstrip= function(text){\n\t\t\t//Strips <?xml ...?> declarations so that external SVG and XML\n\t\t\t//documents can be added to a document without worry. Also, if the string\n\t\t\t//is an HTML document, only the part inside the body tag is returned.\n\t\t\tif(text){\n\t\t\t\ttext= text.replace(/^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im, \"\");\n\t\t\t\tvar matches= text.match(/<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im);\n\t\t\t\tif(matches){\n\t\t\t\t\ttext= matches[1];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttext = \"\";\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\t\tnotFound = {},\n\n\t\tpending = {};\n\n\tdojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){\n\t\t// summary:\n\t\t//\t\tA getter and setter for storing the string content associated with the\n\t\t//\t\tmodule and url arguments.\n\t\t// description:\n\t\t//\t\tIf module is a string that contains slashes, then it is interpretted as a fully\n\t\t//\t\tresolved path (typically a result returned by require.toUrl), and url should not be\n\t\t//\t\tprovided. This is the preferred signature. If module is a string that does not\n\t\t//\t\tcontain slashes, then url must also be provided and module and url are used to\n\t\t//\t\tcall `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.\n\t\t//\t\tIf value is specified, the cache value for the moduleUrl will be set to\n\t\t//\t\tthat value. Otherwise, dojo.cache will fetch the moduleUrl and store it\n\t\t//\t\tin its internal cache and return that cached value for the URL. To clear\n\t\t//\t\ta cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the\n\t\t//\t\tthe URL contents, only modules on the same domain of the page can use this capability.\n\t\t//\t\tThe build system can inline the cache values though, to allow for xdomain hosting.\n\t\t// module: String||Object\n\t\t//\t\tIf a String with slashes, a fully resolved path; if a String without slashes, the\n\t\t//\t\tmodule name to use for the base part of the URL, similar to module argument\n\t\t//\t\tto `dojo.moduleUrl`. If an Object, something that has a .toString() method that\n\t\t//\t\tgenerates a valid path for the cache item. For example, a dojo._Url object.\n\t\t// url: String\n\t\t//\t\tThe rest of the path to append to the path derived from the module argument. If\n\t\t//\t\tmodule is an object, then this second argument should be the \"value\" argument instead.\n\t\t// value: String||Object?\n\t\t//\t\tIf a String, the value to use in the cache for the module/url combination.\n\t\t//\t\tIf an Object, it can have two properties: value and sanitize. The value property\n\t\t//\t\tshould be the value to use in the cache, and sanitize can be set to true or false,\n\t\t//\t\tto indicate if XML declarations should be removed from the value and if the HTML\n\t\t//\t\tinside a body tag in the value should be extracted as the real value. The value argument\n\t\t//\t\tor the value property on the value argument are usually only used by the build system\n\t\t//\t\tas it inlines cache content.\n\t\t// example:\n\t\t//\t\tTo ask dojo.cache to fetch content and store it in the cache (the dojo[\"cache\"] style\n\t\t//\t\tof call is used to avoid an issue with the build system erroneously trying to intern\n\t\t//\t\tthis example. To get the build system to intern your dojo.cache calls, use the\n\t\t//\t\t\"dojo.cache\" style of call):\n\t\t//\t\t| //If template.html contains \"<h1>Hello</h1>\" that will be\n\t\t//\t\t| //the value for the text variable.\n\t\t//\t\t| //Note: This is pre-AMD, deprecated syntax\n\t\t//\t\t| var text = dojo[\"cache\"](\"my.module\", \"template.html\");\n\t\t// example:\n\t\t//\t\tTo ask dojo.cache to fetch content and store it in the cache, and sanitize the input\n\t\t//\t\t (the dojo[\"cache\"] style of call is used to avoid an issue with the build system\n\t\t//\t\terroneously trying to intern this example. To get the build system to intern your\n\t\t//\t\tdojo.cache calls, use the \"dojo.cache\" style of call):\n\t\t//\t\t| //If template.html contains \"<html><body><h1>Hello</h1></body></html>\", the\n\t\t//\t\t| //text variable will contain just \"<h1>Hello</h1>\".\n\t\t//\t\t| //Note: This is pre-AMD, deprecated syntax\n\t\t//\t\t| var text = dojo[\"cache\"](\"my.module\", \"template.html\", {sanitize: true});\n\t\t// example:\n\t\t//\t\tSame example as previous, but demonstrates how an object can be passed in as\n\t\t//\t\tthe first argument, then the value argument can then be the second argument.\n\t\t//\t\t| //If template.html contains \"<html><body><h1>Hello</h1></body></html>\", the\n\t\t//\t\t| //text variable will contain just \"<h1>Hello</h1>\".\n\t\t//\t\t| //Note: This is pre-AMD, deprecated syntax\n\t\t//\t\t| var text = dojo[\"cache\"](new dojo._Url(\"my/module/template.html\"), {sanitize: true});\n\n\t\t//\t * (string string [value]) => (module, url, value)\n\t\t//\t * (object [value])        => (module, value), url defaults to \"\"\n\t\t//\n\t\t//\t * if module is an object, then it must be convertable to a string\n\t\t//\t * (module, url) module + (url ? (\"/\" + url) : \"\") must be a legal argument to require.toUrl\n\t\t//\t * value may be a string or an object; if an object then may have the properties \"value\" and/or \"sanitize\"\n\t\tvar key;\n\t\tif(typeof module==\"string\"){\n\t\t\tif(/\\//.test(module)){\n\t\t\t\t// module is a version 1.7+ resolved path\n\t\t\t\tkey = module;\n\t\t\t\tvalue = url;\n\t\t\t}else{\n\t\t\t\t// module is a version 1.6- argument to dojo.moduleUrl\n\t\t\t\tkey = require.toUrl(module.replace(/\\./g, \"/\") + (url ? (\"/\" + url) : \"\"));\n\t\t\t}\n\t\t}else{\n\t\t\tkey = module + \"\";\n\t\t\tvalue = url;\n\t\t}\n\t\tvar\n\t\t\tval = (value != undefined && typeof value != \"string\") ? value.value : value,\n\t\t\tsanitize = value && value.sanitize;\n\n\t\tif(typeof val == \"string\"){\n\t\t\t//We have a string, set cache value\n\t\t\ttheCache[key] = val;\n\t\t\treturn sanitize ? strip(val) : val;\n\t\t}else if(val === null){\n\t\t\t//Remove cached value\n\t\t\tdelete theCache[key];\n\t\t\treturn null;\n\t\t}else{\n\t\t\t//Allow cache values to be empty strings. If key property does\n\t\t\t//not exist, fetch it.\n\t\t\tif(!(key in theCache)){\n\t\t\t\tgetText(key, true, function(text){\n\t\t\t\t\ttheCache[key]= text;\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn sanitize ? strip(theCache[key]) : theCache[key];\n\t\t}\n\t};\n\n\treturn {\n\t\t// summary:\n\t\t//\t\tThis module implements the dojo/text! plugin and the dojo.cache API.\n\t\t// description:\n\t\t//\t\tWe choose to include our own plugin to leverage functionality already contained in dojo\n\t\t//\t\tand thereby reduce the size of the plugin compared to various foreign loader implementations.\n\t\t//\t\tAlso, this allows foreign AMD loaders to be used without their plugins.\n\t\t//\n\t\t//\t\tCAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous\n\t\t//\t\tloader. This feature is outside the scope of the CommonJS plugins specification.\n\n\t\t// the dojo/text caches it's own resources because of dojo.cache\n\t\tdynamic: true,\n\n\t\tnormalize: function(id, toAbsMid){\n\t\t\t// id is something like (path may be relative):\n\t\t\t//\n\t\t\t//\t \"path/to/text.html\"\n\t\t\t//\t \"path/to/text.html!strip\"\n\t\t\tvar parts= id.split(\"!\"),\n\t\t\t\turl= parts[0];\n\t\t\treturn (/^\\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? \"!\" + parts[1] : \"\");\n\t\t},\n\n\t\tload: function(id, require, load){\n\t\t\t// id: String\n\t\t\t//\t\tPath to the resource.\n\t\t\t// require: Function\n\t\t\t//\t\tObject that include the function toUrl with given id returns a valid URL from which to load the text.\n\t\t\t// load: Function\n\t\t\t//\t\tCallback function which will be called, when the loading finished.\n\n\t\t\t// id is something like (path is always absolute):\n\t\t\t//\n\t\t\t//\t \"path/to/text.html\"\n\t\t\t//\t \"path/to/text.html!strip\"\n\t\t\tvar\n\t\t\t\tparts= id.split(\"!\"),\n\t\t\t\tstripFlag= parts.length>1,\n\t\t\t\tabsMid= parts[0],\n\t\t\t\turl = require.toUrl(parts[0]),\n\t\t\t\trequireCacheUrl = \"url:\" + url,\n\t\t\t\ttext = notFound,\n\t\t\t\tfinish = function(text){\n\t\t\t\t\tload(stripFlag ? strip(text) : text);\n\t\t\t\t};\n\t\t\tif(absMid in theCache){\n\t\t\t\ttext = theCache[absMid];\n\t\t\t}else if(require.cache && requireCacheUrl in require.cache){\n\t\t\t\ttext = require.cache[requireCacheUrl];\n\t\t\t}else if(url in theCache){\n\t\t\t\ttext = theCache[url];\n\t\t\t}\n\t\t\tif(text===notFound){\n\t\t\t\tif(pending[url]){\n\t\t\t\t\tpending[url].push(finish);\n\t\t\t\t}else{\n\t\t\t\t\tvar pendingList = pending[url] = [finish];\n\t\t\t\t\tgetText(url, !require.async, function(text){\n\t\t\t\t\t\ttheCache[absMid]= theCache[url]= text;\n\t\t\t\t\t\tfor(var i = 0; i<pendingList.length;){\n\t\t\t\t\t\t\tpendingList[i++](text);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete pending[url];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfinish(text);\n\t\t\t}\n\t\t}\n\t};\n\n});\n\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/topic.js":"define([\"./Evented\"], function(Evented){\n\n\t// module:\n\t//\t\tdojo/topic\n\n\tvar hub = new Evented;\n\treturn {\n\t\t// summary:\n\t\t//\t\tPubsub hub.\n\t\t// example:\n\t\t//\t\t| \ttopic.subscribe(\"some/topic\", function(event){\n\t\t//\t\t|\t... do something with event\n\t\t//\t\t|\t});\n\t\t//\t\t|\ttopic.publish(\"some/topic\", {name:\"some event\", ...});\n\n\t\tpublish: function(topic, event){\n\t\t\t// summary:\n\t\t\t//\t\tPublishes a message to a topic on the pub/sub hub. All arguments after\n\t\t\t//\t\tthe first will be passed to the subscribers, so any number of arguments\n\t\t\t//\t\tcan be provided (not just event).\n\t\t\t// topic: String\n\t\t\t//\t\tThe name of the topic to publish to\n\t\t\t// event: Object\n\t\t\t//\t\tAn event to distribute to the topic listeners\n\t\t\treturn hub.emit.apply(hub, arguments);\n\t\t},\n\n\t\tsubscribe: function(topic, listener){\n\t\t\t// summary:\n\t\t\t//\t\tSubscribes to a topic on the pub/sub hub\n\t\t\t// topic: String\n\t\t\t//\t\tThe topic to subscribe to\n\t\t\t// listener: Function\n\t\t\t//\t\tA function to call when a message is published to the given topic\n\t\t\treturn hub.on.apply(hub, arguments);\n\t\t}\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/touch.js":"define([\"./_base/kernel\", \"./aspect\", \"./dom\", \"./dom-class\", \"./_base/lang\", \"./on\", \"./has\", \"./mouse\", \"./domReady\", \"./_base/window\"],\nfunction(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){\n\n\t// module:\n\t//\t\tdojo/touch\n\n\tvar hasTouch = has(\"touch\");\n\n\tvar ios4 = has(\"ios\") < 5;\n\t\n\tvar msPointer = navigator.pointerEnabled || navigator.msPointerEnabled,\n\t\tpointer = (function () {\n\t\t\tvar pointer = {};\n\t\t\tfor (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {\n\t\t\t\tpointer[type] = !navigator.pointerEnabled ?\n\t\t\t\t\t\"MSPointer\" + type.charAt(0).toUpperCase() + type.slice(1) :\n\t\t\t\t\t\"pointer\" + type;\n\t\t\t}\n\t\t\treturn pointer;\n\t\t})();\n\n\t// Click generation variables\n\tvar clicksInited, clickTracker, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;\n\n\t// Time of most recent touchstart, touchmove, or touchend event\n\tvar lastTouch;\n\n\tfunction dualEvent(mouseType, touchType, msPointerType){\n\t\t// Returns synthetic event that listens for both the specified mouse event and specified touch event.\n\t\t// But ignore fake mouse events that were generated due to the user touching the screen.\n\t\tif(msPointer && msPointerType){\n\t\t\t// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,\n\t\t\t// so just use that regardless of hasTouch.\n\t\t\treturn function(node, listener){\n\t\t\t\treturn on(node, msPointerType, listener);\n\t\t\t}\n\t\t}else if(hasTouch){\n\t\t\treturn function(node, listener){\n\t\t\t\tvar handle1 = on(node, touchType, listener),\n\t\t\t\t\thandle2 = on(node, mouseType, function(evt){\n\t\t\t\t\t\tif(!lastTouch || (new Date()).getTime() > lastTouch + 1000){\n\t\t\t\t\t\t\tlistener.call(this, evt);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\treturn {\n\t\t\t\t\tremove: function(){\n\t\t\t\t\t\thandle1.remove();\n\t\t\t\t\t\thandle2.remove();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}else{\n\t\t\t// Avoid creating listeners for touch events on performance sensitive older browsers like IE6\n\t\t\treturn function(node, listener){\n\t\t\t\treturn on(node, mouseType, listener);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction marked(/*DOMNode*/ node){\n\t\t// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing,\n\t\tdo{\n\t\t\tif(node.dojoClick !== undefined){ return node.dojoClick; }\n\t\t}while(node = node.parentNode);\n\t}\n\t\n\tfunction doClicks(e, moveType, endType){\n\t\t// summary:\n\t\t//\t\tSetup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser\n\t\t//\t\tto generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()\n\t\t//\t\twas called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has\n\t\t//      its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its\n\t\t//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property\n\t\t//      to falsy.\n\t\t\n\t\tclickTracker  = !e.target.disabled && marked(e.target); // click threshold = true, number or x/y object\n\t\tif(clickTracker){\n\t\t\tclickTarget = e.target;\n\t\t\tclickX = e.touches ? e.touches[0].pageX : e.clientX;\n\t\t\tclickY = e.touches ? e.touches[0].pageY : e.clientY;\n\t\t\tclickDx = (typeof clickTracker == \"object\" ? clickTracker.x : (typeof clickTracker == \"number\" ? clickTracker : 0)) || 4;\n\t\t\tclickDy = (typeof clickTracker == \"object\" ? clickTracker.y : (typeof clickTracker == \"number\" ? clickTracker : 0)) || 4;\n\n\t\t\t// add move/end handlers only the first time a node with dojoClick is seen,\n\t\t\t// so we don't add too much overhead when dojoClick is never set.\n\t\t\tif(!clicksInited){\n\t\t\t\tclicksInited = true;\n\n\t\t\t\twin.doc.addEventListener(moveType, function(e){\n\t\t\t\t\tclickTracker = clickTracker &&\n\t\t\t\t\t\te.target == clickTarget &&\n\t\t\t\t\t\tMath.abs((e.touches ? e.touches[0].pageX : e.clientX) - clickX) <= clickDx &&\n\t\t\t\t\t\tMath.abs((e.touches ? e.touches[0].pageY : e.clientY) - clickY) <= clickDy;\n\t\t\t\t}, true);\n\n\t\t\t\twin.doc.addEventListener(endType, function(e){\n\t\t\t\t\tif(clickTracker){\n\t\t\t\t\t\tclickTime = (new Date()).getTime();\n\t\t\t\t\t\tvar target = e.target;\n\t\t\t\t\t\tif(target.tagName === \"LABEL\"){\n\t\t\t\t\t\t\t// when clicking on a label, forward click to its associated input if any\n\t\t\t\t\t\t\ttarget = dom.byId(target.getAttribute(\"for\")) || target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\ton.emit(target, \"click\", {\n\t\t\t\t\t\t\t\tbubbles : true,\n\t\t\t\t\t\t\t\tcancelable : true,\n\t\t\t\t\t\t\t\t_dojo_click : true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, true);\n\n\t\t\t\tfunction stopNativeEvents(type){\n\t\t\t\t\twin.doc.addEventListener(type, function(e){\n\t\t\t\t\t\t// Stop native events when we emitted our own click event.  Note that the native click may occur\n\t\t\t\t\t\t// on a different node than the synthetic click event was generated on.  For example,\n\t\t\t\t\t\t// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser\n\t\t\t\t\t\t// sends a click event to the node that was *underneath* the menu.  So stop all native events\n\t\t\t\t\t\t// sent shortly after ours, similar to what is done in dualEvent.\n\t\t\t\t\t\t// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which\n\t\t\t\t\t\t// we call click() explicitly, we don't want to stop this event.\n\t\t\t\t\t\tif(!e._dojo_click &&\n\t\t\t\t\t\t\t\t(new Date()).getTime() <= clickTime + 1000 &&\n\t\t\t\t\t\t\t\t!(e.target.tagName == \"INPUT\" && domClass.contains(e.target, \"dijitOffScreen\"))){\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t\te.stopImmediatePropagation && e.stopImmediatePropagation();\n\t\t\t\t\t\t\tif(type == \"click\" && (e.target.tagName != \"INPUT\" || e.target.type == \"radio\" || e.target.type == \"checkbox\")\n\t\t\t\t\t\t\t\t&& e.target.tagName != \"TEXTAREA\" && e.target.tagName != \"AUDIO\" && e.target.tagName != \"VIDEO\"){\n\t\t\t\t\t\t\t\t // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,\n\t\t\t\t\t\t\t\t // but it is still needed for checkboxes and radio buttons, otherwise in some cases\n\t\t\t\t\t\t\t\t // the checked state becomes inconsistent with the widget's state\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, true);\n\t\t\t\t}\n\n\t\t\t\tstopNativeEvents(\"click\");\n\n\t\t\t\t// We also stop mousedown/up since these would be sent well after with our \"fast\" click (300ms),\n\t\t\t\t// which can confuse some dijit widgets.\n\t\t\t\tstopNativeEvents(\"mousedown\");\n\t\t\t\tstopNativeEvents(\"mouseup\");\n\t\t\t}\n\t\t}\n\t}\n\n\tvar hoveredNode;\n\n\tif(hasTouch){\n\t\tif(msPointer){\n\t\t\t // MSPointer (IE10+) already has support for over and out, so we just need to init click support\n\t\t\tdomReady(function(){\n\t\t\t\twin.doc.addEventListener(pointer.down, function(evt){\n\t\t\t\t\tdoClicks(evt, pointer.move, pointer.up);\n\t\t\t\t}, true);\n\t\t\t});\t\t\n\t\t}else{\n\t\t\tdomReady(function(){\n\t\t\t\t// Keep track of currently hovered node\n\t\t\t\thoveredNode = win.body();\t// currently hovered node\n\n\t\t\t\twin.doc.addEventListener(\"touchstart\", function(evt){\n\t\t\t\t\tlastTouch = (new Date()).getTime();\n\n\t\t\t\t\t// Precede touchstart event with touch.over event.  DnD depends on this.\n\t\t\t\t\t// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,\n\t\t\t\t\t// and to ensure this code runs even if the listener on the node does event.stop().\n\t\t\t\t\tvar oldNode = hoveredNode;\n\t\t\t\t\thoveredNode = evt.target;\n\t\t\t\t\ton.emit(oldNode, \"dojotouchout\", {\n\t\t\t\t\t\trelatedTarget: hoveredNode,\n\t\t\t\t\t\tbubbles: true\n\t\t\t\t\t});\n\t\t\t\t\ton.emit(hoveredNode, \"dojotouchover\", {\n\t\t\t\t\t\trelatedTarget: oldNode,\n\t\t\t\t\t\tbubbles: true\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\tdoClicks(evt, \"touchmove\", \"touchend\"); // init click generation\n\t\t\t\t}, true);\n\n\t\t\t\tfunction copyEventProps(evt){\n\t\t\t\t\t// Make copy of event object and also set bubbles:true.  Used when calling on.emit().\n\t\t\t\t\tvar props = lang.delegate(evt, {\n\t\t\t\t\t\tbubbles: true\n\t\t\t\t\t});\n\n\t\t\t\t\tif(has(\"ios\") >= 6){\n\t\t\t\t\t\t// On iOS6 \"touches\" became a non-enumerable property, which \n\t\t\t\t\t\t// is not hit by for...in.  Ditto for the other properties below.\n\t\t\t\t\t\tprops.touches = evt.touches;\n\t\t\t\t\t\tprops.altKey = evt.altKey;\n\t\t\t\t\t\tprops.changedTouches = evt.changedTouches;\n\t\t\t\t\t\tprops.ctrlKey = evt.ctrlKey;\n\t\t\t\t\t\tprops.metaKey = evt.metaKey;\n\t\t\t\t\t\tprops.shiftKey = evt.shiftKey;\n\t\t\t\t\t\tprops.targetTouches = evt.targetTouches;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn props;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ton(win.doc, \"touchmove\", function(evt){\n\t\t\t\t\tlastTouch = (new Date()).getTime();\n\n\t\t\t\t\tvar newNode = win.doc.elementFromPoint(\n\t\t\t\t\t\tevt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords\n\t\t\t\t\t\tevt.pageY - (ios4 ? 0 : win.global.pageYOffset)\n\t\t\t\t\t);\n\n\t\t\t\t\tif(newNode){\n\t\t\t\t\t\t// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.\n\t\t\t\t\t\tif(hoveredNode !== newNode){\n\t\t\t\t\t\t\t// touch out on the old node\n\t\t\t\t\t\t\ton.emit(hoveredNode, \"dojotouchout\", {\n\t\t\t\t\t\t\t\trelatedTarget: newNode,\n\t\t\t\t\t\t\t\tbubbles: true\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// touchover on the new node\n\t\t\t\t\t\t\ton.emit(newNode, \"dojotouchover\", {\n\t\t\t\t\t\t\t\trelatedTarget: hoveredNode,\n\t\t\t\t\t\t\t\tbubbles: true\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thoveredNode = newNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Unlike a listener on \"touchmove\", on(node, \"dojotouchmove\", listener) fires when the finger\n\t\t\t\t\t\t// drags over the specified node, regardless of which node the touch started on.\n\t\t\t\t\t\tif(!on.emit(newNode, \"dojotouchmove\", copyEventProps(evt))){\n\t\t\t\t\t\t\t// emit returns false when synthetic event \"dojotouchmove\" is cancelled, so we prevent the\n\t\t\t\t\t\t\t// default behavior of the underlying native event \"touchmove\".\n\t\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.\n\t\t\t\t// This is different than the native touchend, which fires on the node where the drag started.\n\t\t\t\ton(win.doc, \"touchend\", function(evt){\n\t\t\t\t\tlastTouch = (new Date()).getTime();\n\t\t\t\t\tvar node = win.doc.elementFromPoint(\n\t\t\t\t\t\tevt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords\n\t\t\t\t\t\tevt.pageY - (ios4 ? 0 : win.global.pageYOffset)\n\t\t\t\t\t) || win.body(); // if out of the screen\n\n\t\t\t\t\ton.emit(node, \"dojotouchend\", copyEventProps(evt));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t//device neutral events - touch.press|move|release|cancel/over/out\n\tvar touch = {\n\t\tpress: dualEvent(\"mousedown\", \"touchstart\", pointer.down),\n\t\tmove: dualEvent(\"mousemove\", \"dojotouchmove\", pointer.move),\n\t\trelease: dualEvent(\"mouseup\", \"dojotouchend\", pointer.up),\n\t\tcancel: dualEvent(mouse.leave, \"touchcancel\", hasTouch ? pointer.cancel : null),\n\t\tover: dualEvent(\"mouseover\", \"dojotouchover\", pointer.over),\n\t\tout: dualEvent(\"mouseout\", \"dojotouchout\", pointer.out),\n\t\tenter: mouse._eventHandler(dualEvent(\"mouseover\",\"dojotouchover\", pointer.over)),\n\t\tleave: mouse._eventHandler(dualEvent(\"mouseout\", \"dojotouchout\", pointer.out))\n\t};\n\n\t/*=====\n\ttouch = {\n\t\t// summary:\n\t\t//\t\tThis module provides unified touch event handlers by exporting\n\t\t//\t\tpress, move, release and cancel which can also run well on desktop.\n\t\t//\t\tBased on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html\n\t\t//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates\n\t\t//      click events immediately for this node and its descendants (except for descendants that\n\t\t//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,\n\t\t//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.\n\t\t//\n\t\t// example:\n\t\t//\t\tUsed with dojo/on\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojo/touch\"], function(on, touch){\n\t\t//\t\t|\t\ton(node, touch.press, function(e){});\n\t\t//\t\t|\t\ton(node, touch.move, function(e){});\n\t\t//\t\t|\t\ton(node, touch.release, function(e){});\n\t\t//\t\t|\t\ton(node, touch.cancel, function(e){});\n\t\t// example:\n\t\t//\t\tUsed with touch.* directly\n\t\t//\t\t|\ttouch.press(node, function(e){});\n\t\t//\t\t|\ttouch.move(node, function(e){});\n\t\t//\t\t|\ttouch.release(node, function(e){});\n\t\t//\t\t|\ttouch.cancel(node, function(e){});\n\t\t// example:\n\t\t//\t\tHave dojo/touch generate clicks without delay, with a default move threshold of 4 pixels\n\t\t//\t\t|\tnode.dojoClick = true;\n\t\t// example:\n\t\t//\t\tHave dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically\n\t\t//\t\t|\tnode.dojoClick = 10;\n\t\t// example:\n\t\t//\t\tHave dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically\n\t\t//\t\t|\tnode.dojoClick = {x:50, y:5};\n\t\t// example:\n\t\t//    Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy\n\t\t//    |  node.dojoClick = false;\t\t\n\n\t\tpress: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to 'touchstart'|'mousedown' for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tmove: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener that fires when the mouse cursor or a finger is dragged over the given node.\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\trelease: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to releasing the mouse button while the cursor is over the given node\n\t\t\t//\t\t(i.e. \"mouseup\") or for removing the finger from the screen while touching the given node.\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tcancel: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to 'touchcancel'|'mouseleave' for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tover: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to 'mouseover' or touch equivalent for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tout: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to 'mouseout' or touch equivalent for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tenter: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to mouse.enter or touch equivalent for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t},\n\t\tleave: function(node, listener){\n\t\t\t// summary:\n\t\t\t//\t\tRegister a listener to mouse.leave or touch equivalent for the given node\n\t\t\t// node: Dom\n\t\t\t//\t\tTarget node to listen to\n\t\t\t// listener: Function\n\t\t\t//\t\tCallback function\n\t\t\t// returns:\n\t\t\t//\t\tA handle which will be used to remove the listener by handle.remove()\n\t\t}\n\t};\n\t=====*/\n\n\thas(\"extend-dojo\") && (dojo.touch = touch);\n\n\treturn touch;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/uacss.js":"define([\"./dom-geometry\", \"./_base/lang\", \"./domReady\", \"./sniff\", \"./_base/window\"],\n\tfunction(geometry, lang, domReady, has, baseWindow){\n\n\t// module:\n\t//\t\tdojo/uacss\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tApplies pre-set CSS classes to the top-level HTML node, based on:\n\t\t//\n\t\t//\t\t- browser (ex: dj_ie)\n\t\t//\t\t- browser version (ex: dj_ie6)\n\t\t//\t\t- box model (ex: dj_contentBox)\n\t\t//\t\t- text direction (ex: dijitRtl)\n\t\t//\n\t\t//\t\tIn addition, browser, browser version, and box model are\n\t\t//\t\tcombined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.\n\t\t//\n\t\t//\t\tReturns the has() method.\n\t};\n\t=====*/\n\n\tvar\n\t\thtml = baseWindow.doc.documentElement,\n\t\tie = has(\"ie\"),\n\t\topera = has(\"opera\"),\n\t\tmaj = Math.floor,\n\t\tff = has(\"ff\"),\n\t\tboxModel = geometry.boxModel.replace(/-/,''),\n\n\t\tclasses = {\n\t\t\t\"dj_quirks\": has(\"quirks\"),\n\n\t\t\t// NOTE: Opera not supported by dijit\n\t\t\t\"dj_opera\": opera,\n\n\t\t\t\"dj_khtml\": has(\"khtml\"),\n\n\t\t\t\"dj_webkit\": has(\"webkit\"),\n\t\t\t\"dj_safari\": has(\"safari\"),\n\t\t\t\"dj_chrome\": has(\"chrome\"),\n\n\t\t\t\"dj_gecko\": has(\"mozilla\"),\n\n\t\t\t\"dj_ios\": has(\"ios\"),\n\t\t\t\"dj_android\": has(\"android\")\n\t\t}; // no dojo unsupported browsers\n\n\tif(ie){\n\t\tclasses[\"dj_ie\"] = true;\n\t\tclasses[\"dj_ie\" + maj(ie)] = true;\n\t\tclasses[\"dj_iequirks\"] = has(\"quirks\");\n\t}\n\tif(ff){\n\t\tclasses[\"dj_ff\" + maj(ff)] = true;\n\t}\n\n\tclasses[\"dj_\" + boxModel] = true;\n\n\t// apply browser, browser version, and box model class names\n\tvar classStr = \"\";\n\tfor(var clz in classes){\n\t\tif(classes[clz]){\n\t\t\tclassStr += clz + \" \";\n\t\t}\n\t}\n\thtml.className = lang.trim(html.className + \" \" + classStr);\n\n\t// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.\n\t// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).\n\tdomReady(function(){\n\t\tif(!geometry.isBodyLtr()){\n\t\t\tvar rtlClassStr = \"dj_rtl dijitRtl \" + classStr.replace(/ /g, \"-rtl \");\n\t\t\thtml.className = lang.trim(html.className + \" \" + rtlClassStr + \"dj_rtl dijitRtl \" + classStr.replace(/ /g, \"-rtl \"));\n\t\t}\n\t});\n\treturn has;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/when.js":"define([\n\t\"./Deferred\",\n\t\"./promise/Promise\"\n], function(Deferred, Promise){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/when\n\n\treturn function when(valueOrPromise, callback, errback, progback){\n\t\t// summary:\n\t\t//\t\tTransparently applies callbacks to values and/or promises.\n\t\t// description:\n\t\t//\t\tAccepts promises but also transparently handles non-promises. If no\n\t\t//\t\tcallbacks are provided returns a promise, regardless of the initial\n\t\t//\t\tvalue. Foreign promises are converted.\n\t\t//\n\t\t//\t\tIf callbacks are provided and the initial value is not a promise,\n\t\t//\t\tthe callback is executed immediately with no error handling. Returns\n\t\t//\t\ta promise if the initial value is a promise, or the result of the\n\t\t//\t\tcallback otherwise.\n\t\t// valueOrPromise:\n\t\t//\t\tEither a regular value or an object with a `then()` method that\n\t\t//\t\tfollows the Promises/A specification.\n\t\t// callback: Function?\n\t\t//\t\tCallback to be invoked when the promise is resolved, or a non-promise\n\t\t//\t\tis received.\n\t\t// errback: Function?\n\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t// progback: Function?\n\t\t//\t\tCallback to be invoked when the promise emits a progress update.\n\t\t// returns: dojo/promise/Promise\n\t\t//\t\tPromise, or if a callback is provided, the result of the callback.\n\n\t\tvar receivedPromise = valueOrPromise && typeof valueOrPromise.then === \"function\";\n\t\tvar nativePromise = receivedPromise && valueOrPromise instanceof Promise;\n\n\t\tif(!receivedPromise){\n\t\t\tif(arguments.length > 1){\n\t\t\t\treturn callback ? callback(valueOrPromise) : valueOrPromise;\n\t\t\t}else{\n\t\t\t\treturn new Deferred().resolve(valueOrPromise);\n\t\t\t}\n\t\t}else if(!nativePromise){\n\t\t\tvar deferred = new Deferred(valueOrPromise.cancel);\n\t\t\tvalueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);\n\t\t\tvalueOrPromise = deferred.promise;\n\t\t}\n\n\t\tif(callback || errback || progback){\n\t\t\treturn valueOrPromise.then(callback, errback, progback);\n\t\t}\n\t\treturn valueOrPromise;\n\t};\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/dojo/window.js":"define([\"./_base/lang\", \"./sniff\", \"./_base/window\", \"./dom\", \"./dom-geometry\", \"./dom-style\", \"./dom-construct\"],\n\tfunction(lang, has, baseWindow, dom, geom, style, domConstruct){\n\n\t// feature detection\n\t/* not needed but included here for future reference\n\thas.add(\"rtl-innerVerticalScrollBar-on-left\", function(win, doc){\n\t\tvar\tbody = baseWindow.body(doc),\n\t\t\tscrollable = domConstruct.create('div', {\n\t\t\t\tstyle: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}\n\t\t\t}, body, \"last\"),\n\t\t\tcenter = domConstruct.create('center', {\n\t\t\t\tstyle: {overflow:'hidden', direction:'ltr'}\n\t\t\t}, scrollable, \"last\"),\n\t\t\tinner = domConstruct.create('div', {\n\t\t\t\tstyle: {overflow:'visible', display:'inline' }\n\t\t\t}, center, \"last\");\n\t\tinner.innerHTML=\"&nbsp;\";\n\t\tvar midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);\n\t\tvar ret = midPoint >= 32;\n\t\tcenter.removeChild(inner);\n\t\tscrollable.removeChild(center);\n\t\tbody.removeChild(scrollable);\n\t\treturn ret;\n\t});\n\t*/\n\thas.add(\"rtl-adjust-position-for-verticalScrollBar\", function(win, doc){\n\t\tvar\tbody = baseWindow.body(doc),\n\t\t\tscrollable = domConstruct.create('div', {\n\t\t\t\tstyle: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}\n\t\t\t}, body, \"last\"),\n\t\t\tdiv = domConstruct.create('div', {\n\t\t\t\tstyle: {overflow:'hidden', direction:'ltr'}\n\t\t\t}, scrollable, \"last\"),\n\t\t\tret = geom.position(div).x != 0;\n\t\tscrollable.removeChild(div);\n\t\tbody.removeChild(scrollable);\n\t\treturn ret;\n\t});\n\n\thas.add(\"position-fixed-support\", function(win, doc){\n\t\t// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed\n\t\tvar\tbody = baseWindow.body(doc),\n\t\t\touter = domConstruct.create('span', {\n\t\t\t\tstyle: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}\n\t\t\t}, body, \"last\"),\n\t\t\tinner = domConstruct.create('span', {\n\t\t\t\tstyle: {position:'fixed', left:'0', top:'0'}\n\t\t\t}, outer, \"last\"),\n\t\t\tret = geom.position(inner).x != geom.position(outer).x;\n\t\touter.removeChild(inner);\n\t\tbody.removeChild(outer);\n\t\treturn ret;\n\t});\n\n\t// module:\n\t//\t\tdojo/window\n\n\tvar window = {\n\t\t// summary:\n\t\t//\t\tTODOC\n\n\t\tgetBox: function(/*Document?*/ doc){\n\t\t\t// summary:\n\t\t\t//\t\tReturns the dimensions and scroll position of the viewable area of a browser window\n\n\t\t\tdoc = doc || baseWindow.doc;\n\n\t\t\tvar\n\t\t\t\tscrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,\n\t\t\t\t// get scroll position\n\t\t\t\tscroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work\n\t\t\t\tw, h;\n\n\t\t\tif(has(\"touch\")){ // if(scrollbars not supported)\n\t\t\t\tvar uiWindow = window.get(doc);   // use UI window, not dojo.global window\n\t\t\t\t// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight\n\t\t\t\tw = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated\n\t\t\t\th = uiWindow.innerHeight || scrollRoot.clientHeight;\n\t\t\t}else{\n\t\t\t\t// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight\n\t\t\t\t// uiWindow.innerWidth/Height includes the scrollbar and cannot be used\n\t\t\t\tw = scrollRoot.clientWidth;\n\t\t\t\th = scrollRoot.clientHeight;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tl: scroll.x,\n\t\t\t\tt: scroll.y,\n\t\t\t\tw: w,\n\t\t\t\th: h\n\t\t\t};\n\t\t},\n\n\t\tget: function(/*Document*/ doc){\n\t\t\t// summary:\n\t\t\t//\t\tGet window object associated with document doc.\n\t\t\t// doc:\n\t\t\t//\t\tThe document to get the associated window for.\n\n\t\t\t// In some IE versions (at least 6.0), document.parentWindow does not return a\n\t\t\t// reference to the real window object (maybe a copy), so we must fix it as well\n\t\t\t// We use IE specific execScript to attach the real window reference to\n\t\t\t// document._parentWindow for later use\n\t\t\tif(has(\"ie\") && window !== document.parentWindow){\n\t\t\t\t/*\n\t\t\t\tIn IE 6, only the variable \"window\" can be used to connect events (others\n\t\t\t\tmay be only copies).\n\t\t\t\t*/\n\t\t\t\tdoc.parentWindow.execScript(\"document._parentWindow = window;\", \"Javascript\");\n\t\t\t\t//to prevent memory leak, unset it after use\n\t\t\t\t//another possibility is to add an onUnload handler which seems overkill to me (liucougar)\n\t\t\t\tvar win = doc._parentWindow;\n\t\t\t\tdoc._parentWindow = null;\n\t\t\t\treturn win;\t//\tWindow\n\t\t\t}\n\n\t\t\treturn doc.parentWindow || doc.defaultView;\t//\tWindow\n\t\t},\n\n\t\tscrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){\n\t\t\t// summary:\n\t\t\t//\t\tScroll the passed node into view using minimal movement, if it is not already.\n\n\t\t\t// Don't rely on node.scrollIntoView working just because the function is there since\n\t\t\t// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.\n\t\t\t// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode\n\t\t\t// and when there's a fixed position scrollable element\n\n\t\t\ttry{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method\n\t\t\t\tnode = dom.byId(node);\n\t\t\t\tvar\tdoc = node.ownerDocument || baseWindow.doc,\t// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?\n\t\t\t\t\tbody = baseWindow.body(doc),\n\t\t\t\t\thtml = doc.documentElement || body.parentNode,\n\t\t\t\t\tisIE = has(\"ie\"),\n\t\t\t\t\tisWK = has(\"webkit\");\n\t\t\t\t// if an untested browser, then use the native method\n\t\t\t\tif(node == body || node == html){ return; }\n\t\t\t\tif(!(has(\"mozilla\") || isIE || isWK || has(\"opera\") || has(\"trident\")) && (\"scrollIntoView\" in node)){\n\t\t\t\t\tnode.scrollIntoView(false); // short-circuit to native if possible\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar\tbackCompat = doc.compatMode == 'BackCompat',\n\t\t\t\t\trootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),\n\t\t\t\t\trootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),\n\t\t\t\t\tscrollRoot = (isWK || backCompat) ? body : html,\n\t\t\t\t\tnodePos = pos || geom.position(node),\n\t\t\t\t\tel = node.parentNode,\n\t\t\t\t\tisFixed = function(el){\n\t\t\t\t\t\treturn (isIE <= 6 || (isIE == 7 && backCompat))\n\t\t\t\t\t\t\t? false\n\t\t\t\t\t\t\t: (has(\"position-fixed-support\") && (style.get(el, 'position').toLowerCase() == \"fixed\"));\n\t\t\t\t\t};\n\t\t\t\tif(isFixed(node)){ return; } // nothing to do\n\t\t\t\twhile(el){\n\t\t\t\t\tif(el == body){ el = scrollRoot; }\n\t\t\t\t\tvar\telPos = geom.position(el),\n\t\t\t\t\t\tfixedPos = isFixed(el),\n\t\t\t\t\t\trtl = style.getComputedStyle(el).direction.toLowerCase() == \"rtl\";\n\n\t\t\t\t\tif(el == scrollRoot){\n\t\t\t\t\t\telPos.w = rootWidth; elPos.h = rootHeight;\n\t\t\t\t\t\tif(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x\n\t\t\t\t\t\tif(elPos.x < 0 || !isIE || isIE >= 9){ elPos.x = 0; } // older IE can have values > 0\n\t\t\t\t\t\tif(elPos.y < 0 || !isIE || isIE >= 9){ elPos.y = 0; }\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar pb = geom.getPadBorderExtents(el);\n\t\t\t\t\t\telPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;\n\t\t\t\t\t\tvar clientSize = el.clientWidth,\n\t\t\t\t\t\t\tscrollBarSize = elPos.w - clientSize;\n\t\t\t\t\t\tif(clientSize > 0 && scrollBarSize > 0){\n\t\t\t\t\t\t\tif(rtl && has(\"rtl-adjust-position-for-verticalScrollBar\")){\n\t\t\t\t\t\t\t\telPos.x += scrollBarSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telPos.w = clientSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclientSize = el.clientHeight;\n\t\t\t\t\t\tscrollBarSize = elPos.h - clientSize;\n\t\t\t\t\t\tif(clientSize > 0 && scrollBarSize > 0){\n\t\t\t\t\t\t\telPos.h = clientSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(fixedPos){ // bounded by viewport, not parents\n\t\t\t\t\t\tif(elPos.y < 0){\n\t\t\t\t\t\t\telPos.h += elPos.y; elPos.y = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(elPos.x < 0){\n\t\t\t\t\t\t\telPos.w += elPos.x; elPos.x = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(elPos.y + elPos.h > rootHeight){\n\t\t\t\t\t\t\telPos.h = rootHeight - elPos.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(elPos.x + elPos.w > rootWidth){\n\t\t\t\t\t\t\telPos.w = rootWidth - elPos.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// calculate overflow in all 4 directions\n\t\t\t\t\tvar\tl = nodePos.x - elPos.x, // beyond left: < 0\n//\t\t\t\t\t\tt = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0\n\t\t\t\t\t\tt = nodePos.y - elPos.y, // beyond top: < 0\n\t\t\t\t\t\tr = l + nodePos.w - elPos.w, // beyond right: > 0\n\t\t\t\t\t\tbot = t + nodePos.h - elPos.h; // beyond bottom: > 0\n\t\t\t\t\tvar s, old;\n\t\t\t\t\tif(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){\n\t\t\t\t\t\ts = Math[l < 0? \"max\" : \"min\"](l, r);\n\t\t\t\t\t\tif(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }\n\t\t\t\t\t\told = el.scrollLeft;\n\t\t\t\t\t\tel.scrollLeft += s;\n\t\t\t\t\t\ts = el.scrollLeft - old;\n\t\t\t\t\t\tnodePos.x -= s;\n\t\t\t\t\t}\n\t\t\t\t\tif(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){\n\t\t\t\t\t\ts = Math.ceil(Math[t < 0? \"max\" : \"min\"](t, bot));\n\t\t\t\t\t\told = el.scrollTop;\n\t\t\t\t\t\tel.scrollTop += s;\n\t\t\t\t\t\ts = el.scrollTop - old;\n\t\t\t\t\t\tnodePos.y -= s;\n\t\t\t\t\t}\n\t\t\t\t\tel = (el != scrollRoot) && !fixedPos && el.parentNode;\n\t\t\t\t}\n\t\t\t}catch(error){\n\t\t\t\tconsole.error('scrollIntoView: ' + error);\n\t\t\t\tnode.scrollIntoView(false);\n\t\t\t}\n\t\t}\n\t};\n\n\thas(\"extend-dojo\") && lang.setObject(\"dojo.window\", window);\n\n\treturn window;\n});\n","/home/travis/build/npmtest/node-npmtest-altair.io/node_modules/altair.io/core/lib/lodash/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.1 <http://lodash.com/>\n * Copyright 2012-2014 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.6.0 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to compose bitmasks for wrapper metadata */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_FLAG = 4,\n      CURRY_BOUND_FLAG = 8,\n      PARTIAL_FLAG = 16,\n      PARTIAL_RIGHT_FLAG = 32;\n\n  /** Used as the semantic version number */\n  var version = '2.4.1';\n\n  /** Used as the property name for wrapper metadata */\n  var expando = '__lodash@' + version + '__';\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to detect words composed of all capital letters */\n  var reAllCaps = /^[A-Z]+$/;\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g;\n\n  /** Used to match template delimiters */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /**\n   * Used to match ES6 template delimiters.\n   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)\n   * for more details.\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to detect hexadecimal string values */\n  var reHexPrefix = /^0[xX]/;\n\n  /** Used to match latin-1 supplement letters */\n  var reLatin1 = /[\\xC0-\\xFF]/g;\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /**\n   * Used to match `RegExp` special characters.\n   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)\n   * for more details.\n   */\n  var reRegExpChars = /[.*+?^${}()|[\\]\\\\]/g;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to match words to create compound words */\n  var reWords = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[a-z]+|[0-9]+/g;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout', 'TypeError', 'window', 'WinRTError'\n  ];\n\n  /** Used to fix the JScript `[[DontEnum]]` bug */\n  var shadowedProps = [\n    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n    'toLocaleString', 'toString', 'valueOf'\n  ];\n\n  /** Used to make template `sourceURL`s easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      errorClass = '[object Error]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object by `_.throttle` */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for wrapper metadata */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /**\n   * Used to convert characters to HTML entities.\n   *\n   * Note: Though the \">\" character is escaped for symmetry, characters like\n   * \">\", \"`\", and \"/\" don't require escaping in HTML and have no special meaning\n   * unless they're part of a tag or unquoted attribute value.\n   * See [Mathias' article](http://mathiasbynens.be/notes/ambiguous-ampersands)\n   * (under \"semi-related fun fact\") for more details.\n   */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to convert HTML entities to characters */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /**\n   * Used to convert latin-1 supplement letters to basic latin (ASCII) letters.\n   * See [Wikipedia](http://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n   * for more details.\n   */\n  var deburredLetters = {\n    '\\xC0': 'A',  '\\xC1': 'A', '\\xC2': 'A', '\\xC3': 'A', '\\xC4': 'A', '\\xC5': 'A',\n    '\\xE0': 'a',  '\\xE1': 'a', '\\xE2': 'a', '\\xE3': 'a', '\\xE4': 'a', '\\xE5': 'a',\n    '\\xC7': 'C',  '\\xE7': 'c',\n    '\\xD0': 'D',  '\\xF0': 'd',\n    '\\xC8': 'E',  '\\xC9': 'E', '\\xCA': 'E', '\\xCB': 'E',\n    '\\xE8': 'e',  '\\xE9': 'e', '\\xEA': 'e', '\\xEB': 'e',\n    '\\xCC': 'I',  '\\xCD': 'I', '\\xCE': 'I', '\\xCF': 'I',\n    '\\xEC': 'i',  '\\xED': 'i', '\\xEE': 'i', '\\xEF': 'i',\n    '\\xD1': 'N',  '\\xF1': 'n',\n    '\\xD2': 'O',  '\\xD3': 'O', '\\xD4': 'O', '\\xD5': 'O', '\\xD6': 'O', '\\xD8': 'O',\n    '\\xF2': 'o',  '\\xF3': 'o', '\\xF4': 'o', '\\xF5': 'o', '\\xF6': 'o', '\\xF8': 'o',\n    '\\xD9': 'U',  '\\xDA': 'U', '\\xDB': 'U', '\\xDC': 'U',\n    '\\xF9': 'u',  '\\xFA': 'u', '\\xFB': 'u', '\\xFC': 'u',\n    '\\xDD': 'Y',  '\\xFD': 'y', '\\xFF': 'y',\n    '\\xC6': 'AE', '\\xE6': 'ae',\n    '\\xDE': 'Th', '\\xFE': 'th',\n    '\\xDF': 'ss', '\\xD7': ' ', '\\xF7': ' '\n  };\n\n  /** Used to determine if values are of the language type `Object` */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Used by `_.defaults` to customize its `_.assign` use.\n   *\n   * @private\n   * @param {*} objectValue The destination object property value.\n   * @param {*} sourceValue The source object property value.\n   * @returns {*} Returns the value to assign to the destination object.\n   */\n  function assignDefaults(objectValue, sourceValue) {\n    return typeof objectValue == 'undefined' ? sourceValue : objectValue;\n  }\n\n  /**\n   * The base implementation of `compareAscending` used to compare values and\n   * sort them in ascending order without guaranteeing a stable sort.\n   *\n   * @private\n   * @param {*} value The value to compare to `other`.\n   * @param {*} other The value to compare to `value`.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function baseCompareAscending(value, other) {\n    if (value !== other) {\n      if (value > other || typeof value == 'undefined') {\n        return 1;\n      }\n      if (value < other || typeof other == 'undefined') {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    return cache.has(value) ? 0 : -1;\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the code unit of the first character of the string.\n   */\n  function charAtCallback(string) {\n    return string.charCodeAt(0);\n  }\n\n  /**\n   * Gets the index of the first character of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the first character not found in `chars`.\n   */\n  function charsLeftIndex(string, chars) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length) {\n      if (chars.indexOf(string.charAt(index)) < 0) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the index of the last character of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the last character not found in `chars`.\n   */\n  function charsRightIndex(string, chars) {\n    var index = string.length;\n    while (index--) {\n      if (chars.indexOf(string.charAt(index)) < 0) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n   * sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareAscending(object, other) {\n    return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare multiple properties of each element in a\n   * collection and stable sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultipleAscending(object, other) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length;\n\n    while (++index < length) {\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        return result;\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value\n    // for `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90\n    return object.index - other.index;\n  }\n\n  /**\n   * Creates a function that produces compound words out of the words in a\n   * given string.\n   *\n   * @private\n   * @param {Function} callback The function called to combine each word.\n   * @returns {Function} Returns the new compounder function.\n   */\n  function createCompounder(callback) {\n    return function(string) {\n      var index = -1,\n          words = string != null && String(string).replace(reLatin1, deburrLetter).match(reWords),\n          length = words ? words.length : 0,\n          result = '';\n\n      while (++index < length) {\n        result = callback(result, words[index], index, words);\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Used by `createCompounder` to convert latin-1 supplement letters to basic\n   * latin (ASCII) letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Checks if `value` is a DOM node in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a DOM node, else `false`.\n   */\n  function isNode(value) {\n    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`\n    // methods that are `typeof` \"string\" and still can coerce nodes to strings\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\n  }\n\n  /**\n   * A fallback implementation of `String#trim` to remove leading and trailing\n   * whitespace or specified characters from `string`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @param {string} [chars=whitespace] The characters to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function shimTrim(string, chars) {\n    string = string == null ? '' : String(string);\n    if (!string) {\n      return string;\n    }\n    if (chars == null) {\n      return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n    }\n    chars = String(chars);\n    return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n  }\n\n  /**\n   * A fallback implementation of `String#trimLeft` to remove leading whitespace or\n   * specified characters from `string`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @param {string} [chars=whitespace] The characters to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function shimTrimLeft(string, chars) {\n    string = string == null ? '' : String(string);\n    if (!string) {\n      return string;\n    }\n    if (chars == null) {\n      return string.slice(trimmedLeftIndex(string))\n    }\n    chars = String(chars);\n    return string.slice(charsLeftIndex(string, chars));\n  }\n\n  /**\n   * A fallback implementation of `String#trimRight` to remove trailing whitespace or\n   * specified characters from `string`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @param {string} [chars=whitespace] The characters to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function shimTrimRight(string, chars) {\n    string = string == null ? '' : String(string);\n    if (!string) {\n      return string;\n    }\n    if (chars == null) {\n      return string.slice(0, trimmedRightIndex(string) + 1)\n    }\n    chars = String(chars);\n    return string.slice(0, charsRightIndex(string, chars) + 1);\n  }\n\n  /**\n   * Gets the index of the first non-whitespace character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the first non-whitespace character.\n   */\n  function trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length) {\n      var c = string.charCodeAt(index);\n      if (!((c <= 160 && (c >= 9 && c <= 13) || c == 32 || c == 160) || c == 5760 || c == 6158 ||\n          (c >= 8192 && (c <= 8202 || c == 8232 || c == 8233 || c == 8239 || c == 8287 || c == 12288 || c == 65279)))) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the index of the last non-whitespace character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedRightIndex(string) {\n    var index = string.length;\n    while (index--) {\n      var c = string.charCodeAt(index);\n      if (!((c <= 160 && (c >= 9 && c <= 13) || c == 32 || c == 160) || c == 5760 || c == 6158 ||\n          (c >= 8192 && (c <= 8202 || c == 8232 || c == 8233 || c == 8239 || c == 8287 || c == 12288 || c == 65279)))) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for native method references */\n    var arrayRef = Array.prototype,\n        errorProto = Error.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to detect DOM support */\n    var document = (document = context.window) && document.document;\n\n    /** Used to restore the original `_` reference in `_.noConflict` */\n    var oldDash = context._;\n\n    /**\n     * Used as the maximum length of an array-like object.\n     * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n     * for more details.\n     */\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n\n    /** Used to resolve the internal `[[Class]]` of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      escapeRegExp(toString)\n      .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        Set = isNative(Set = context.Set) && Set,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set metadata on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeContains = isNative(nativeContains = stringProto.contains) && nativeContains,\n        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = isNative(nativeNow = Date.now) && nativeNow,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeTrim = isNative(nativeTrim = stringProto.trim) && !nativeTrim.call(whitespace) && nativeTrim,\n        nativeTrimLeft = isNative(nativeTrimLeft = stringProto.trimLeft) && !nativeTrimLeft.call(whitespace) && nativeTrimLeft,\n        nativeTrimRight = isNative(nativeTrimRight = stringProto.trimRight) && !nativeTrimRight.call(whitespace) && nativeTrimRight;\n\n    /** Used to lookup a built-in constructor by `[[Class]]` */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /** Used to avoid iterating over non-enumerable properties in IE < 9 */\n    var nonEnumProps = {};\n    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };\n    nonEnumProps[objectClass] = { 'constructor': true };\n\n    (function() {\n      var length = shadowedProps.length;\n      while (length--) {\n        var key = shadowedProps[length];\n        for (var className in nonEnumProps) {\n          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {\n            nonEnumProps[className][key] = false;\n          }\n        }\n      }\n    }());\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `at`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `constant`, `countBy`, `create`, `createCallback`,\n     * `curry`, `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`,\n     * `flatten`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,\n     * `forOwnRight`, `functions`, `groupBy`, `indexBy`, `initial`, `intersection`,\n     * `invert`, `invoke`, `keys`, `map`, `mapValues`, `matches`, `max`, `memoize`,\n     * `merge`, `min`, `noop`, `object`, `omit`, `once`, `pairs`, `partial`,\n     * `partialRight`, `pick`, `pluck`, `property`, `pull`, `push`, `range`,\n     * `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`,\n     * `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`, `union`,\n     * `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`, `xor`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `capitalize`, `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`,\n     * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`,\n     * `identity`, `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`,\n     * `isElement`, `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`,\n     * `isNull`, `isNumber`, `isObject`, `isPlainObject`, `isRegExp`, `isString`,\n     * `isUndefined`, `join`, `lastIndexOf`, `mixin`, `noConflict`, `now`,\n     * `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `result`, `shift`,\n     * `size`, `some`, `sortedIndex`, `runInContext`, `template`, `trim`,\n     * `trimLeft`, `trimRight`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first`, `last`, and `sample` return wrapped values\n     * when `n` is provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} [chainAll=false] A flag to enable chaining for all methods.\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    (function(x) {\n      var ctor = function() { this.x = 1; },\n          object = { '0': 1, 'length': 1 },\n          props = [];\n\n      ctor.prototype = { 'valueOf': 1, 'y': 1 };\n      for (var key in new ctor) { props.push(key); }\n      for (var argsKey in arguments) { }\n      for (var strKey in 'x') { }\n\n      /**\n       * Detect if an `arguments` object's `[[Class]]` is resolvable\n       * (all but Firefox < 4, IE < 9).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.argsClass = toString.call(arguments) == argsClass;\n\n      /**\n       * Detect if `arguments` objects are `Object` objects\n       * (all but Narwhal and Opera < 10.5).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);\n\n      /**\n       * Detect if `name` or `message` properties of `Error.prototype` are\n       * enumerable by default (IE < 9, Safari < 5.1).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\n        propertyIsEnumerable.call(errorProto, 'name');\n\n      /**\n       * Detect if `prototype` properties are enumerable by default.\n       *\n       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\n       * (if the prototype or a property on the prototype has been set)\n       * incorrectly sets the `[[Enumerable]]` value of a function's `prototype`\n       * property to `true`.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');\n\n      /**\n       * Detect if functions can be decompiled by `Function#toString`\n       * (all but PS3 and older Opera mobile browsers; forced `false` for Windows 8 apps).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n      /**\n       * Detect if `Function#name` is supported (all but IE).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcNames = typeof Function.name == 'string';\n\n      /**\n       * Detect if string indexes are non-enumerable\n       * (IE < 9, RingoJS, Rhino, Narwhal).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.nonEnumStrings = strKey != '0';\n\n      /**\n       * Detect if properties shadowing those on `Object.prototype` are\n       * non-enumerable.\n       *\n       * In IE < 9 an object's own properties, shadowing non-enumerable ones,\n       * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.nonEnumShadows = !/valueOf/.test(props);\n\n      /**\n       * Detect if own properties are iterated after inherited properties\n       * (all but IE < 9).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.ownLast = props[0] != 'x';\n\n      /**\n       * Detect if `Array#shift` and `Array#splice` augment array-like objects\n       * correctly.\n       *\n       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`\n       * and `splice()` functions that fail to remove the last element, `value[0]`,\n       * of array-like objects even though the `length` property is set to `0`.\n       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`\n       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode\n       * in IE 9.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\n\n      /**\n       * Detect lack of support for accessing string characters by index.\n       *\n       * IE < 8 can't access characters by index. IE 8 can only access characters\n       * by index on string literals, not string objects.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\n\n      /**\n       * Detect if the DOM is supported.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.dom = false;\n//        support.dom = document.createDocumentFragment().nodeType === 11;\n      } catch(e) {\n        support.dom = false;\n      }\n\n      /**\n       * Detect if a DOM node's `[[Class]]` is resolvable (all but IE < 9)\n       * and that the JS engine errors when attempting to coerce an object to\n       * a string without a `toString` function.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));\n      } catch(e) {\n        support.nodeClass = true;\n      }\n\n      /**\n       * Detect if `arguments` object indexes are non-enumerable.\n       *\n       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n       * checks for indexes that exceed their function's formal parameters with\n       * associated values of `0`.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.nonEnumArgs = !(argsKey == '1' && hasOwnProperty.call(arguments, argsKey) &&\n          propertyIsEnumerable.call(arguments, argsKey));\n      } catch(e) {\n        support.nonEnumArgs = true;\n      }\n    }(0, 0));\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those\n     * in embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its metadata.\n     *\n     * @private\n     * @param {Array} data The metadata array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(data) {\n      var func = data[0],\n          thisArg = data[3],\n          partialArgs = data[4],\n          partialHolders = data[6];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object use disqualifying optimizations by\n          // converting it to an array before passing it to `composeArgs`\n          var index = -1,\n              length = arguments.length,\n              args = Array(length);\n\n          while (++index < length) {\n            args[index] = arguments[index];\n          }\n          args = composeArgs(partialArgs, partialHolders, args);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setData(bound, data);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `this` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect `[[Class]]`\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        stackA || (stackA = []);\n        stackB || (stackB = []);\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? baseEach : baseForOwn)(value, function(valValue, key) {\n        result[key] = baseClone(valValue, isDeep, callback, stackA, stackB);\n      });\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for environments without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var data = func[expando];\n      if (typeof data == 'undefined') {\n        if (support.funcNames) {\n          data = !func.name;\n        }\n        data = data || !support.funcDecomp;\n        if (!data) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            data = !reFuncName.test(source);\n          }\n          if (!data) {\n            // checks if `func` references the `this` keyword and stores the result\n            data = reThis.test(source);\n            setData(func, data);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (data === false || (data !== true && data[1] & BIND_FLAG)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(value, other) {\n          return func.call(thisArg, value, other);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its metadata.\n     *\n     * @private\n     * @param {Array} data The metadata array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(data) {\n      var func = data[0],\n          bitmask = data[1],\n          arity = data[2],\n          thisArg = data[3],\n          partialArgs = data[4],\n          partialRightArgs = data[5],\n          partialHolders = data[6],\n          partialRightHolders = data[7];\n\n      var isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n          key = func;\n\n      function bound() {\n        var index = -1,\n            length = arguments.length,\n            args = Array(length);\n\n        while (++index < length) {\n          args[index] = arguments[index];\n        }\n        if (partialArgs) {\n          args = composeArgs(partialArgs, partialHolders, args);\n        }\n        if (partialRightArgs) {\n          args = composeArgsRight(partialRightArgs, partialRightHolders, args);\n        }\n        if (isCurry) {\n          var newPartialHolders = getHolders(args);\n          length -= newPartialHolders.length;\n\n          if (length < arity) {\n            bitmask |= PARTIAL_FLAG;\n            bitmask &= ~PARTIAL_RIGHT_FLAG\n            if (!isCurryBound) {\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n            }\n            var newArity = nativeMax(arity - length, 0);\n            return baseCreateWrapper([func, bitmask, newArity, thisArg, args, null, newPartialHolders]);\n          }\n        }\n        var thisBinding = isBind ? thisArg : this;\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setData(bound, data);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          prereq = indexOf === baseIndexOf,\n          isLarge = prereq && createCache && values && values.length >= 200,\n          isCommon = prereq && !isLarge,\n          result = [],\n          valuesLength = values ? values.length : 0;\n\n      if (isLarge) {\n        indexOf = cacheIndexOf;\n        values = createCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index];\n\n        if (isCommon) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === value) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    function baseEach(collection, callback) {\n      var index = -1,\n          iterable = collection,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {\n        if (support.unindexedChars && isString(iterable)) {\n          iterable = iterable.split('');\n        }\n        while (++index < length) {\n          if (callback(iterable[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        baseForOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * The base implementation of `_.forEachRight` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    function baseEachRight(collection, callback) {\n      var iterable = collection,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {\n        if (support.unindexedChars && isString(iterable)) {\n          iterable = iterable.split('');\n        }\n        while (length--) {\n          if (callback(iterable[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        baseForOwnRight(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`\n     * without support for callback shorthands or `this` binding which iterates\n     * over `collection` using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function} predicate The function called per iteration.\n     * @param {Function} eachFunc The function to iterate over the collection.\n     * @param {boolean} [retKey=false] A flag to indicate returning the key of\n     *  the found element instead of the element itself.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFind(collection, predicate, eachFunc, retKey) {\n      var result;\n\n      eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n          result = retKey ? key : value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` executing the callback\n     * for each property. Callbacks may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    function baseFor(object, callback, keysFunc) {\n      var index = -1,\n          props = keysFunc(object),\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForRight(object, callback, keysFunc) {\n      var props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, callback) {\n      return baseFor(object, callback, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, callback) {\n      return baseFor(object, callback, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for callback\n     * shorthands or `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} callback The function called per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, callback) {\n      return baseForRight(object, callback, keys);\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg`\n     * binding, that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} value The value to compare to `other`.\n     * @param {*} other The value to compare to `value`.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, callback, isWhere, stackA, stackB) {\n      if (callback) {\n        var result = callback(value, other);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (value === other) {\n        // treat `+0` vs. `-0` as not equal\n        return value !== 0 || (1 / value == 1 / other);\n      }\n      var valType = typeof value,\n          othType = typeof other;\n\n      // exit early for unlike primitive values\n      if (value === value && (value == null || other == null ||\n          (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object'))) {\n        return false;\n      }\n      // compare `[[Class]]` names\n      var valClass = toString.call(value),\n          othClass = toString.call(other),\n          valIsArg = valClass == argsClass,\n          othIsArg = othClass == argsClass;\n\n      if (valIsArg) {\n        valClass = objectClass;\n      }\n      if (othIsArg) {\n        othClass = objectClass;\n      }\n      if (valClass != othClass) {\n        return false;\n      }\n      switch (valClass) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +value == +other;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (value != +value)\n            ? other != +other\n            // but treat `-0` vs. `+0` as not equal\n            : (value == 0 ? (1 / value == 1 / other) : value == +other);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return value == String(other);\n      }\n      var isArr = valClass == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var valWrapped = hasOwnProperty.call(value, '__wrapped__'),\n            othWrapped = hasOwnProperty.call(other, '__wrapped__');\n\n        if (valWrapped || othWrapped) {\n          return baseIsEqual(valWrapped ? value.__wrapped__ : value, othWrapped ? other.__wrapped__ : other, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (valClass != objectClass || (!support.nodeClass && (isNode(value) || isNode(other)))) {\n          return false;\n        }\n        if (!support.argsObject) {\n          valIsArg = isArguments(value);\n          othIsArg = isArguments(other);\n        }\n        var hasValCtor = !valIsArg && hasOwnProperty.call(value, 'constructor'),\n            hasOthCtor = !othIsArg && hasOwnProperty.call(other, 'constructor');\n\n        if (hasValCtor != hasOthCtor) {\n          return false;\n        }\n        if (!hasValCtor) {\n          // in older versions of Opera, `arguments` objects have `Array` constructors\n          var valCtor = valIsArg ? Object : value.constructor,\n              othCtor = othIsArg ? Object : other.constructor;\n\n          // non `Object` object instances with different constructors are not equal\n          if (valCtor != othCtor &&\n                !(isFunction(valCtor) && valCtor instanceof valCtor && isFunction(othCtor) && othCtor instanceof othCtor) &&\n                ('constructor' in value && 'constructor' in other)\n              ) {\n            return false;\n          }\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length] == other;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `value` and `other` to the stack of traversed objects\n      stackA.push(value);\n      stackB.push(other);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = value.length;\n        size = other.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                othValue = other[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(value[index], othValue, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(value[size], othValue, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        baseForIn(other, function(othValue, key, other) {\n          if (hasOwnProperty.call(other, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(value, key) && baseIsEqual(value[key], othValue, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          baseForIn(value, function(valValue, key, value) {\n            if (hasOwnProperty.call(value, key)) {\n              // `size` will be `-1` if `value` has more properties than `other`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `this` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? baseEach : baseForOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          prereq = !isSorted && indexOf === baseIndexOf,\n          isLarge = prereq && createCache && length >= 200,\n          isCommon = prereq && !isLarge,\n          result = [];\n\n      if (isLarge) {\n        var seen = createCache();\n        indexOf = cacheIndexOf;\n      } else {\n        seen = (callback && !isSorted) ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isCommon) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (callback) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (isSorted) {\n          if (!index || seen !== computed) {\n            seen = computed;\n            result.push(value);\n          }\n        }\n        else if (indexOf(seen, computed) < 0) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * returned by `keysFunc`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, keysFunc) {\n      var index = -1,\n          props = keysFunc(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} partialArgs An array of arguments to prepend to those provided.\n     * @param {Array} partialHolders An array of `partialArgs` placeholder indexes.\n     * @param {Array|Object} args The provided arguments.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(partialArgs, partialHolders, args) {\n      var holdersLength = partialHolders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partialArgs.length,\n          result = Array(argsLength + leftLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partialArgs[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[partialHolders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} partialRightArgs An array of arguments to append to those provided.\n     * @param {Array} partialHolders An array of `partialRightArgs` placeholder indexes.\n     * @param {Array|Object} args The provided arguments.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(partialRightArgs, partialRightHolders, args) {\n      var holdersIndex = -1,\n          holdersLength = partialRightHolders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partialRightArgs.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var pad = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[pad + rightIndex] = partialRightArgs[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[pad + partialRightHolders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object or\n     * array composed from the results of running each element in the collection\n     * through a callback. The given setter function sets the keys and values of\n     * the composed object or array.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @param {boolean} [retArray=false] A flag to indicate that the aggregator\n     *  function should return an array.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, retArray) {\n      return function(collection, callback, thisArg) {\n        var result = retArray ? [[], []] : {};\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a cache object to optimize linear searches of large arrays.\n     *\n     * @private\n     * @param {Array} [array=[]] The array to search.\n     * @returns {Object} Returns the new cache object.\n     */\n    var createCache = Set && function(array) {\n      var cache = new Set,\n          length = array ? array.length : 0;\n\n      cache.push = cache.add;\n      while (length--) {\n        cache.push(array[length]);\n      }\n      return cache;\n    };\n\n    /**\n     * Creates the pad required for `string` based on the given padding length.\n     * The `chars` string may be truncated if the number of padding characters\n     * exceeds the padding length.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the pad for `string`.\n     */\n    function createPad(string, length, chars) {\n      var strLength = string.length;\n      length = +length;\n\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars == null ? ' ' : String(chars);\n      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with an optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1  - `_.bind`\n     *  2  - `_.bindKey`\n     *  4  - `_.curry`\n     *  8  - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {number} [arity] The arity of `func`.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, arity, thisArg, partialArgs, partialRightArgs) {\n      var isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isPartial = bitmask & PARTIAL_FLAG,\n          isPartialRight = bitmask & PARTIAL_RIGHT_FLAG;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~PARTIAL_FLAG;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~PARTIAL_RIGHT_FLAG;\n        isPartialRight = partialRightArgs = false;\n      }\n      var data = !isBindKey && func[expando];\n      if (data && data !== true) {\n        // shallow clone `data`\n        data = slice(data);\n\n        // clone partial left arguments\n        if (data[4]) {\n          data[4] = slice(data[4]);\n        }\n        // clone partial right arguments\n        if (data[5]) {\n          data[5] = slice(data[5]);\n        }\n        // set arity if provided\n        if (typeof arity == 'number') {\n          data[2] = arity;\n        }\n        // set `thisArg` if not previously bound\n        var bound = data[1] & BIND_FLAG;\n        if (isBind && !bound) {\n          data[3] = thisArg;\n        }\n        // set if currying a bound function\n        if (!isBind && bound) {\n          bitmask |= CURRY_BOUND_FLAG;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          if (data[4]) {\n            push.apply(data[4], partialArgs);\n          } else {\n            data[4] = partialArgs;\n          }\n        }\n        // prepend partial right arguments\n        if (isPartialRight) {\n          if (data[5]) {\n            unshift.apply(data[5], partialRightArgs);\n          } else {\n            data[5] = partialRightArgs;\n          }\n        }\n        // merge flags\n        data[1] |= bitmask;\n        return createWrapper.apply(null, data);\n      }\n      if (isPartial) {\n        var partialHolders = getHolders(partialArgs);\n      }\n      if (isPartialRight) {\n        var partialRightHolders = getHolders(partialRightArgs);\n      }\n      if (arity == null) {\n        arity = isBindKey ? 0 : func.length;\n      }\n      arity = nativeMax(arity, 0);\n\n      // fast path for `_.bind`\n      data = [func, bitmask, arity, thisArg, partialArgs, partialRightArgs, partialHolders, partialRightHolders];\n      return (bitmask == BIND_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG))\n        ? baseBind(data)\n        : baseCreateWrapper(data);\n    }\n\n    /**\n     * Finds the indexes of all placeholder elements in `array`.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new array of placeholder indexes.\n     */\n    function getHolders(array) {\n      var index = -1,\n          length = array.length,\n          result = [];\n\n      while (++index < length) {\n        if (array[index] === lodash) {\n          result.push(index);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(fnToString.call(value));\n    }\n\n    /**\n     * Sets wrapper metadata on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, expando, descriptor);\n    };\n\n    /**\n     * A fallback implementation of `_.isPlainObject` which checks if `value` is\n     * an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and\n     * that there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non `Object` objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (!hasOwnProperty.call(value, 'constructor') &&\n            (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) ||\n          (!support.argsClass && isArguments(value)) ||\n          (!support.nodeClass && isNode(value))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      if (support.ownLast) {\n        baseForIn(value, function(value, key, object) {\n          result = hasOwnProperty.call(object, key);\n          return false;\n        });\n        return result !== false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      baseForIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n      var keyIndex,\n          index = -1,\n          props = keysIn(object),\n          length = props.length,\n          objLength = length && object.length,\n          maxIndex = objLength - 1,\n          result = [];\n\n      var allowIndexes = typeof objLength == 'number' && objLength > 0 &&\n        (isArray(object) || (support.nonEnumArgs && isArguments(object)) ||\n          (support.nonEnumStrings && isString(object)));\n\n      while (++index < length) {\n        var key = props[index];\n        if ((allowIndexes && (keyIndex = +key, keyIndex > -1 && keyIndex <= maxIndex && keyIndex % 1 == 0)) ||\n            hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3], [5, 2, 10]);\n     * // => [1, 3]\n     */\n    function difference() {\n      return baseDifference(arguments[0], baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3], 1);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    var drop = rest;\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3], 1);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    var dropRight = initial;\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements will be dropped until the predicate returns falsey. The predicate\n     * is bound to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per element.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRightWhile([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'employer': 'slate' },\n     *   { 'name': 'fred',    'employer': 'slate', 'blocked': true },\n     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.dropRightWhile(characters, 'blocked'), 'name');\n     * // => ['barney']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.dropRightWhile(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    var dropRightWhile = initial;\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements will be dropped until the predicate returns falsey. The predicate\n     * is bound to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per element.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropWhile([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'employer': 'slate', 'blocked': true },\n     *   { 'name': 'fred',    'employer': 'slate' },\n     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.dropWhile(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.dropWhile(characters, { 'employer': 'slate' }), 'name');\n     * // => ['pebbles']\n     */\n    var dropWhile = rest;\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element the predicate returns truthy for, instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, predicate, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a collection from right to left.\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      while (length--) {\n        if (predicate(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * Note: The `n` and `predicate` arguments are deprecated; replace with\n     * `_.take` and `_.takeWhile` respectively.\n     *\n     * @static\n     * @memberOf _\n     * @alias head\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([]);\n     * // => undefined\n     */\n    function first(array, predicate, thisArg) {\n      if (typeof predicate != 'number' && predicate != null) {\n        var index = -1,\n            length = array ? array.length : 0,\n            n = 0;\n\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        while (++index < length && predicate(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = predicate;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truthy, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback] The function called per iteration.\n     *  If a property name or object is provided it will be used to create a \"_.pluck\"\n     *  or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * // using `isShallow`\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      // juggle arguments\n      var type = typeof isShallow;\n      if (type != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = isShallow;\n        isShallow = false;\n\n        // enables use as a callback for functions like `_.map`\n        if ((type == 'number' || type == 'string') && thisArg && thisArg[callback] === array) {\n          callback = null;\n        }\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * // performing a binary search\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return (length && array[index] === value) ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * Note: The `n` and `predicate` arguments are deprecated; replace with\n     * `_.dropRight` and `_.dropRightWhile` respectively.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n\n      if (typeof predicate != 'number' && predicate != null) {\n        var index = length,\n            n = 0;\n\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        while (index-- && predicate(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (predicate == null || thisArg) ? 1 : predicate;\n      }\n      n = length - (n || 0);\n      return slice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = [],\n          indexOf = getIndexOf(),\n          prereq = createCache && indexOf === baseIndexOf;\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(prereq && value.length >= 120 &&\n            createCache(argsIndex && value));\n        }\n      }\n      argsLength = args.length;\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [],\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        value = array[index];\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {\n          argsIndex = argsLength;\n          while (--argsIndex) {\n            var cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(value);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * Note: The `n` and `predicate` arguments are deprecated; replace with\n     * `_.takeRight` and `_.takeRightWhile` respectively.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array, predicate, thisArg) {\n      var length = array ? array.length : 0;\n\n      if (typeof predicate != 'number' && predicate != null) {\n        var index = length,\n            n = 0;\n\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        while (index-- && predicate(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = predicate;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      n = length - (n || 0);\n      return slice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If `fromIndex` is negative,\n     * it is used as the offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(index + fromIndex, 0) : nativeMin(fromIndex || 0, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var argsIndex = 0,\n          argsLength = arguments.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = arguments[argsIndex];\n\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Removes all elements from an array that the predicate returns truthy for\n     * and returns an array of removed elements. The predicate is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, predicate, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * Note: The `n` and `predicate` arguments are deprecated; replace with\n     * `_.drop` and `_.dropWhile` respectively.\n     *\n     * @static\n     * @memberOf _\n     * @alias tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function rest(array, predicate, thisArg) {\n      if (typeof predicate != 'number' && predicate != null) {\n        var index = -1,\n            length = array ? array.length : 0,\n            n = 0;\n\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        while (++index < length && predicate(array[index], index, array)) {\n          n++;\n        }\n      } else if (predicate == null || thisArg) {\n        n = 1;\n      } else {\n        n = predicate < 0 ? 0 : predicate;\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Slices `array` from the `start` index up to, but not including, the `end` index.\n     *\n     * Note: This function is used instead of `Array#slice` to support node lists\n     * in IE < 9 and to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start index.\n     * @param {number} [end=array.length] The end index.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      start = typeof start == 'undefined' ? 0 : (+start || 0);\n      if (start < 0) {\n        start = nativeMax(length + start, 0);\n      } else if (start > length) {\n        start = length;\n      }\n      end = typeof end == 'undefined' ? length : (+end || 0);\n      if (end < 0) {\n        end = nativeMax(length + end, 0);\n      } else if (end > length) {\n        end = length;\n      }\n      length = start > end ? 0 : (end - start);\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[start + index];\n      }\n      return result;\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * // using `callback`\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * // using `callback` with `thisArg`\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? (low = mid + 1)\n          : (high = mid);\n      }\n      return low;\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3], 1);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    var take = first;\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3], 1);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    var takeRight = last;\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements will\n     * be taken until the predicate returns falsey. The predicate is bound to\n     * `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per element.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRightWhile([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'employer': 'slate' },\n     *   { 'name': 'fred',    'employer': 'slate', 'blocked': true },\n     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.takeRightWhile(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.takeRightWhile(characters, { 'employer': 'na' }), 'name');\n     * // => ['pebbles']\n     */\n    var takeRightWhile = last;\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * will be taken until the predicate returns falsey. The predicate is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per element.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeWhile([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'employer': 'slate', 'blocked': true },\n     *   { 'name': 'fred',    'employer': 'slate' },\n     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.takeWhile(characters, 'blocked'), 'name');\n     * // => ['barney']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.takeWhile(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    var takeWhile = first;\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback] The function called per iteration.\n     *  If a property name or object is provided it will be used to create a \"_.pluck\"\n     *  or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * // using `isSorted`\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * // using `callback`\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * // using `callback` with `thisArg`\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      // juggle arguments\n      var type = typeof isSorted;\n      if (type != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = isSorted;\n        isSorted = false;\n\n        // enables use as a callback for functions like `_.map`\n        if ((type == 'number' || type == 'string') && thisArg && thisArg[callback] === array) {\n          callback = null;\n        }\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without() {\n      return baseDifference(arguments[0], slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See [Wikipedia](http://en.wikipedia.org/wiki/Symmetric_difference) for\n     * more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseDifference(result, array).concat(baseDifference(array, result))\n            : array;\n        }\n      }\n      return result ? baseUniq(result) : [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on. If a zipped value is provided its corresponding\n     * unzipped value will be returned.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip([['fred', 30, true], ['barney', 40, false]]);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method\n     * chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      return new lodashWrapper(value, true);\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n     * this method is to \"tap into\" a method chain in order to perform operations\n     * on intermediate results within the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor, thisArg) {\n      interceptor.call(thisArg, value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the result of coercing the wrapped value to a string.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the coerced string value.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias toJSON, value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes to retrieve,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns the array of picked elements.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection, guard) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = props.length,\n          type = typeof guard;\n\n      // enables use as a callback for functions like `_.map`\n      if ((type == 'number' || type == 'string') && args[2] && args[2][guard] === collection) {\n        length = 1;\n      }\n      if (support.unindexedChars && isString(collection)) {\n        collection = collection.split('');\n      }\n      var result = Array(length);\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the target element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var length = collection ? collection.length : 0;\n      if (!(typeof length == 'number' && length > -1 && length <= maxSafeInteger)) {\n        var props = keys(collection);\n        length = props.length;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      } else {\n        fromIndex = 0;\n      }\n      if (props) {\n        while (fromIndex < length) {\n          var value = collection[props[fromIndex++]];\n          if (value === target) {\n            return true;\n          }\n        }\n        return false;\n      }\n      if (typeof collection == 'string' || !isArray(collection) && isString(collection)) {\n        if (fromIndex >= length) {\n          return false;\n        }\n        return nativeContains\n          ? nativeContains.call(collection, target, fromIndex)\n          : collection.indexOf(target, fromIndex) > -1;\n      }\n      var indexOf = getIndexOf();\n      return indexOf(collection, target, fromIndex) > -1;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the predicate returns truthy for **all** elements of a collection.\n     * The predicate is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if all elements passed the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, predicate, thisArg) {\n      var result = true;\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if (!predicate(collection[index], index, collection)) {\n            return false;\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          return (result = !!predicate(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection returning an array of all elements\n     * the predicate returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4], function(num) { return num % 2 == 0; });\n     * // => [2, 4]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36 }]\n     */\n    function filter(collection, predicate, thisArg) {\n      var result = [];\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (predicate(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          if (predicate(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the predicate returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1 }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, predicate, thisArg) {\n      if (isArray(collection)) {\n        var index = findIndex(collection, predicate, thisArg);\n        return index > -1 ? collection[index] : undefined;\n      }\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      return baseFind(collection, predicate, baseEach);\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of a\n     * collection from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, predicate, thisArg) {\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      return baseFind(collection, predicate, baseEachRight);\n    }\n\n    /**\n     * Iterates over elements of a collection executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        baseEach(collection, baseCreateCallback(callback, thisArg, 3));\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * a collection from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {\n        var length = collection.length;\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        baseEachRight(collection, baseCreateCallback(callback, thisArg, 3));\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the collection\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] Arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection && collection.length,\n          result = Array(length < 0 ? 0 : length >>> 0);\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? methodName : (value != null && value[methodName]);\n        result[++index] = func ? func.apply(value, args) : undefined;\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection && collection.length,\n          result = Array(length < 0 ? 0 : length >>> 0);\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (isArray(collection)) {\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        baseEach(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback] The function called per iteration.\n     *  If a property name or object is provided it will be used to create a \"_.pluck\"\n     *  or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed,\n          type = typeof callback;\n\n      // enables use as a callback for functions like `_.map`\n      if ((type == 'number' || type == 'string') && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        baseEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback] The function called per iteration.\n     *  If a property name or object is provided it will be used to create a \"_.pluck\"\n     *  or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed,\n          type = typeof callback;\n\n      // enables use as a callback for functions like `_.map`\n      if ((type == 'number' || type == 'string') && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        baseEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements the predicate returns truthy for, while the second of which\n     * contains elements the predicate returns falsey for. The predicate is bound\n     * to `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.partition([1, 2, 3], function(num) { return num % 2; });\n     * // => [[1, 3], [2]]\n     *\n     * _.partition([1.2, 2.3, 3.4], function(num) { return this.floor(num) % 2; }, Math);\n     * // => [[1, 3], [2]]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * // using \"_.where\" callback shorthand\n     * _.map(_.partition(characters, { 'age': 1 }), function(array) { return _.pluck(array, 'name'); });\n     * // => [['pebbles'], ['barney', 'fred']]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.partition(characters, 'blocked'), function(array) { return _.pluck(array, 'name'); });\n     * // => [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, true);\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} key The name of the property to pluck.\n     * @returns {Array} Returns the property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n\n      callback = lodash.createCallback(callback, thisArg, 4);\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        if (noaccum && length) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of a\n     * collection from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n\n      callback = lodash.createCallback(callback, thisArg, 4);\n      baseEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of a collection\n     * the predicate does **not** return truthy for.\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4], function(num) { return num % 2 == 0; });\n     * // => [1, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36 }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, predicate, thisArg) {\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      return filter(collection, negate(predicate));\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {*} Returns the random sample(s).\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      } else if (support.unindexedChars && isString(collection)) {\n        collection = collection.split('');\n      }\n      if (n == null || guard) {\n        var length = collection ? collection.length : 0;\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See [Wikipedia](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection && collection.length,\n          result = Array(length < 0 ? 0 : length >>> 0);\n\n      baseEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n\n      return result;\n    }\n\n    /**\n     * Gets the size of the collection by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return (typeof length == 'number' && length > -1 && length <= maxSafeInteger)\n        ? length\n        : keys(collection).length;\n    }\n\n    /**\n     * Checks if the predicate returns truthy for **any** element of a collection.\n     * The function returns as soon as it finds a passing value and does not iterate\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\n     * with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if any element passed the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, predicate, thisArg) {\n      var result;\n\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if (predicate(collection[index], index, collection)) {\n            return true;\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          return !(result = predicate(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function\n     *  called per iteration. If a property name or object is provided it will\n     *  be used to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          length = collection && collection.length,\n          multi = callback && isArray(callback),\n          result = Array(length < 0 ? 0 : length >>> 0);\n\n      if (!multi) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      baseEach(collection, function(value, key, collection) {\n        if (multi) {\n          var length = callback.length,\n              criteria = Array(length);\n\n          while (length--) {\n            criteria[length] = value[callback[length]];\n          }\n        } else {\n          criteria = callback(value, key, collection);\n        }\n        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };\n      });\n\n      length = result.length;\n      result.sort(multi ? compareMultipleAscending : compareAscending);\n      while (length--) {\n        result[length] = result[length].value;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      var length = collection && collection.length;\n      if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {\n        return (support.unindexedChars && isString(collection))\n          ? collection.split('')\n          : slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} source The object of property values to filter by.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      n = nativeIsFinite(n = +n) ? n : 0;\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `bind` arguments to those provided to the bound\n     * function.\n     *\n     * Note: Unlike native `Function#bind` this method does not set the `length`\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [args] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      if (arguments.length < 3) {\n        return createWrapper(func, BIND_FLAG, null, thisArg);\n      }\n      if (func) {\n        var arity = func[expando] ? func[expando][2] : func.length,\n            partialArgs = slice(arguments, 2);\n\n        arity -= partialArgs.length;\n      }\n      return createWrapper(func, BIND_FLAG | PARTIAL_FLAG, arity, thisArg, partialArgs);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * Note: This method does not set the `length` property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], BIND_FLAG, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `bindKey` arguments to those provided to the bound function.\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that will be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [args] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length < 3\n        ? createWrapper(key, BIND_FLAG | BIND_KEY_FLAG, null, object)\n        : createWrapper(key, BIND_FLAG | BIND_KEY_FLAG | PARTIAL_FLAG, null, object, slice(arguments, 2));\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [funcs] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          funcsLength = funcs.length,\n          length = funcsLength;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var length = funcsLength - 1,\n            result = funcs[length].apply(this, arguments);\n\n        while (length--) {\n          result = funcs[length].call(this, result);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * Note: This method does not set the `length` property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      if (typeof arity != 'number') {\n        arity = +arity || (func ? func.length : 0);\n      }\n      return createWrapper(func, CURRY_FLAG, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true`, `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = wait < 0 ? 0 : wait;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && nativeMax(wait, +options.maxWait || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [args] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : '_' + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` function is executed with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(num) {\n     *   return num % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (!isFunction(predicate)) {\n        throw new TypeError;\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with any additional `partial` arguments\n     * prepended to those provided to the new function. This method is similar to\n     * `_.bind` except it does **not** alter the `this` binding.\n     *\n     * Note: This method does not set the `length` property of partially applied\n     * functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [args] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      if (func) {\n        var arity = func[expando] ? func[expando][2] : func.length,\n            partialArgs = slice(arguments, 1);\n\n        arity -= partialArgs.length;\n      }\n      return createWrapper(func, PARTIAL_FLAG, arity, null, partialArgs);\n    }\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * Note: This method does not set the `length` property of partially applied\n     * functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [args] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      if (func) {\n        var arity = func[expando] ? func[expando][2] : func.length,\n            partialRightArgs = slice(arguments, 1);\n\n        arity -= partialRightArgs.length;\n      }\n      return createWrapper(func, PARTIAL_RIGHT_FLAG, arity, null, null, partialRightArgs);\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true`, `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = +wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, PARTIAL_FLAG, null, null, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(value, other) {\n     *   return typeof value == 'undefined' ? other : value;\n     * });\n     *\n     * defaults({ 'name': 'barney' }, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    function assign(object, source, guard) {\n      var args = arguments;\n      if (!object || args.length < 2) {\n        return object;\n      }\n      var argsIndex = 0,\n          argsLength = args.length,\n          type = typeof guard;\n\n      // enables use as a callback for functions like `_.reduce`\n      if ((type == 'number' || type == 'string') && args[3] && args[3][guard] === source) {\n        argsLength = 2;\n      }\n      // juggle arguments\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        source = args[argsIndex];\n        var index = -1,\n            props = keys(source),\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          object[key] = callback ? callback(object[key], source[key]) : source[key];\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      var type = typeof isDeep;\n\n      // juggle arguments\n      if (type != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n\n        // enables use as a callback for functions like `_.map`\n        if ((type == 'number' || type == 'string') && thisArg && thisArg[callback] === value) {\n          callback = null;\n        }\n      }\n      callback = typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1);\n      return baseClone(value, isDeep, callback);\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      callback = typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1);\n      return baseClone(value, true, callback);\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.defaults({ 'name': 'barney' }, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    function defaults(object) {\n      if (!object || arguments.length < 2) {\n        return object;\n      }\n      var args = slice(arguments);\n      args.push(assignDefaults);\n      return assign.apply(null, args);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element the predicate returns truthy for, instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': { 'age': 36 },\n     *   'fred': { 'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1 }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, predicate, thisArg) {\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      return baseFind(object, predicate, baseForOwn, true);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * If a property name is provided for `predicate` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `predicate` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': { 'age': 36, 'blocked': true },\n     *   'fred': { 'age': 40 },\n     *   'pebbles': { 'age': 1, 'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate, thisArg) {\n      predicate = lodash.createCallback(predicate, thisArg, 3);\n      return baseFind(object, predicate, baseForOwnRight, true);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object executing\n     * the callback for each property. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, key, object). Callbacks may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'z' (property order is not guaranteed across environments)\n     */\n    function forIn(object, callback, thisArg) {\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      return baseFor(object, callback, keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements of a\n     * collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'z', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'z'\n     */\n    function forInRight(object, callback, thisArg) {\n      callback = baseCreateCallback(callback, thisArg, 3);\n      return baseForRight(object, callback, keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    function forOwn(object, callback, thisArg) {\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      return baseForOwn(object, callback);\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements of a\n     * collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      callback = baseCreateCallback(callback, thisArg, 3);\n      return baseForRight(object, callback, keys);\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new sorted array of property names.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n\n      baseForIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given\n     * object. If the given object contains duplicate values, subsequent values\n     * will overwrite property assignments of previous values unless `multiValue`\n     * is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiValue=false] Allow multiple values per key.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     *\n     * // without `multiValue`\n     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });\n     * // => { 'fred': 'third', 'barney': 'second' }\n     *\n     * // with `multiValue`\n     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);\n     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }\n     */\n    function invert(object, multiValue) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (multiValue) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })();\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n    // fallback for environments that can't detect `arguments` objects by `[[Class]]`\n    if (!support.argsClass) {\n      isArguments = function(value) {\n        return value && typeof value == 'object' && typeof value.length == 'number' &&\n          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;\n      };\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Wed May 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return value && typeof value == 'object' && value.nodeType === 1 &&\n        (support.nodeClass ? toString.call(value).indexOf('Element') > -1 : isNode(value)) || false;\n    }\n    // fallback for environments without DOM support\n    if (!support.dom) {\n      isElement = function(value) {\n        return value && typeof value == 'object' && value.nodeType === 1 &&\n          !isPlainObject(value) || false;\n      };\n    }\n\n    /**\n     * Checks if a collection is empty. A value is considered empty unless it is\n     * an array, array-like object, or string with a length greater than `0` or\n     * an object with own properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if (length > -1 && length <= maxSafeInteger && (\n            (className == arrayClass || className == stringClass ||\n              (support.argsClass ? className == argsClass : isArguments(value))) ||\n            (className == objectClass && isFunction(value.splice))\n          )) {\n        return !length;\n      }\n      baseForOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent. If a callback is provided it will be executed to compare\n     * values. If the callback returns `undefined` comparisons will be handled\n     * by the method instead. The callback is bound to `thisArg` and invoked\n     * with two arguments; (value, other).\n     *\n     * Note: This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Functions and DOM nodes\n     * are **not** supported. A callback may be used to extend support for\n     * comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to compare to `other`.\n     * @param {*} other The value to compare to `value`.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var other = { 'name': 'fred' };\n     *\n     * object == other;\n     * // => false\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function() {\n     *   return _.every(arguments, _.bind(RegExp.prototype.test, /^h(?:i|ello)$/)) || undefined;\n     * });\n     * // => true\n     */\n    function isEqual(value, other, callback, thisArg) {\n      callback = typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2);\n\n      if (!callback) {\n        // exit early for identical values\n        if (value === other) {\n          // treat `-0` vs. `+0` as not equal\n          return value !== 0 || (1 / value == 1 / other);\n        }\n        var valType = typeof value,\n            othType = typeof other;\n\n        // exit early for unlike primitive values\n        if (value === value && (value == null || other == null ||\n            (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object'))) {\n          return false;\n        }\n      }\n      return baseIsEqual(value, other, callback);\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This method is not the same as native `isFinite` which will return\n     * `true` for booleans and empty strings. See the [ES5 spec](http://es5.github.io/#x15.1.2.5)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n    // fallback for older versions of Chrome and Safari\n    if (isFunction(/x/)) {\n      isFunction = function(value) {\n        return typeof value == 'function' && toString.call(value) == funcClass;\n      };\n    }\n\n    /**\n     * Checks if `value` is the language type of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of `Object`\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // https://code.google.com/p/v8/issues/detail?id=2291\n      var type = typeof value;\n      return value && (type == 'function' || type == 'object') || false;\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This method is not the same as native `isNaN` which will return `true`\n     * for `undefined` and other non-numeric values. See the [ES5 spec](http://es5.github.io/#x15.1.2.4)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the `[[Class]]` check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See the [ES5 spec](http://es5.github.io/#x8.5)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4);\n     * // => true\n     *\n     * _.isNumber(NaN);\n     * // => true\n     *\n     * _.isNumber('8.4');\n     * // => false\n     */\n    function isNumber(value) {\n      var type = typeof value;\n      return type == 'number' ||\n        value && type == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      var type = typeof value;\n      return value && (type == 'function' || type == 'object') &&\n        toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.keys(new Shape);\n     * // => ['x', 'y'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      var length = object ? object.length : 0;\n      if (typeof length == 'number' && length > 0) {\n        return shimKeys(object);\n      }\n      return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.keysIn(new Shape);\n     * // => ['x', 'y', 'z'] (property order is not guaranteed across environments)\n     */\n    function keysIn(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      var length = object.length;\n      length = (typeof length == 'number' && length > 0 &&\n        (isArray(object) || (support.nonEnumStrings && isString(object)) ||\n          (support.nonEnumArgs && isArguments(object))) && length) >>> 0;\n\n      var keyIndex,\n          index = -1,\n          maxIndex = length - 1,\n          result = Array(length),\n          skipIndexes = length > 0,\n          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\n          skipProto = support.enumPrototypes && typeof object == 'function';\n\n      while (++index < length) {\n        result[index] = String(index);\n      }\n      for (var key in object) {\n        if (!(skipProto && key == 'prototype') &&\n            !(skipErrorProps && (key == 'message' || key == 'name')) &&\n            !(skipIndexes && (keyIndex = +key, keyIndex > -1 && keyIndex <= maxIndex && keyIndex % 1 == 0))) {\n          result.push(key);\n        }\n      }\n      // Lo-Dash skips the `constructor` property when it infers it's iterating\n      // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\n      // attribute of an existing property and the `constructor` property of a\n      // prototype defaults to non-enumerable.\n      if (support.nonEnumShadows && object !== objectProto) {\n        var ctor = object.constructor;\n        index = -1;\n        length = shadowedProps.length;\n\n        if (object === (ctor && ctor.prototype)) {\n          var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),\n              nonEnum = nonEnumProps[className];\n        }\n        while (++index < length) {\n          key = shadowedProps[index];\n          if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {\n            result.push(key);\n          }\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      baseForOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object, source, guard) {\n      if (!object) {\n        return object;\n      }\n      var args = arguments,\n          length = args.length,\n          type = typeof guard;\n\n      // enables use as a callback for functions like `_.reduce`\n      if ((type == 'number' || type == 'string') && args[3] && args[3][guard] === source) {\n        length = 2;\n      }\n      // juggle arguments\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(args, 1, length),\n          index = -1,\n          stackA = [],\n          stackB = [];\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a predicate is provided it will be executed for each\n     * property of `object` omitting the properties the predicate returns truthy\n     * for. The predicate is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [predicate] The function called per\n     *  iteration or property names to omit, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, predicate, thisArg) {\n      if (typeof predicate == 'function') {\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        return pick(object, negate(predicate));\n      }\n      var omitProps = baseFlatten(arguments, true, false, 1),\n          length = omitProps.length;\n\n      while (length--) {\n        omitProps[length] = String(omitProps[length]);\n      }\n      return pick(object, baseDifference(keysIn(object),  omitProps));\n    }\n\n    /**\n     * Creates a two dimensional array of a given object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a predicate is provided it will be executed for each\n     * property of `object` picking the properties the predicate returns truthy\n     * for. The predicate is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [predicate] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, predicate, thisArg) {\n      var result = {};\n\n      if (typeof predicate != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        predicate = lodash.createCallback(predicate, thisArg, 3);\n        baseForIn(object, function(value, key, object) {\n          if (predicate(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? baseEach : baseForOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Shape(x, y) {\n     *   this.x = x;\n     *   this.y = y;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.values(new Shape(2, 1));\n     * // => [2, 1] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      return baseValues(object, keys);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values\n     * of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Shape(x, y) {\n     *   this.x = x;\n     *   this.y = y;\n     * }\n     *\n     * Shape.prototype.z = 0;\n     *\n     * _.valuesIn(new Shape(2, 1));\n     * // => [2, 1, 0] (property order is not guaranteed across environments)\n     */\n    function valuesIn(object) {\n      return baseValues(object, keysIn);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to camel case.\n     * See [Wikipedia](http://en.wikipedia.org/wiki/CamelCase) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to camel case.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Hello world');\n     * // => 'helloWorld'\n     *\n     * _.camelCase('--hello-world');\n     * // => 'helloWorld'\n     *\n     * _.camelCase('__hello_world__');\n     * // => 'helloWorld'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      if (!index && reAllCaps.test(word)) {\n        return result + word.toLowerCase();\n      }\n      return result + (word.charAt(0)[index ? 'toUpperCase' : 'toLowerCase']() + word.slice(1));\n    });\n\n    /**\n     * Capitalizes the first character of `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('fred');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      if (string == null) {\n        return '';\n      }\n      string = String(string);\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n\n    /**\n     * Checks if `string` ends with a given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if the given string ends with the\n     *  target string, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = string == null ? '' : String(string);\n      target = String(target);\n\n      var length = string.length;\n      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to\n     * their corresponding HTML entities.\n     *\n     * Note: No other characters are escaped. To escape additional characters\n     * use a third-party library like [_he_](http://mths.be/he).\n     *\n     * When working with HTML you should always quote attribute values to reduce\n     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"\\\", \"^\", \"$\", \".\", \"|\", \"?\", \"*\",\n     * \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](http://lodash.com)');\n     * // => '\\[lodash\\]\\(http://lodash\\.com\\)'\n     */\n    function escapeRegExp(string) {\n      return string == null ? '' : String(string).replace(reRegExpChars, '\\\\$&');\n    }\n\n    /**\n     * Converts `string` to kebab case (a.k.a. spinal case).\n     * See [Wikipedia](http://en.wikipedia.org/wiki/Letter_case#Computers) for\n     * more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to kebab case.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Hello world');\n     * // => 'hello-world'\n     *\n     * _.kebabCase('helloWorld');\n     * // => 'hello-world'\n     *\n     * _.kebabCase('__hello_world__');\n     * // => 'hello-world'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Pads `string` on the left and right sides if it is shorter then the given\n     * padding length. The `chars` string may be truncated if the number of padding\n     * characters can't be evenly divided by the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = string == null ? '' : String(string);\n      length = +length;\n\n      var strLength = string.length;\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = floor(mid),\n          rightLength = ceil(mid);\n\n      chars = createPad('', rightLength, chars);\n      return chars.slice(0, leftLength) + string + chars;\n    }\n\n    /**\n     * Pads `string` on the left side if it is shorter then the given padding\n     * length. The `chars` string may be truncated if the number of padding\n     * characters exceeds the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padLeft('abc', 6);\n     * // => '   abc'\n     *\n     * _.padLeft('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padLeft('abc', 3);\n     * // => 'abc'\n     */\n    function padLeft(string, length, chars) {\n      string = string == null ? '' : String(string);\n      return createPad(string, length, chars) + string;\n    }\n\n    /**\n     * Pads `string` on the right side if it is shorter then the given padding\n     * length. The `chars` string may be truncated if the number of padding\n     * characters exceeds the padding length.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padRight('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padRight('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padRight('abc', 3);\n     * // => 'abc'\n     */\n    function padRight(string, length, chars) {\n      string = string == null ? '' : String(string);\n      return string + createPad(string, length, chars);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      var result = '';\n      n = +n;\n\n      if (n < 1 || string == null || !nativeIsFinite(n)) {\n        return result;\n      }\n      string = String(string);\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = floor(n / 2);\n        string += string;\n      } while (n);\n      return result;\n    }\n\n    /**\n     * Converts `string` to snake case.\n     * See [Wikipedia](http://en.wikipedia.org/wiki/Snake_case) for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to snake case.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Hello world');\n     * // => 'hello_world'\n     *\n     * _.snakeCase('--hello-world');\n     * // => 'hello_world'\n     *\n     * _.snakeCase('helloWorld');\n     * // => 'hello_world'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Checks if `string` starts with a given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if the given string starts with the\n     *  target string, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = string == null ? '' : String(string);\n      position = typeof position == 'undefined' ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escaped interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. If\n     * a data object is provided the interpolated template string will be returned.\n     * Data properties may be accessed as free variables in the template. If a\n     * settings object is provided it will override `_.templateSettings` for the\n     * template.\n     *\n     * Note: In the development build, `_.template` utilizes `sourceURL`s for easier debugging.\n     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for more details.\n     *\n     * For more information on precompiling templates see\n     * [Lo-Dash's custom builds documentation](http://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](http://developer.chrome.com/stable/extensions/sandboxingEval.html).\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The template string.\n     * @param {Object} [data] The data object used to populate the template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The `sourceURL` of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @returns {Function|string} Returns the interpolated string if a data object\n     *  is provided, else the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom `sourceURL` for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      options = defaults({}, options, settings);\n      string = String(string == null ? '' : string);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a `sourceURL` for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  fred  ');\n     * // => 'fred'\n     *\n     * _.trim('-_-fred-_-', '_-');\n     * // => 'fred'\n     */\n    var trim = !nativeTrim ? shimTrim : function(string, chars) {\n      if (string == null) {\n        return '';\n      }\n      return chars == null ? nativeTrim.call(string) : shimTrim(string, chars);\n    };\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimLeft('  fred  ');\n     * // => 'fred  '\n     *\n     * _.trimLeft('-_-fred-_-', '_-');\n     * // => 'fred-_-'\n     */\n    var trimLeft = !nativeTrimLeft ? shimTrimLeft : function(string, chars) {\n      if (string == null) {\n        return '';\n      }\n      return chars == null ? nativeTrimLeft.call(string) : shimTrimLeft(string, chars);\n    };\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimRight('  fred  ');\n     * // => '  fred'\n     *\n     * _.trimRight('-_-fred-_-', '_-');\n     * // => '-_-fred'\n     */\n    var trimRight = !nativeTrimRight ? shimTrimRight : function(string, chars) {\n      if (string == null) {\n        return '';\n      }\n      return chars == null ? nativeTrimRight.call(string) : shimTrimRight(string, chars);\n    };\n\n    /**\n     * Truncates `string` if it is longer than the given maximum string length.\n     * The last characters of the truncated string will be replaced with the\n     * omission string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object|number} [options] The options object or maximum string length.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string used to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', 24);\n     * // => 'hi-diddly-ho there, n...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });\n     * //=> 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = 30,\n          omission = '...';\n\n      if (options && isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? +options.length || 0 : length;\n        omission = 'omission' in options ? String(options.omission) : omission;\n      }\n      else if (options != null) {\n        length = +options || 0;\n      }\n      string = string == null ? '' : String(string);\n      if (length >= string.length) {\n        return string;\n      }\n      var end = length - omission.length;\n      if (end < 1) {\n        return omission;\n      }\n      var result = string.slice(0, end);\n      if (separator == null) {\n        return result + omission;\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              newEnd,\n              substring = string.slice(0, end);\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            newEnd = match.index;\n          }\n          result = result.slice(0, newEnd == null ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * Note: No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](http://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category Strings\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney &amp; pebbles');\n     * // => 'fred, barney & pebbles'\n     */\n    function unescape(string) {\n      if (string == null) {\n        return '';\n      }\n      string = String(string);\n      return string.indexOf(';') < 0 ? string : string.replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Creates a function bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias callback\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (type == 'function' || func == null) {\n        return (typeof thisArg == 'undefined' || !('prototype' in func)) &&\n          func || baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" and \"_.where\" style callback shorthands\n      return type != 'object' ? property(func) : matches(func);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a \"_.where\" style predicate function which performs a deep comparison\n     * between a given object and the `source` object, returning `true` if the given\n     * object has equivalent property values, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var matchesAge = _.matches({ 'age': 36 });\n     *\n     * _.filter(characters, matchesAge);\n     * // => [{ 'name': 'barney', 'age': 36 }]\n     *\n     * _.find(characters, matchesAge);\n     * // => { 'name': 'barney', 'age': 36 }\n     */\n    function matches(source) {\n      source || (source = {});\n      var props = keys(source),\n          propsLength = props.length,\n          key = props[0],\n          value = source[key];\n\n      // fast path the common case of providing an object with a single\n      // property containing a primitive value\n      if (propsLength == 1 && value === value && !isObject(value)) {\n        return function(object) {\n          if (!(object && hasOwnProperty.call(object, key))) {\n            return false;\n          }\n          // treat `-0` vs. `+0` as not equal\n          var other = object[key];\n          return value === other && (value !== 0 || (1 / value == 1 / other));\n        };\n      }\n      return function(object) {\n        var length = propsLength;\n        if (length && !object) {\n          return false;\n        }\n        var result = true;\n        while (length--) {\n          var key = props[length];\n          if (!(result = hasOwnProperty.call(object, key) &&\n              baseIsEqual(object[key], source[key], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var index = -1,\n          isFunc = isFunction(object),\n          length = methodNames ? methodNames.length : 0;\n\n      while (++index < length) {\n        var methodName = methodNames[index],\n            func = object[methodName] = source[methodName];\n\n        if (isFunc) {\n          object.prototype[methodName] = (function(func) {\n            return function() {\n              var chainAll = this.__chain__,\n                  value = this.__wrapped__,\n                  args = [value];\n\n              push.apply(args, arguments);\n              var result = func.apply(object, args);\n              if (chain || chainAll) {\n                if (value === result && isObject(result)) {\n                  return this;\n                }\n                result = new object(result);\n                result.__chain__ = chainAll;\n              }\n              return result;\n            };\n          }(func));\n        }\n      }\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = nativeNow || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts `value` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See the [ES5 spec](http://es5.github.io/#E)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow ES3  for `parseInt` and\n      // Chrome fails to trim leading <BOM> whitespace characters.\n      // See https://code.google.com/p/v8/issues/detail?id=3109\n      value = trim(value);\n      return nativeParseInt(value, +radix || (reHexPrefix.test(value) ? 16 : 10));\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truthy or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (noMax && typeof min == 'boolean') {\n          floating = min;\n          min = 1;\n        }\n        else if (typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n        noMax = false;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = step == null ? 1 : (+step || 0);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(ceil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result\n     * returned, else the property value is returned. If `object` is `null` or\n     * `undefined` then `undefined` is returned. If a default value is provided\n     * it will be returned if the property value resolves to `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the property value\n     *  resolves to `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'age': function() {\n     *     return 40;\n     *   }\n     * };\n     *\n     * _.result(object, 'name');\n     * // => 'fred'\n     *\n     * _.result(object, 'age');\n     * // => 40\n     *\n     * _.result(object, 'employer', 'slate');\n     * // => 'slate'\n     */\n    function result(object, key, defaultValue) {\n      var value = object == null ? undefined : object[key];\n      if (typeof value == 'undefined') {\n        return defaultValue;\n      }\n      return isFunction(value) ? object[key]() : value;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = n < 0 ? 0 : n >>> 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.negate = negate;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.callback = createCallback;\n    lodash.collect = map;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(assign({}, lodash));\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.endsWith = endsWith;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.kebabCase = kebabCase;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padLeft = padLeft;\n    lodash.padRight = padRight;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.snakeCase = snakeCase;\n    lodash.startsWith = startsWith;\n    lodash.template = template;\n    lodash.trim = trim;\n    lodash.trimLeft = trimLeft;\n    lodash.trimRight = trimRight;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      baseForOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n\n    // add aliases\n    lodash.head = first;\n\n    baseForOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = version;\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toJSON = wrapperValueOf;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    baseEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    baseEach(['concat', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    // avoid array-like object bugs with `Array#shift` and `Array#splice`\n    // in IE < 9, Firefox < 10, Narwhal, and RingoJS\n    if (!support.spliceObjects) {\n      baseEach(['pop', 'shift', 'splice'], function(methodName) {\n        var func = arrayRef[methodName],\n            isSplice = methodName == 'splice';\n\n        lodash.prototype[methodName] = function() {\n          var chainAll = this.__chain__,\n              value = this.__wrapped__,\n              result = func.apply(value, arguments);\n\n          if (value.length === 0) {\n            delete value[0];\n          }\n          return (chainAll || isSplice)\n            ? new lodashWrapper(result, chainAll)\n            : result;\n        };\n      });\n    }\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // export Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n"}